const micro = @import("microzig");
const mmio = micro.mmio;

pub const devices = struct {
    /// LPC54628J512ET180
    pub const LPC54628 = struct {
        pub const properties = struct {
            pub const @"cpu.endian" = "little";
            pub const @"cpu.fpuPresent" = "true";
            pub const @"cpu.mpuPresent" = "true";
            pub const @"cpu.name" = "CM4";
            pub const @"cpu.nvicPrioBits" = "3";
            pub const @"cpu.revision" = "r0p1";
            pub const @"cpu.vendorSystickConfig" = "false";
            pub const @"cpu.vtorPresent" = "true";
            pub const license =
                \\
                \\Copyright 2016-2022 NXP
                \\All rights reserved.
                \\
                \\SPDX-License-Identifier: BSD-3-Clause
                \\  
            ;
        };
        pub const VectorTable = extern struct {
            const Handler = micro.interrupt.Handler;
            const unhandled = micro.interrupt.unhandled;

            initial_stack_pointer: u32,
            Reset: Handler,
            NMI: Handler = unhandled,
            HardFault: Handler = unhandled,
            MemManageFault: Handler = unhandled,
            BusFault: Handler = unhandled,
            UsageFault: Handler = unhandled,
            reserved5: [4]u32 = undefined,
            SVCall: Handler = unhandled,
            reserved10: [2]u32 = undefined,
            PendSV: Handler = unhandled,
            SysTick: Handler = unhandled,
            WDT_BOD: Handler = unhandled,
            DMA0: Handler = unhandled,
            GINT0: Handler = unhandled,
            reserved17: [1]u32 = undefined,
            PIN_INT0: Handler = unhandled,
            PIN_INT1: Handler = unhandled,
            PIN_INT2: Handler = unhandled,
            PIN_INT3: Handler = unhandled,
            UTICK0: Handler = unhandled,
            MRT0: Handler = unhandled,
            CTIMER0: Handler = unhandled,
            reserved25: [1]u32 = undefined,
            SCT0: Handler = unhandled,
            reserved27: [1]u32 = undefined,
            FLEXCOMM0: Handler = unhandled,
            reserved29: [5]u32 = undefined,
            FLEXCOMM6: Handler = unhandled,
            reserved35: [1]u32 = undefined,
            ADC0_SEQA: Handler = unhandled,
            ADC0_SEQB: Handler = unhandled,
            ADC0_THCMP: Handler = unhandled,
            DMIC0: Handler = unhandled,
            HWVAD0: Handler = unhandled,
            USB0_NEEDCLK: Handler = unhandled,
            USB0: Handler = unhandled,
            RTC: Handler = unhandled,
            reserved44: [2]u32 = undefined,
            PIN_INT4: Handler = unhandled,
            PIN_INT5: Handler = unhandled,
            PIN_INT6: Handler = unhandled,
            PIN_INT7: Handler = unhandled,
            reserved50: [2]u32 = undefined,
            RIT: Handler = unhandled,
            SPIFI0: Handler = unhandled,
            reserved54: [2]u32 = undefined,
            SDIO: Handler = unhandled,
            CAN0_IRQ0: Handler = unhandled,
            CAN0_IRQ1: Handler = unhandled,
            reserved59: [2]u32 = undefined,
            USB1: Handler = unhandled,
            USB1_NEEDCLK: Handler = unhandled,
            ETHERNET: Handler = unhandled,
            ETHERNET_PMT: Handler = unhandled,
            ETHERNET_MACLP: Handler = unhandled,
            EEPROM: Handler = unhandled,
            LCD: Handler = unhandled,
            reserved68: [1]u32 = undefined,
            SMARTCARD0: Handler = unhandled,
        };

        pub const peripherals = struct {
            /// LPC5460x System configuration (SYSCON)
            pub const SYSCON: *volatile types.peripherals.SYSCON = @ptrFromInt(0x40000000);
            /// LPC5411x I/O pin configuration (IOCON)
            pub const IOCON: *volatile types.peripherals.IOCON = @ptrFromInt(0x40001000);
            /// LPC5411x Group GPIO input interrupt (GINT0/1)
            pub const GINT0: *volatile types.peripherals.GINT0 = @ptrFromInt(0x40002000);
            /// LPC5411x Group GPIO input interrupt (GINT0/1)
            pub const GINT1: *volatile types.peripherals.GINT0 = @ptrFromInt(0x40003000);
            /// LPC5411x Pin interrupt and pattern match (PINT)
            pub const PINT: *volatile types.peripherals.PINT = @ptrFromInt(0x40004000);
            /// LPC5411x Input multiplexing (INPUT MUX)
            pub const INPUTMUX: *volatile types.peripherals.INPUTMUX = @ptrFromInt(0x40005000);
            /// LPC5411x Standard counter/timers (CTIMER0 to 4)
            pub const CTIMER0: *volatile types.peripherals.CTIMER0 = @ptrFromInt(0x40008000);
            /// LPC5411x Standard counter/timers (CTIMER0 to 4)
            pub const CTIMER1: *volatile types.peripherals.CTIMER0 = @ptrFromInt(0x40009000);
            /// LPC5411x Windowed Watchdog Timer (WWDT)
            pub const WWDT: *volatile types.peripherals.WWDT = @ptrFromInt(0x4000c000);
            /// LPC5411x Multi-Rate Timer (MRT)
            pub const MRT0: *volatile types.peripherals.MRT0 = @ptrFromInt(0x4000d000);
            /// LPC5411x Micro-tick Timer (UTICK)
            pub const UTICK0: *volatile types.peripherals.UTICK0 = @ptrFromInt(0x4000e000);
            /// LPC5460x EEPROM controller
            pub const EEPROM: *volatile types.peripherals.EEPROM = @ptrFromInt(0x40014000);
            /// This is the description of component otpc It is an eFUSE OTP (One Time Programmable memory) controller with APB bus interface. More details will follow.
            pub const OTPC: *volatile types.peripherals.OTPC = @ptrFromInt(0x40015000);
            /// LPC5411x Standard counter/timers (CTIMER0 to 4)
            pub const CTIMER2: *volatile types.peripherals.CTIMER0 = @ptrFromInt(0x40028000);
            /// LPC5411x Real-Time Clock (RTC)
            pub const RTC: *volatile types.peripherals.RTC = @ptrFromInt(0x4002c000);
            /// LPC5460x Repetitive Interrupt Timer(RIT)
            pub const RIT: *volatile types.peripherals.RIT = @ptrFromInt(0x4002d000);
            /// LPC5460x Flash signature generator
            pub const FMC: *volatile types.peripherals.FMC = @ptrFromInt(0x40034000);
            /// LPC5460x Smart Card Interface
            pub const SMARTCARD0: *volatile types.peripherals.SMARTCARD0 = @ptrFromInt(0x40036000);
            /// LPC5460x Smart Card Interface
            pub const SMARTCARD1: *volatile types.peripherals.SMARTCARD0 = @ptrFromInt(0x40037000);
            /// LPC5411x Asynchronous system configuration (ASYNC_SYSCON)
            pub const ASYNC_SYSCON: *volatile types.peripherals.ASYNC_SYSCON = @ptrFromInt(0x40040000);
            /// LPC5411x Standard counter/timers (CTIMER0 to 4)
            pub const CTIMER3: *volatile types.peripherals.CTIMER0 = @ptrFromInt(0x40048000);
            /// LPC5411x Standard counter/timers (CTIMER0 to 4)
            pub const CTIMER4: *volatile types.peripherals.CTIMER0 = @ptrFromInt(0x40049000);
            /// LPC5411x SPI Flash Interface (SPIFI)
            pub const SPIFI0: *volatile types.peripherals.SPIFI0 = @ptrFromInt(0x40080000);
            /// LPC5460x External Memory Controller (EMC)
            pub const EMC: *volatile types.peripherals.EMC = @ptrFromInt(0x40081000);
            /// LPC5411x DMA controller
            pub const DMA0: *volatile types.peripherals.DMA0 = @ptrFromInt(0x40082000);
            /// LPC5460x LCD controller
            pub const LCD: *volatile types.peripherals.LCD = @ptrFromInt(0x40083000);
            /// LPC5411x USB 2.0 Device Controller
            pub const USB0: *volatile types.peripherals.USB0 = @ptrFromInt(0x40084000);
            /// SCTimer/PWM (SCT)
            pub const SCT0: *volatile types.peripherals.SCT0 = @ptrFromInt(0x40085000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM0: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x40086000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C0: *volatile types.peripherals.I2C0 = @ptrFromInt(0x40086000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI0: *volatile types.peripherals.SPI0 = @ptrFromInt(0x40086000);
            /// LPC5411x USARTs
            pub const USART0: *volatile types.peripherals.USART0 = @ptrFromInt(0x40086000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM1: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x40087000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C1: *volatile types.peripherals.I2C0 = @ptrFromInt(0x40087000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI1: *volatile types.peripherals.SPI0 = @ptrFromInt(0x40087000);
            /// LPC5411x USARTs
            pub const USART1: *volatile types.peripherals.USART0 = @ptrFromInt(0x40087000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM2: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x40088000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C2: *volatile types.peripherals.I2C0 = @ptrFromInt(0x40088000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI2: *volatile types.peripherals.SPI0 = @ptrFromInt(0x40088000);
            /// LPC5411x USARTs
            pub const USART2: *volatile types.peripherals.USART0 = @ptrFromInt(0x40088000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM3: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x40089000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C3: *volatile types.peripherals.I2C0 = @ptrFromInt(0x40089000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI3: *volatile types.peripherals.SPI0 = @ptrFromInt(0x40089000);
            /// LPC5411x USARTs
            pub const USART3: *volatile types.peripherals.USART0 = @ptrFromInt(0x40089000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM4: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x4008a000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C4: *volatile types.peripherals.I2C0 = @ptrFromInt(0x4008a000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI4: *volatile types.peripherals.SPI0 = @ptrFromInt(0x4008a000);
            /// LPC5411x USARTs
            pub const USART4: *volatile types.peripherals.USART0 = @ptrFromInt(0x4008a000);
            /// LPC5411x General Purpose I/O (GPIO)
            pub const GPIO: *volatile types.peripherals.GPIO = @ptrFromInt(0x4008c000);
            /// LPC5411x DMIC Subsystem (DMIC))
            pub const DMIC0: *volatile types.peripherals.DMIC0 = @ptrFromInt(0x40090000);
            /// LPC5460x Ethernet controller
            pub const ENET: *volatile types.peripherals.ENET = @ptrFromInt(0x40092000);
            /// LPC5460x USB1 High-speed Device Controller
            pub const USBHSD: *volatile types.peripherals.USBHSD = @ptrFromInt(0x40094000);
            /// LPC5411x CRC engine
            pub const CRC_ENGINE: *volatile types.peripherals.CRC_ENGINE = @ptrFromInt(0x40095000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM5: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x40096000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C5: *volatile types.peripherals.I2C0 = @ptrFromInt(0x40096000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI5: *volatile types.peripherals.SPI0 = @ptrFromInt(0x40096000);
            /// LPC5411x USARTs
            pub const USART5: *volatile types.peripherals.USART0 = @ptrFromInt(0x40096000);
            /// LPC5411x I2S interface
            pub const I2S0: *volatile types.peripherals.I2S0 = @ptrFromInt(0x40097000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM6: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x40097000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C6: *volatile types.peripherals.I2C0 = @ptrFromInt(0x40097000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI6: *volatile types.peripherals.SPI0 = @ptrFromInt(0x40097000);
            /// LPC5411x USARTs
            pub const USART6: *volatile types.peripherals.USART0 = @ptrFromInt(0x40097000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM7: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x40098000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C7: *volatile types.peripherals.I2C0 = @ptrFromInt(0x40098000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI7: *volatile types.peripherals.SPI0 = @ptrFromInt(0x40098000);
            /// LPC5411x USARTs
            pub const USART7: *volatile types.peripherals.USART0 = @ptrFromInt(0x40098000);
            /// LPC5411x I2S interface
            pub const I2S1: *volatile types.peripherals.I2S0 = @ptrFromInt(0x40098000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM8: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x40099000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C8: *volatile types.peripherals.I2C0 = @ptrFromInt(0x40099000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI8: *volatile types.peripherals.SPI0 = @ptrFromInt(0x40099000);
            /// LPC5411x USARTs
            pub const USART8: *volatile types.peripherals.USART0 = @ptrFromInt(0x40099000);
            /// LPC5411x Flexcomm serial communication
            pub const FLEXCOMM9: *volatile types.peripherals.FLEXCOMM0 = @ptrFromInt(0x4009a000);
            /// LPC5411x I2C-bus interfaces
            pub const I2C9: *volatile types.peripherals.I2C0 = @ptrFromInt(0x4009a000);
            /// LPC5411x Serial Peripheral Interfaces (SPI)
            pub const SPI9: *volatile types.peripherals.SPI0 = @ptrFromInt(0x4009a000);
            /// LPC5411x USARTs
            pub const USART9: *volatile types.peripherals.USART0 = @ptrFromInt(0x4009a000);
            /// SDMMC
            pub const SDIF: *volatile types.peripherals.SDIF = @ptrFromInt(0x4009b000);
            /// LPC5460x Controller Area Network Flexible Data
            pub const CAN0: *volatile types.peripherals.CAN0 = @ptrFromInt(0x4009d000);
            /// LPC5460x Controller Area Network Flexible Data
            pub const CAN1: *volatile types.peripherals.CAN0 = @ptrFromInt(0x4009e000);
            /// LPC5411x 12-bit ADC controller (ADC)
            pub const ADC0: *volatile types.peripherals.ADC0 = @ptrFromInt(0x400a0000);
            /// LPC5460x USB0 Full-speed Host controller
            pub const USBFSH: *volatile types.peripherals.USBFSH = @ptrFromInt(0x400a2000);
            /// LPC5460x USB1 High-speed Host Controller
            pub const USBHSH: *volatile types.peripherals.USBHSH = @ptrFromInt(0x400a3000);
            /// SHA
            pub const SHA0: *volatile types.peripherals.SHA0 = @ptrFromInt(0x400a4000);
            /// Instrumentation Trace Macrocell Registers
            pub const ITM: *volatile types.peripherals.ITM = @ptrFromInt(0xe0000000);
            /// System Control Block
            pub const SystemControl: *volatile types.peripherals.SystemControl = @ptrFromInt(0xe000e000);
            /// System timer
            pub const SysTick: *volatile types.peripherals.SysTick = @ptrFromInt(0xe000e010);
            /// Nested Vectored Interrupt Controller
            pub const NVIC: *volatile types.peripherals.NVIC = @ptrFromInt(0xe000e100);
            /// Embedded Trace Macrocell Registers
            pub const ETM: *volatile types.peripherals.ETM = @ptrFromInt(0xe0041000);
        };
    };
};

pub const types = struct {
    pub const peripherals = struct {
        /// LPC5411x 12-bit ADC controller (ADC)
        pub const ADC0 = extern struct {
            /// ADC Control register. Contains the clock divide value, resolution selection, sampling time selection, and mode controls.
            CTRL: mmio.Mmio(packed struct(u32) {
                /// In synchronous mode only, the system clock is divided by this value plus one to produce the clock for the ADC converter, which should be less than or equal to 72 MHz. Typically, software should program the smallest value in this field that yields this maximum clock rate or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable. This field is ignored in the asynchronous operating mode.
                CLKDIV: u8,
                /// Select clock mode.
                ASYNMODE: enum(u1) {
                    /// Synchronous mode. The ADC clock is derived from the system clock based on the divide value selected in the CLKDIV field. The ADC clock will be started in a controlled fashion in response to a trigger to eliminate any uncertainty in the launching of an ADC conversion in response to any synchronous (on-chip) trigger. In Synchronous mode with the SYNCBYPASS bit (in a sequence control register) set, sampling of the ADC input and start of conversion will initiate 2 system clocks after the leading edge of a (synchronous) trigger pulse.
                    SYNCHRONOUS_MODE = 0x0,
                    /// Asynchronous mode. The ADC clock is based on the output of the ADC clock divider ADCCLKSEL in the SYSCON block.
                    ASYNCHRONOUS_MODE = 0x1,
                },
                /// The number of bits of ADC resolution. Accuracy can be reduced to achieve higher conversion rates. A single conversion (including one conversion in a burst or sequence) requires the selected number of bits of resolution plus 3 ADC clocks. This field must only be altered when the ADC is fully idle. Changing it during any kind of ADC operation may have unpredictable results. ADC clock frequencies for various resolutions must not exceed: - 5x the system clock rate for 12-bit resolution - 4.3x the system clock rate for 10-bit resolution - 3.6x the system clock for 8-bit resolution - 3x the bus clock rate for 6-bit resolution
                RESOL: enum(u2) {
                    /// 6-bit resolution. An ADC conversion requires 9 ADC clocks, plus any clocks specified by the TSAMP field.
                    RESOLUTION_6_BIT = 0x0,
                    /// 8-bit resolution. An ADC conversion requires 11 ADC clocks, plus any clocks specified by the TSAMP field.
                    RESOLUTION_8_BIT = 0x1,
                    /// 10-bit resolution. An ADC conversion requires 13 ADC clocks, plus any clocks specified by the TSAMP field.
                    RESOLUTION_10_BIT = 0x2,
                    /// 12-bit resolution. An ADC conversion requires 15 ADC clocks, plus any clocks specified by the TSAMP field.
                    RESOLUTION_12_BIT = 0x3,
                },
                /// Bypass Calibration. This bit may be set to avoid the need to calibrate if offset error is not a concern in the application.
                BYPASSCAL: enum(u1) {
                    /// Calibrate. The stored calibration value will be applied to the ADC during conversions to compensated for offset error. A calibration cycle must be performed each time the chip is powered-up. Re-calibration may be warranted periodically - especially if operating conditions have changed.
                    CALIBRATE = 0x0,
                    /// Bypass calibration. Calibration is not utilized. Less time is required when enabling the ADC - particularly following chip power-up. Attempts to launch a calibration cycle are blocked when this bit is set.
                    BYPASS_CALIBRATION = 0x1,
                },
                /// Sample Time. The default sampling period (TSAMP = '000') at the start of each conversion is 2.5 ADC clock periods. Depending on a variety of factors, including operating conditions and the output impedance of the analog source, longer sampling times may be required. See Section 28.7.10. The TSAMP field specifies the number of additional ADC clock cycles, from zero to seven, by which the sample period will be extended. The total conversion time will increase by the same number of clocks. 000 - The sample period will be the default 2.5 ADC clocks. A complete conversion with 12-bits of accuracy will require 15 clocks. 001- The sample period will be extended by one ADC clock to a total of 3.5 clock periods. A complete 12-bit conversion will require 16 clocks. 010 - The sample period will be extended by two clocks to 4.5 ADC clock cycles. A complete 12-bit conversion will require 17 ADC clocks. 111 - The sample period will be extended by seven clocks to 9.5 ADC clock cycles. A complete 12-bit conversion will require 22 ADC clocks.
                TSAMP: u3,
                padding: u17,
            }),
            /// Input Select. Allows selection of the temperature sensor as an alternate input to ADC channel 0.
            INSEL: mmio.Mmio(packed struct(u32) {
                /// Selects the input source for channel 0. All other values are reserved.
                SEL: enum(u2) {
                    /// ADC0_IN0 function.
                    ADC0_IN0 = 0x0,
                    /// Internal temperature sensor.
                    TEMPERATURE_SENSOR = 0x3,
                    _,
                },
                padding: u30,
            }),
            reserved32: [24]u8,
            /// ADC Channel 0 Data register. This register contains the result of the most recent conversion completed on channel 0.
            DAT: [12]mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// This field contains the 12-bit ADC conversion result from the last conversion performed on this channel. This will be a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to VREFN. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VREFN, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
                RESULT: u12,
                /// Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.
                THCMPRANGE: u2,
                /// Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.
                THCMPCROSS: u2,
                reserved26: u6,
                /// This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)
                CHANNEL: u4,
                /// This bit will be set to a 1 if a new conversion on this channel completes and overwrites the previous contents of the RESULT field before it has been read - i.e. while the DONE bit is set. This bit is cleared, along with the DONE bit, whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. This bit (in any of the 12 registers) will cause an overrun interrupt/DMA trigger to be asserted if the overrun interrupt is enabled. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.
                OVERRUN: u1,
                /// This bit is set to 1 when an ADC conversion on this channel completes. This bit is cleared whenever this register is read or when the data related to this channel is read from either of the global SEQn_GDAT registers. While it is allowed to include the same channels in both conversion sequences, doing so may cause erratic behavior of the DONE and OVERRUN bits in the data registers associated with any of the channels that are shared between the two sequences. Any erratic OVERRUN behavior will also affect overrun interrupt generation, if enabled.
                DATAVALID: u1,
            }),
            /// ADC Low Compare Threshold register 0: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0.
            THR0_LOW: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// Low threshold value against which ADC results will be compared
                THRLOW: u12,
                padding: u16,
            }),
            /// ADC Low Compare Threshold register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1.
            THR1_LOW: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// Low threshold value against which ADC results will be compared
                THRLOW: u12,
                padding: u16,
            }),
            /// ADC High Compare Threshold register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0.
            THR0_HIGH: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// High threshold value against which ADC results will be compared
                THRHIGH: u12,
                padding: u16,
            }),
            /// ADC High Compare Threshold register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1.
            THR1_HIGH: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// High threshold value against which ADC results will be compared
                THRHIGH: u12,
                padding: u16,
            }),
            /// ADC Channel-Threshold Select register. Specifies which set of threshold compare registers are to be used for each channel
            CHAN_THRSEL: mmio.Mmio(packed struct(u32) {
                /// Threshold select for channel 0.
                CH0_THRSEL: enum(u1) {
                    /// Threshold 0. Results for this channel will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers.
                    THRESHOLD0 = 0x0,
                    /// Threshold 1. Results for this channel will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers.
                    THRESHOLD1 = 0x1,
                },
                /// Threshold select for channel 1. See description for channel 0.
                CH1_THRSEL: u1,
                /// Threshold select for channel 2. See description for channel 0.
                CH2_THRSEL: u1,
                /// Threshold select for channel 3. See description for channel 0.
                CH3_THRSEL: u1,
                /// Threshold select for channel 4. See description for channel 0.
                CH4_THRSEL: u1,
                /// Threshold select for channel 5. See description for channel 0.
                CH5_THRSEL: u1,
                /// Threshold select for channel 6. See description for channel 0.
                CH6_THRSEL: u1,
                /// Threshold select for channel 7. See description for channel 0.
                CH7_THRSEL: u1,
                /// Threshold select for channel 8. See description for channel 0.
                CH8_THRSEL: u1,
                /// Threshold select for channel 9. See description for channel 0.
                CH9_THRSEL: u1,
                /// Threshold select for channel 10. See description for channel 0.
                CH10_THRSEL: u1,
                /// Threshold select for channel 11. See description for channel 0.
                CH11_THRSEL: u1,
                padding: u20,
            }),
            /// ADC Interrupt Enable register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated.
            INTEN: mmio.Mmio(packed struct(u32) {
                /// Sequence A interrupt enable.
                SEQA_INTEN: enum(u1) {
                    /// Disabled. The sequence A interrupt/DMA trigger is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The sequence A interrupt/DMA trigger is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence A, or upon completion of the entire A sequence of conversions, depending on the MODE bit in the SEQA_CTRL register.
                    ENABLED = 0x1,
                },
                /// Sequence B interrupt enable.
                SEQB_INTEN: enum(u1) {
                    /// Disabled. The sequence B interrupt/DMA trigger is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The sequence B interrupt/DMA trigger is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence B, or upon completion of the entire B sequence of conversions, depending on the MODE bit in the SEQB_CTRL register.
                    ENABLED = 0x1,
                },
                /// Overrun interrupt enable.
                OVR_INTEN: enum(u1) {
                    /// Disabled. The overrun interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The overrun interrupt is enabled. Detection of an overrun condition on any of the 12 channel data registers will cause an overrun interrupt/DMA trigger. In addition, if the MODE bit for a particular sequence is 0, then an overrun in the global data register for that sequence will also cause this interrupt/DMA trigger to be asserted.
                    ENABLED = 0x1,
                },
                /// Threshold comparison interrupt enable for channel 0.
                ADCMPINTEN0: enum(u2) {
                    /// Disabled.
                    DISABLED = 0x0,
                    /// Outside threshold.
                    OUTSIDE_THRESHOLD = 0x1,
                    /// Crossing threshold.
                    CROSSING_THRESHOLD = 0x2,
                    _,
                },
                /// Channel 1 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN1: u2,
                /// Channel 2 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN2: u2,
                /// Channel 3 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN3: u2,
                /// Channel 4 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN4: u2,
                /// Channel 5 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN5: u2,
                /// Channel 6 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN6: u2,
                /// Channel 7 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN7: u2,
                /// Channel 8 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN8: u2,
                /// Channel 9 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN9: u2,
                /// Channel 10 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN10: u2,
                /// Channel 21 threshold comparison interrupt enable. See description for channel 0.
                ADCMPINTEN11: u2,
                padding: u5,
            }),
            /// ADC Flags register. Contains the four interrupt/DMA trigger flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers).
            FLAGS: mmio.Mmio(packed struct(u32) {
                /// Threshold comparison event on Channel 0. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.
                THCMP0: u1,
                /// Threshold comparison event on Channel 1. See description for channel 0.
                THCMP1: u1,
                /// Threshold comparison event on Channel 2. See description for channel 0.
                THCMP2: u1,
                /// Threshold comparison event on Channel 3. See description for channel 0.
                THCMP3: u1,
                /// Threshold comparison event on Channel 4. See description for channel 0.
                THCMP4: u1,
                /// Threshold comparison event on Channel 5. See description for channel 0.
                THCMP5: u1,
                /// Threshold comparison event on Channel 6. See description for channel 0.
                THCMP6: u1,
                /// Threshold comparison event on Channel 7. See description for channel 0.
                THCMP7: u1,
                /// Threshold comparison event on Channel 8. See description for channel 0.
                THCMP8: u1,
                /// Threshold comparison event on Channel 9. See description for channel 0.
                THCMP9: u1,
                /// Threshold comparison event on Channel 10. See description for channel 0.
                THCMP10: u1,
                /// Threshold comparison event on Channel 11. See description for channel 0.
                THCMP11: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 0
                OVERRUN0: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 1
                OVERRUN1: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 2
                OVERRUN2: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 3
                OVERRUN3: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 4
                OVERRUN4: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 5
                OVERRUN5: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 6
                OVERRUN6: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 7
                OVERRUN7: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 8
                OVERRUN8: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 9
                OVERRUN9: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 10
                OVERRUN10: u1,
                /// Mirrors the OVERRRUN status flag from the result register for ADC channel 11
                OVERRUN11: u1,
                /// Mirrors the global OVERRUN status flag in the SEQA_GDAT register
                SEQA_OVR: u1,
                /// Mirrors the global OVERRUN status flag in the SEQB_GDAT register
                SEQB_OVR: u1,
                reserved28: u2,
                /// Sequence A interrupt/DMA trigger. If the MODE bit in the SEQA_CTRL register is 0, this flag will mirror the DATAVALID bit in the sequence A global data register (SEQA_GDAT), which is set at the end of every ADC conversion performed as part of sequence A. It will be cleared automatically when the SEQA_GDAT register is read. If the MODE bit in the SEQA_CTRL register is 1, this flag will be set upon completion of an entire A sequence. In this case it must be cleared by writing a 1 to this SEQA_INT bit. This interrupt must be enabled in the INTEN register.
                SEQA_INT: u1,
                /// Sequence A interrupt/DMA trigger. If the MODE bit in the SEQB_CTRL register is 0, this flag will mirror the DATAVALID bit in the sequence A global data register (SEQB_GDAT), which is set at the end of every ADC conversion performed as part of sequence B. It will be cleared automatically when the SEQB_GDAT register is read. If the MODE bit in the SEQB_CTRL register is 1, this flag will be set upon completion of an entire B sequence. In this case it must be cleared by writing a 1 to this SEQB_INT bit. This interrupt must be enabled in the INTEN register.
                SEQB_INT: u1,
                /// Threshold Comparison Interrupt. This bit will be set if any of the THCMP flags in the lower bits of this register are set to 1 (due to an enabled out-of-range or threshold-crossing event on any channel). Each type of threshold comparison interrupt on each channel must be individually enabled in the INTEN register to cause this interrupt. This bit will be cleared when all of the individual threshold flags are cleared via writing 1s to those bits.
                THCMP_INT: u1,
                /// Overrun Interrupt flag. Any overrun bit in any of the individual channel data registers will cause this interrupt. In addition, if the MODE bit in either of the SEQn_CTRL registers is 0 then the OVERRUN bit in the corresponding SEQn_GDAT register will also cause this interrupt. This interrupt must be enabled in the INTEN register. This bit will be cleared when all of the individual overrun bits have been cleared via reading the corresponding data registers.
                OVR_INT: u1,
            }),
            /// ADC Startup register.
            STARTUP: mmio.Mmio(packed struct(u32) {
                /// ADC Enable bit. This bit can only be set to a 1 by software. It is cleared automatically whenever the ADC is powered down. This bit must not be set until at least 10 microseconds after the ADC is powered up (typically by altering a system-level ADC power control bit).
                ADC_ENA: u1,
                /// ADC Initialization. After enabling the ADC (setting the ADC_ENA bit), the API routine will EITHER set this bit or the CALIB bit in the CALIB register, depending on whether or not calibration is required. Setting this bit will launch the 'dummy' conversion cycle that is required if a calibration is not performed. It will also reload the stored calibration value from a previous calibration unless the BYPASSCAL bit is set. This bit should only be set AFTER the ADC_ENA bit is set and after the CALIREQD bit is tested to determine whether a calibration or an ADC dummy conversion cycle is required. It should not be set during the same write that sets the ADC_ENA bit. This bit can only be set to a '1' by software. It is cleared automatically when the 'dummy' conversion cycle completes.
                ADC_INIT: u1,
                padding: u30,
            }),
            /// ADC Calibration register.
            CALIB: mmio.Mmio(packed struct(u32) {
                /// Calibration request. Setting this bit will launch an ADC calibration cycle. This bit can only be set to a '1' by software. It is cleared automatically when the calibration cycle completes.
                CALIB: u1,
                /// Calibration required. This read-only bit indicates if calibration is required when enabling the ADC. CALREQD will be '1' if no calibration has been run since the chip was powered-up and if the BYPASSCAL bit in the CTRL register is low. Software will test this bit to determine whether to initiate a calibration cycle or whether to set the ADC_INIT bit (in the STARTUP register) to launch the ADC initialization process which includes a 'dummy' conversion cycle. Note: A 'dummy' conversion cycle requires approximately 6 ADC clocks as opposed to 81 clocks required for calibration.
                CALREQD: u1,
                /// Calibration Value. This read-only field displays the calibration value established during last calibration cycle. This value is not typically of any use to the user.
                CALVALUE: u7,
                padding: u23,
            }),
        };

        /// LPC5411x Asynchronous system configuration (ASYNC_SYSCON)
        pub const ASYNC_SYSCON = extern struct {
            /// Async peripheral reset control
            ASYNCPRESETCTRL: mmio.Mmio(packed struct(u32) {
                reserved13: u13,
                /// Standard counter/timer CTIMER3 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                CTIMER3: u1,
                /// Standard counter/timer CTIMER4 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                CTIMER4: u1,
                padding: u17,
            }),
            /// Set bits in ASYNCPRESETCTRL
            ASYNCPRESETCTRLSET: mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register sets the corresponding bit or bits in the ASYNCPRESETCTRL register, if they are implemented. Bits that do not correspond to defined bits in ASYNCPRESETCTRL are reserved and only zeroes should be written to them.
                ARST_SET: u32,
            }),
            /// Clear bits in ASYNCPRESETCTRL
            ASYNCPRESETCTRLCLR: mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register clears the corresponding bit or bits in the ASYNCPRESETCTRL register, if they are implemented. Bits that do not correspond to defined bits in ASYNCPRESETCTRL are reserved and only zeroes should be written to them.
                ARST_CLR: u32,
            }),
            reserved16: [4]u8,
            /// Async peripheral clock control
            ASYNCAPBCLKCTRL: mmio.Mmio(packed struct(u32) {
                reserved13: u13,
                /// Controls the clock for CTIMER3. 0 = Disable; 1 = Enable.
                CTIMER3: u1,
                /// Controls the clock for CTIMER4. 0 = Disable; 1 = Enable.
                CTIMER4: u1,
                padding: u17,
            }),
            /// Set bits in ASYNCAPBCLKCTRL
            ASYNCAPBCLKCTRLSET: mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register sets the corresponding bit or bits in the ASYNCAPBCLKCTRL register, if they are implemented. Bits that do not correspond to defined bits in ASYNCPRESETCTRL are reserved and only zeroes should be written to them.
                ACLK_SET: u32,
            }),
            /// Clear bits in ASYNCAPBCLKCTRL
            ASYNCAPBCLKCTRLCLR: mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register clears the corresponding bit or bits in the ASYNCAPBCLKCTRL register, if they are implemented. Bits that do not correspond to defined bits in ASYNCAPBCLKCTRL are reserved and only zeroes should be written to them.
                ACLK_CLR: u32,
            }),
            reserved32: [4]u8,
            /// Async APB clock source select A
            ASYNCAPBCLKSELA: mmio.Mmio(packed struct(u32) {
                /// Clock source for asynchronous clock source selector A
                SEL: enum(u2) {
                    /// Main clock (main_clk)
                    MAIN_CLOCK = 0x0,
                    /// FRO 12 MHz (fro_12m)
                    FRO_12_MHZ = 0x1,
                    /// Audio PLL clock.(AUDPLL_BYPASS)
                    AUDIO_PLL_CLOCK = 0x2,
                    /// fc6 fclk (fc6_fclk)
                    FC6_FCLK = 0x3,
                },
                padding: u30,
            }),
        };

        /// LPC5460x Controller Area Network Flexible Data
        pub const CAN0 = extern struct {
            reserved12: [12]u8,
            /// Data Bit Timing Prescaler Register
            DBTP: mmio.Mmio(packed struct(u32) {
                /// Data (re)synchronization jump width.
                DSJW: u4,
                /// Data time segment after sample point.
                DTSEG2: u4,
                /// Data time segment before sample point.
                DTSEG1: u5,
                reserved16: u3,
                /// Data bit rate prescaler.
                DBRP: u5,
                reserved23: u2,
                /// Transmitter delay compensation.
                TDC: u1,
                padding: u8,
            }),
            /// Test Register
            TEST: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// Loop back mode.
                LBCK: u1,
                /// Control of transmit pin.
                TX: u2,
                /// Monitors the actual value of the CAN_RXD.
                RX: u1,
                padding: u24,
            }),
            reserved24: [4]u8,
            /// CC Control Register
            CCCR: mmio.Mmio(packed struct(u32) {
                /// Initialization.
                INIT: u1,
                /// Configuration change enable.
                CCE: u1,
                /// Restricted operational mode.
                ASM: u1,
                /// Clock Stop Acknowledge.
                CSA: u1,
                /// Clock Stop Request.
                CSR: u1,
                /// Bus monitoring mode.
                MON: u1,
                /// Disable automatic retransmission.
                DAR: u1,
                /// Test mode enable.
                TEST: u1,
                /// CAN FD operation enable.
                FDOE: u1,
                /// When CAN FD operation is disabled, this bit is not evaluated.
                BRSE: u1,
                reserved12: u2,
                /// Protocol exception handling disable.
                PXHD: u1,
                /// Edge filtering during bus integration.
                EFBI: u1,
                /// Transmit pause.
                TXP: u1,
                /// Non ISO operation.
                NISO: u1,
                padding: u16,
            }),
            /// Nominal Bit Timing and Prescaler Register
            NBTP: mmio.Mmio(packed struct(u32) {
                /// Nominal time segment after sample point.
                NTSEG2: u7,
                reserved8: u1,
                /// Nominal time segment before sample point.
                NTSEG1: u8,
                /// Nominal bit rate prescaler.
                NBRP: u9,
                /// Nominal (re)synchronization jump width.
                NSJW: u7,
            }),
            /// Timestamp Counter Configuration
            TSCC: mmio.Mmio(packed struct(u32) {
                /// Timestamp select.
                TSS: u2,
                reserved16: u14,
                /// Timestamp counter prescaler Configures the timestamp and timeout counters time unit in multiple of CAN bit times.
                TCP: u4,
                padding: u12,
            }),
            /// Timestamp Counter Value
            TSCV: mmio.Mmio(packed struct(u32) {
                /// Timestamp counter.
                TSC: u16,
                padding: u16,
            }),
            /// Timeout Counter Configuration
            TOCC: mmio.Mmio(packed struct(u32) {
                /// Enable timeout counter.
                ETOC: u1,
                /// Timeout select.
                TOS: u2,
                reserved16: u13,
                /// Timeout period.
                TOP: u16,
            }),
            /// Timeout Counter Value
            TOCV: mmio.Mmio(packed struct(u32) {
                /// Timeout counter.
                TOC: u16,
                padding: u16,
            }),
            reserved64: [16]u8,
            /// Error Counter Register
            ECR: mmio.Mmio(packed struct(u32) {
                /// Transmit error counter.
                TEC: u8,
                /// Receive error counter.
                REC: u7,
                /// Receive error passive.
                RP: u1,
                /// CAN error logging.
                CEL: u8,
                padding: u8,
            }),
            /// Protocol Status Register
            PSR: mmio.Mmio(packed struct(u32) {
                /// Last error code.
                LEC: u3,
                /// Activity.
                ACT: u2,
                /// Error Passive.
                EP: u1,
                /// Warning status.
                EW: u1,
                /// Bus Off Status.
                BO: u1,
                /// Data phase last error code.
                DLEC: u3,
                /// ESI flag of the last received CAN FD message.
                RESI: u1,
                /// BRS flag of last received CAN FD message.
                RBRS: u1,
                /// Received a CAN FD message.
                RFDF: u1,
                /// Protocol exception event.
                PXE: u1,
                reserved16: u1,
                /// Transmitter delay compensation value.
                TDCV: u7,
                padding: u9,
            }),
            /// Transmitter Delay Compensator Register
            TDCR: mmio.Mmio(packed struct(u32) {
                /// Transmitter delay compensation filter window length.
                TDCF: u7,
                reserved8: u1,
                /// Transmitter delay compensation offset.
                TDCO: u7,
                padding: u17,
            }),
            reserved80: [4]u8,
            /// Interrupt Register
            IR: mmio.Mmio(packed struct(u32) {
                /// Rx FIFO 0 new message.
                RF0N: u1,
                /// Rx FIFO 0 watermark reached.
                RF0W: u1,
                /// Rx FIFO 0 full.
                RF0F: u1,
                /// Rx FIFO 0 message lost.
                RF0L: u1,
                /// Rx FIFO 1 new message.
                RF1N: u1,
                /// Rx FIFO 1 watermark reached.
                RF1W: u1,
                /// Rx FIFO 1 full.
                RF1F: u1,
                /// Rx FIFO 1 message lost.
                RF1L: u1,
                /// High priority message.
                HPM: u1,
                /// Transmission completed.
                TC: u1,
                /// Transmission cancellation finished.
                TCF: u1,
                /// Tx FIFO empty.
                TFE: u1,
                /// Tx event FIFO new entry.
                TEFN: u1,
                /// Tx event FIFO watermark reached.
                TEFW: u1,
                /// Tx event FIFO full.
                TEFF: u1,
                /// Tx event FIFO element lost.
                TEFL: u1,
                /// Timestamp wraparound.
                TSW: u1,
                /// Message RAM access failure.
                MRAF: u1,
                /// Timeout occurred.
                TOO: u1,
                /// Message stored in dedicated Rx buffer.
                DRX: u1,
                /// Bit error corrected.
                BEC: u1,
                /// Bit error uncorrected.
                BEU: u1,
                /// Error logging overflow.
                ELO: u1,
                /// Error passive.
                EP: u1,
                /// Warning status.
                EW: u1,
                /// Bus_Off Status.
                BO: u1,
                /// Watchdog interrupt.
                WDI: u1,
                /// Protocol error in arbitration phase.
                PEA: u1,
                /// Protocol error in data phase.
                PED: u1,
                /// Access to reserved address.
                ARA: u1,
                padding: u2,
            }),
            /// Interrupt Enable
            IE: mmio.Mmio(packed struct(u32) {
                /// Rx FIFO 0 new message interrupt enable.
                RF0NE: u1,
                /// Rx FIFO 0 watermark reached interrupt enable.
                RF0WE: u1,
                /// Rx FIFO 0 full interrupt enable.
                RF0FE: u1,
                /// Rx FIFO 0 message lost interrupt enable.
                RF0LE: u1,
                /// Rx FIFO 1 new message interrupt enable.
                RF1NE: u1,
                /// Rx FIFO 1 watermark reached interrupt enable.
                RF1WE: u1,
                /// Rx FIFO 1 full interrupt enable.
                RF1FE: u1,
                /// Rx FIFO 1 message lost interrupt enable.
                RF1LE: u1,
                /// High priority message interrupt enable.
                HPME: u1,
                /// Transmission completed interrupt enable.
                TCE: u1,
                /// Transmission cancellation finished interrupt enable.
                TCFE: u1,
                /// Tx FIFO empty interrupt enable.
                TFEE: u1,
                /// Tx event FIFO new entry interrupt enable.
                TEFNE: u1,
                /// Tx event FIFO watermark reached interrupt enable.
                TEFWE: u1,
                /// Tx event FIFO full interrupt enable.
                TEFFE: u1,
                /// Tx event FIFO element lost interrupt enable.
                TEFLE: u1,
                /// Timestamp wraparound interrupt enable.
                TSWE: u1,
                /// Message RAM access failure interrupt enable.
                MRAFE: u1,
                /// Timeout occurred interrupt enable.
                TOOE: u1,
                /// Message stored in dedicated Rx buffer interrupt enable.
                DRXE: u1,
                /// Bit error corrected interrupt enable.
                BECE: u1,
                /// Bit error uncorrected interrupt enable.
                BEUE: u1,
                /// Error logging overflow interrupt enable.
                ELOE: u1,
                /// Error passive interrupt enable.
                EPE: u1,
                /// Warning status interrupt enable.
                EWE: u1,
                /// Bus_Off Status interrupt enable.
                BOE: u1,
                /// Watchdog interrupt enable.
                WDIE: u1,
                /// Protocol error in arbitration phase interrupt enable.
                PEAE: u1,
                /// Protocol error in data phase interrupt enable.
                PEDE: u1,
                /// Access to reserved address interrupt enable.
                ARAE: u1,
                padding: u2,
            }),
            /// Interrupt Line Select
            ILS: mmio.Mmio(packed struct(u32) {
                /// Rx FIFO 0 new message interrupt line.
                RF0NL: u1,
                /// Rx FIFO 0 watermark reached interrupt line.
                RF0WL: u1,
                /// Rx FIFO 0 full interrupt line.
                RF0FL: u1,
                /// Rx FIFO 0 message lost interrupt line.
                RF0LL: u1,
                /// Rx FIFO 1 new message interrupt line.
                RF1NL: u1,
                /// Rx FIFO 1 watermark reached interrupt line.
                RF1WL: u1,
                /// Rx FIFO 1 full interrupt line.
                RF1FL: u1,
                /// Rx FIFO 1 message lost interrupt line.
                RF1LL: u1,
                /// High priority message interrupt line.
                HPML: u1,
                /// Transmission completed interrupt line.
                TCL: u1,
                /// Transmission cancellation finished interrupt line.
                TCFL: u1,
                /// Tx FIFO empty interrupt line.
                TFEL: u1,
                /// Tx event FIFO new entry interrupt line.
                TEFNL: u1,
                /// Tx event FIFO watermark reached interrupt line.
                TEFWL: u1,
                /// Tx event FIFO full interrupt line.
                TEFFL: u1,
                /// Tx event FIFO element lost interrupt line.
                TEFLL: u1,
                /// Timestamp wraparound interrupt line.
                TSWL: u1,
                /// Message RAM access failure interrupt line.
                MRAFL: u1,
                /// Timeout occurred interrupt line.
                TOOL: u1,
                /// Message stored in dedicated Rx buffer interrupt line.
                DRXL: u1,
                /// Bit error corrected interrupt line.
                BECL: u1,
                /// Bit error uncorrected interrupt line.
                BEUL: u1,
                /// Error logging overflow interrupt line.
                ELOL: u1,
                /// Error passive interrupt line.
                EPL: u1,
                /// Warning status interrupt line.
                EWL: u1,
                /// Bus_Off Status interrupt line.
                BOL: u1,
                /// Watchdog interrupt line.
                WDIL: u1,
                /// Protocol error in arbitration phase interrupt line.
                PEAL: u1,
                /// Protocol error in data phase interrupt line.
                PEDL: u1,
                /// Access to reserved address interrupt line.
                ARAL: u1,
                padding: u2,
            }),
            /// Interrupt Line Enable
            ILE: mmio.Mmio(packed struct(u32) {
                /// Enable interrupt line 0.
                EINT0: u1,
                /// Enable interrupt line 1.
                EINT1: u1,
                padding: u30,
            }),
            reserved128: [32]u8,
            /// Global Filter Configuration
            GFC: mmio.Mmio(packed struct(u32) {
                /// Reject remote frames extended.
                RRFE: u1,
                /// Reject remote frames standard.
                RRFS: u1,
                /// Accept non-matching frames extended.
                ANFE: u2,
                /// Accept non-matching frames standard.
                ANFS: u2,
                padding: u26,
            }),
            /// Standard ID Filter Configuration
            SIDFC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Filter list standard start address.
                FLSSA: u14,
                /// List size standard 0 = No standard message ID filter.
                LSS: u8,
                padding: u8,
            }),
            /// Extended ID Filter Configuration
            XIDFC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Filter list extended start address.
                FLESA: u14,
                /// List size extended 0 = No extended message ID filter.
                LSE: u8,
                padding: u8,
            }),
            reserved144: [4]u8,
            /// Extended ID AND Mask
            XIDAM: mmio.Mmio(packed struct(u32) {
                /// Extended ID mask.
                EIDM: u29,
                padding: u3,
            }),
            /// High Priority Message Status
            HPMS: mmio.Mmio(packed struct(u32) {
                /// Buffer index.
                BIDX: u6,
                /// Message storage indicator.
                MSI: u2,
                /// Filter index.
                FIDX: u7,
                /// Filter list.
                FLST: u1,
                padding: u16,
            }),
            /// New Data 1
            NDAT1: mmio.Mmio(packed struct(u32) {
                /// New Data.
                ND: u32,
            }),
            /// New Data 2
            NDAT2: mmio.Mmio(packed struct(u32) {
                /// New Data.
                ND: u32,
            }),
            /// Rx FIFO 0 Configuration
            RXF0C: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Rx FIFO 0 start address.
                F0SA: u14,
                /// Rx FIFO 0 size.
                F0S: u7,
                reserved24: u1,
                /// Rx FIFO 0 watermark 0 = Watermark interrupt disabled.
                F0WM: u7,
                /// FIFO 0 operation mode.
                F0OM: u1,
            }),
            /// Rx FIFO 0 Status
            RXF0S: mmio.Mmio(packed struct(u32) {
                /// Rx FIFO 0 fill level.
                F0FL: u7,
                reserved8: u1,
                /// Rx FIFO 0 get index.
                F0GI: u6,
                reserved16: u2,
                /// Rx FIFO 0 put index.
                F0PI: u6,
                reserved24: u2,
                /// Rx FIFO 0 full.
                F0F: u1,
                /// Rx FIFO 0 message lost.
                RF0L: u1,
                padding: u6,
            }),
            /// Rx FIFO 0 Acknowledge
            RXF0A: mmio.Mmio(packed struct(u32) {
                /// Rx FIFO 0 acknowledge index.
                F0AI: u6,
                padding: u26,
            }),
            /// Rx Buffer Configuration
            RXBC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Rx buffer start address.
                RBSA: u14,
                padding: u16,
            }),
            /// Rx FIFO 1 Configuration
            RXF1C: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Rx FIFO 1 start address.
                F1SA: u14,
                /// Rx FIFO 1 size 0 = No Rx FIFO 1.
                F1S: u7,
                reserved24: u1,
                /// Rx FIFO 1 watermark 0 = Watermark interrupt disabled.
                F1WM: u7,
                /// FIFO 1 operation mode.
                F1OM: u1,
            }),
            /// Rx FIFO 1 Status
            RXF1S: mmio.Mmio(packed struct(u32) {
                /// Rx FIFO 1 fill level.
                F1FL: u7,
                reserved8: u1,
                /// Rx FIFO 1 get index.
                F1GI: u6,
                reserved16: u2,
                /// Rx FIFO 1 put index.
                F1PI: u6,
                reserved24: u2,
                /// Rx FIFO 1 full.
                F1F: u1,
                /// Rx FIFO 1 message lost.
                RF1L: u1,
                padding: u6,
            }),
            /// Rx FIFO 1 Acknowledge
            RXF1A: mmio.Mmio(packed struct(u32) {
                /// Rx FIFO 1 acknowledge index.
                F1AI: u6,
                padding: u26,
            }),
            /// Rx Buffer and FIFO Element Size Configuration
            RXESC: mmio.Mmio(packed struct(u32) {
                /// Rx FIFO 0 data field size.
                F0DS: u3,
                reserved4: u1,
                /// Rx FIFO 1 data field size.
                F1DS: u3,
                reserved8: u1,
                /// .
                RBDS: u3,
                padding: u21,
            }),
            /// Tx Buffer Configuration
            TXBC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Tx buffers start address.
                TBSA: u14,
                /// Number of dedicated transmit buffers 0 = No dedicated Tx buffers.
                NDTB: u6,
                reserved24: u2,
                /// Transmit FIFO/queue size 0 = No tx FIFO/Queue.
                TFQS: u6,
                /// Tx FIFO/queue mode.
                TFQM: u1,
                padding: u1,
            }),
            /// Tx FIFO/Queue Status
            TXFQS: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                /// Tx FIFO get index.
                TFGI: u5,
                reserved16: u3,
                /// Tx FIFO/queue put index.
                TFQPI: u5,
                /// Tx FIFO/queue full.
                TFQF: u1,
                padding: u10,
            }),
            /// Tx Buffer Element Size Configuration
            TXESC: mmio.Mmio(packed struct(u32) {
                /// Tx buffer data field size.
                TBDS: u3,
                padding: u29,
            }),
            /// Tx Buffer Request Pending
            TXBRP: mmio.Mmio(packed struct(u32) {
                /// Transmission request pending.
                TRP: u32,
            }),
            /// Tx Buffer Add Request
            TXBAR: mmio.Mmio(packed struct(u32) {
                /// Add request.
                AR: u32,
            }),
            /// Tx Buffer Cancellation Request
            TXBCR: mmio.Mmio(packed struct(u32) {
                /// Cancellation request.
                CR: u32,
            }),
            /// Tx Buffer Transmission Occurred
            TXBTO: mmio.Mmio(packed struct(u32) {
                /// Transmission occurred.
                TO: u32,
            }),
            /// Tx Buffer Cancellation Finished
            TXBCF: mmio.Mmio(packed struct(u32) {
                /// Cancellation finished.
                TO: u32,
            }),
            /// Tx Buffer Transmission Interrupt Enable
            TXBTIE: mmio.Mmio(packed struct(u32) {
                /// Transmission interrupt enable.
                TIE: u32,
            }),
            /// Tx Buffer Cancellation Finished Interrupt Enable
            TXBCIE: mmio.Mmio(packed struct(u32) {
                /// Cancellation finished interrupt enable.
                CFIE: u32,
            }),
            reserved240: [8]u8,
            /// Tx Event FIFO Configuration
            TXEFC: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Event FIFO start address.
                EFSA: u14,
                /// Event FIFO size 0 = Tx event FIFO disabled.
                EFS: u6,
                reserved24: u2,
                /// Event FIFO watermark 0 = Watermark interrupt disabled.
                EFWM: u6,
                padding: u2,
            }),
            /// Tx Event FIFO Status
            TXEFS: mmio.Mmio(packed struct(u32) {
                /// Event FIFO fill level.
                EFFL: u6,
                reserved8: u2,
                /// Event FIFO get index.
                EFGI: u5,
                reserved16: u3,
                /// Event FIFO put index.
                EFPI: u6,
                reserved24: u2,
                /// Event FIFO full.
                EFF: u1,
                /// Tx event FIFO element lost.
                TEFL: u1,
                padding: u6,
            }),
            /// Tx Event FIFO Acknowledge
            TXEFA: mmio.Mmio(packed struct(u32) {
                /// Event FIFO acknowledge index.
                EFAI: u5,
                padding: u27,
            }),
            reserved512: [260]u8,
            /// CAN Message RAM Base Address
            MRBA: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                /// Base address for the message RAM in the chip memory map.
                BA: u16,
            }),
            reserved1024: [508]u8,
            /// External Timestamp Counter Configuration
            ETSCC: mmio.Mmio(packed struct(u32) {
                /// External timestamp prescaler value.
                ETCP: u11,
                reserved31: u20,
                /// External timestamp counter enable.
                ETCE: u1,
            }),
            reserved1536: [508]u8,
            /// External Timestamp Counter Value
            ETSCV: mmio.Mmio(packed struct(u32) {
                /// External timestamp counter.
                ETSC: u16,
                padding: u16,
            }),
        };

        /// LPC5411x CRC engine
        pub const CRC_ENGINE = extern struct {
            /// CRC mode register
            MODE: mmio.Mmio(packed struct(u32) {
                /// CRC polynomial: 1X = CRC-32 polynomial 01 = CRC-16 polynomial 00 = CRC-CCITT polynomial
                CRC_POLY: u2,
                /// Data bit order: 1 = Bit order reverse for CRC_WR_DATA (per byte) 0 = No bit order reverse for CRC_WR_DATA (per byte)
                BIT_RVS_WR: u1,
                /// Data complement: 1 = 1's complement for CRC_WR_DATA 0 = No 1's complement for CRC_WR_DATA
                CMPL_WR: u1,
                /// CRC sum bit order: 1 = Bit order reverse for CRC_SUM 0 = No bit order reverse for CRC_SUM
                BIT_RVS_SUM: u1,
                /// CRC sum complement: 1 = 1's complement for CRC_SUM 0 = No 1's complement for CRC_SUM
                CMPL_SUM: u1,
                padding: u26,
            }),
            /// CRC seed register
            SEED: mmio.Mmio(packed struct(u32) {
                /// A write access to this register will load CRC seed value to CRC_SUM register with selected bit order and 1's complement pre-processes. A write access to this register will overrule the CRC calculation in progresses.
                CRC_SEED: u32,
            }),
            /// CRC checksum register
            SUM: mmio.Mmio(packed struct(u32) {
                /// The most recent CRC sum can be read through this register with selected bit order and 1's complement post-processes.
                CRC_SUM: u32,
            }),
        };

        /// LPC5411x Standard counter/timers (CTIMER0 to 4)
        pub const CTIMER0 = extern struct {
            /// Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
            IR: mmio.Mmio(packed struct(u32) {
                /// Interrupt flag for match channel 0.
                MR0INT: u1,
                /// Interrupt flag for match channel 1.
                MR1INT: u1,
                /// Interrupt flag for match channel 2.
                MR2INT: u1,
                /// Interrupt flag for match channel 3.
                MR3INT: u1,
                /// Interrupt flag for capture channel 0 event.
                CR0INT: u1,
                /// Interrupt flag for capture channel 1 event.
                CR1INT: u1,
                /// Interrupt flag for capture channel 2 event.
                CR2INT: u1,
                /// Interrupt flag for capture channel 3 event.
                CR3INT: u1,
                padding: u24,
            }),
            /// Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
            TCR: mmio.Mmio(packed struct(u32) {
                /// Counter enable.
                CEN: enum(u1) {
                    /// Disabled.The counters are disabled.
                    DISABLED = 0x0,
                    /// Enabled. The Timer Counter and Prescale Counter are enabled.
                    ENABLED = 0x1,
                },
                /// Counter reset.
                CRST: enum(u1) {
                    /// Disabled. Do nothing.
                    DISABLED = 0x0,
                    /// Enabled. The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of the APB bus clock. The counters remain reset until TCR[1] is returned to zero.
                    ENABLED = 0x1,
                },
                padding: u30,
            }),
            /// Timer Counter
            TC: mmio.Mmio(packed struct(u32) {
                /// Timer counter value.
                TCVAL: u32,
            }),
            /// Prescale Register
            PR: mmio.Mmio(packed struct(u32) {
                /// Prescale counter value.
                PRVAL: u32,
            }),
            /// Prescale Counter
            PC: mmio.Mmio(packed struct(u32) {
                /// Prescale counter value.
                PCVAL: u32,
            }),
            /// Match Control Register
            MCR: mmio.Mmio(packed struct(u32) {
                /// Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC.
                MR0I: u1,
                /// Reset on MR0: the TC will be reset if MR0 matches it.
                MR0R: u1,
                /// Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC.
                MR0S: u1,
                /// Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC.
                MR1I: u1,
                /// Reset on MR1: the TC will be reset if MR1 matches it.
                MR1R: u1,
                /// Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC.
                MR1S: u1,
                /// Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC.
                MR2I: u1,
                /// Reset on MR2: the TC will be reset if MR2 matches it.
                MR2R: u1,
                /// Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC.
                MR2S: u1,
                /// Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC.
                MR3I: u1,
                /// Reset on MR3: the TC will be reset if MR3 matches it.
                MR3R: u1,
                /// Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC.
                MR3S: u1,
                reserved24: u12,
                /// Reload MR0 with the contents of the Match 0 Shadow Register when the TC is reset to zero (either via a match event or a write to bit 1 of the TCR).
                MR0RL: u1,
                /// Reload MR1 with the contents of the Match 1 Shadow Register when the TC is reset to zero (either via a match event or a write to bit 1 of the TCR).
                MR1RL: u1,
                /// Reload MR2 with the contents of the Match 2 Shadow Register when the TC is reset to zero (either via a match event or a write to bit 1 of the TCR).
                MR2RL: u1,
                /// Reload MR3 with the contents of the Match 3 Shadow Register when the TC is reset to zero (either via a match event or a write to bit 1 of the TCR).
                MR3RL: u1,
                padding: u4,
            }),
            /// Match Register . MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
            MR: [4]mmio.Mmio(packed struct(u32) {
                /// Timer counter match value.
                MATCH: u32,
            }),
            /// Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
            CCR: mmio.Mmio(packed struct(u32) {
                /// Rising edge of capture channel 0: a sequence of 0 then 1 causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
                CAP0RE: u1,
                /// Falling edge of capture channel 0: a sequence of 1 then 0 causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
                CAP0FE: u1,
                /// Generate interrupt on channel 0 capture event: a CR0 load generates an interrupt.
                CAP0I: u1,
                /// Rising edge of capture channel 1: a sequence of 0 then 1 causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
                CAP1RE: u1,
                /// Falling edge of capture channel 1: a sequence of 1 then 0 causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
                CAP1FE: u1,
                /// Generate interrupt on channel 1 capture event: a CR1 load generates an interrupt.
                CAP1I: u1,
                /// Rising edge of capture channel 2: a sequence of 0 then 1 causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
                CAP2RE: u1,
                /// Falling edge of capture channel 2: a sequence of 1 then 0 causes CR2 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
                CAP2FE: u1,
                /// Generate interrupt on channel 2 capture event: a CR2 load generates an interrupt.
                CAP2I: u1,
                /// Rising edge of capture channel 3: a sequence of 0 then 1 causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
                CAP3RE: u1,
                /// Falling edge of capture channel 3: a sequence of 1 then 0 causes CR3 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.
                CAP3FE: u1,
                /// Generate interrupt on channel 3 capture event: a CR3 load generates an interrupt.
                CAP3I: u1,
                padding: u20,
            }),
            /// Capture Register . CR is loaded with the value of TC when there is an event on the CAPn. input.
            CR: [4]mmio.Mmio(packed struct(u32) {
                /// Timer counter capture value.
                CAP: u32,
            }),
            /// External Match Register. The EMR controls the match function and the external match pins.
            EMR: mmio.Mmio(packed struct(u32) {
                /// External Match 0. This bit reflects the state of output MAT0, whether or not this output is connected to a pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by EMR[5:4]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.
                EM0: u1,
                /// External Match 1. This bit reflects the state of output MAT1, whether or not this output is connected to a pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by EMR[7:6]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.
                EM1: u1,
                /// External Match 2. This bit reflects the state of output MAT2, whether or not this output is connected to a pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by EMR[9:8]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.
                EM2: u1,
                /// External Match 3. This bit reflects the state of output MAT3, whether or not this output is connected to a pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by MR[11:10]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.
                EM3: u1,
                /// External Match Control 0. Determines the functionality of External Match 0.
                EMC0: enum(u2) {
                    /// Do Nothing.
                    DO_NOTHING = 0x0,
                    /// Clear. Clear the corresponding External Match bit/output to 0 (MAT0 pin is LOW if pinned out).
                    CLEAR = 0x1,
                    /// Set. Set the corresponding External Match bit/output to 1 (MAT0 pin is HIGH if pinned out).
                    SET = 0x2,
                    /// Toggle. Toggle the corresponding External Match bit/output.
                    TOGGLE = 0x3,
                },
                /// External Match Control 1. Determines the functionality of External Match 1.
                EMC1: enum(u2) {
                    /// Do Nothing.
                    DO_NOTHING = 0x0,
                    /// Clear. Clear the corresponding External Match bit/output to 0 (MAT1 pin is LOW if pinned out).
                    CLEAR = 0x1,
                    /// Set. Set the corresponding External Match bit/output to 1 (MAT1 pin is HIGH if pinned out).
                    SET = 0x2,
                    /// Toggle. Toggle the corresponding External Match bit/output.
                    TOGGLE = 0x3,
                },
                /// External Match Control 2. Determines the functionality of External Match 2.
                EMC2: enum(u2) {
                    /// Do Nothing.
                    DO_NOTHING = 0x0,
                    /// Clear. Clear the corresponding External Match bit/output to 0 (MAT2 pin is LOW if pinned out).
                    CLEAR = 0x1,
                    /// Set. Set the corresponding External Match bit/output to 1 (MAT2 pin is HIGH if pinned out).
                    SET = 0x2,
                    /// Toggle. Toggle the corresponding External Match bit/output.
                    TOGGLE = 0x3,
                },
                /// External Match Control 3. Determines the functionality of External Match 3.
                EMC3: enum(u2) {
                    /// Do Nothing.
                    DO_NOTHING = 0x0,
                    /// Clear. Clear the corresponding External Match bit/output to 0 (MAT3 pin is LOW if pinned out).
                    CLEAR = 0x1,
                    /// Set. Set the corresponding External Match bit/output to 1 (MAT3 pin is HIGH if pinned out).
                    SET = 0x2,
                    /// Toggle. Toggle the corresponding External Match bit/output.
                    TOGGLE = 0x3,
                },
                padding: u20,
            }),
            reserved112: [48]u8,
            /// Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
            CTCR: mmio.Mmio(packed struct(u32) {
                /// Counter/Timer Mode This field selects which rising APB bus clock edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale Register.
                CTMODE: enum(u2) {
                    /// Timer Mode. Incremented every rising APB bus clock edge.
                    TIMER = 0x0,
                    /// Counter Mode rising edge. TC is incremented on rising edges on the CAP input selected by bits 3:2.
                    COUNTER_RISING_EDGE = 0x1,
                    /// Counter Mode falling edge. TC is incremented on falling edges on the CAP input selected by bits 3:2.
                    COUNTER_FALLING_EDGE = 0x2,
                    /// Counter Mode dual edge. TC is incremented on both edges on the CAP input selected by bits 3:2.
                    COUNTER_DUAL_EDGE = 0x3,
                },
                /// Count Input Select When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking. Note: If Counter mode is selected for a particular CAPn input in the CTCR, the 3 bits for that input in the Capture Control Register (CCR) must be programmed as 000. However, capture and/or interrupt can be selected for the other 3 CAPn inputs in the same timer.
                CINSEL: enum(u2) {
                    /// Channel 0. CAPn.0 for CTIMERn
                    CHANNEL_0 = 0x0,
                    /// Channel 1. CAPn.1 for CTIMERn
                    CHANNEL_1 = 0x1,
                    /// Channel 2. CAPn.2 for CTIMERn
                    CHANNEL_2 = 0x2,
                    /// Channel 3. CAPn.3 for CTIMERn
                    CHANNEL_3 = 0x3,
                },
                /// Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs.
                ENCC: u1,
                /// Edge select. When bit 4 is 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved.
                SELCC: enum(u3) {
                    /// Channel 0 Rising Edge. Rising edge of the signal on capture channel 0 clears the timer (if bit 4 is set).
                    CHANNEL_0_RISING = 0x0,
                    /// Channel 0 Falling Edge. Falling edge of the signal on capture channel 0 clears the timer (if bit 4 is set).
                    CHANNEL_0_FALLING = 0x1,
                    /// Channel 1 Rising Edge. Rising edge of the signal on capture channel 1 clears the timer (if bit 4 is set).
                    CHANNEL_1_RISING = 0x2,
                    /// Channel 1 Falling Edge. Falling edge of the signal on capture channel 1 clears the timer (if bit 4 is set).
                    CHANNEL_1_FALLING = 0x3,
                    /// Channel 2 Rising Edge. Rising edge of the signal on capture channel 2 clears the timer (if bit 4 is set).
                    CHANNEL_2_RISING = 0x4,
                    /// Channel 2 Falling Edge. Falling edge of the signal on capture channel 2 clears the timer (if bit 4 is set).
                    CHANNEL_2_FALLING = 0x5,
                    _,
                },
                padding: u24,
            }),
            /// PWM Control Register. The PWMCON enables PWM mode for the external match pins.
            PWMC: mmio.Mmio(packed struct(u32) {
                /// PWM mode enable for channel0.
                PWMEN0: enum(u1) {
                    /// Match. CTIMERn_MAT0 is controlled by EM0.
                    MATCH = 0x0,
                    /// PWM. PWM mode is enabled for CTIMERn_MAT0.
                    PWM = 0x1,
                },
                /// PWM mode enable for channel1.
                PWMEN1: enum(u1) {
                    /// Match. CTIMERn_MAT01 is controlled by EM1.
                    MATCH = 0x0,
                    /// PWM. PWM mode is enabled for CTIMERn_MAT1.
                    PWM = 0x1,
                },
                /// PWM mode enable for channel2.
                PWMEN2: enum(u1) {
                    /// Match. CTIMERn_MAT2 is controlled by EM2.
                    MATCH = 0x0,
                    /// PWM. PWM mode is enabled for CTIMERn_MAT2.
                    PWM = 0x1,
                },
                /// PWM mode enable for channel3. Note: It is recommended to use match channel 3 to set the PWM cycle.
                PWMEN3: enum(u1) {
                    /// Match. CTIMERn_MAT3 is controlled by EM3.
                    MATCH = 0x0,
                    /// PWM. PWM mode is enabled for CT132Bn_MAT3.
                    PWM = 0x1,
                },
                padding: u28,
            }),
            /// Match Shadow Register
            MSR: [4]mmio.Mmio(packed struct(u32) {
                /// Timer counter match shadow value.
                SHADOWW: u32,
            }),
        };

        /// LPC5411x DMA controller
        pub const DMA0 = extern struct {
            /// DMA control.
            CTRL: mmio.Mmio(packed struct(u32) {
                /// DMA controller master enable.
                ENABLE: enum(u1) {
                    /// Disabled. The DMA controller is disabled. This clears any triggers that were asserted at the point when disabled, but does not prevent re-triggering when the DMA controller is re-enabled.
                    DISABLED = 0x0,
                    /// Enabled. The DMA controller is enabled.
                    ENABLED = 0x1,
                },
                padding: u31,
            }),
            /// Interrupt status.
            INTSTAT: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// Summarizes whether any enabled interrupts (other than error interrupts) are pending.
                ACTIVEINT: enum(u1) {
                    /// Not pending. No enabled interrupts are pending.
                    NOT_PENDING = 0x0,
                    /// Pending. At least one enabled interrupt is pending.
                    PENDING = 0x1,
                },
                /// Summarizes whether any error interrupts are pending.
                ACTIVEERRINT: enum(u1) {
                    /// Not pending. No error interrupts are pending.
                    NOT_PENDING = 0x0,
                    /// Pending. At least one error interrupt is pending.
                    PENDING = 0x1,
                },
                padding: u29,
            }),
            /// SRAM address of the channel configuration table.
            SRAMBASE: mmio.Mmio(packed struct(u32) {
                reserved9: u9,
                /// Address bits 31:9 of the beginning of the DMA descriptor table. For 18 channels, the table must begin on a 512 byte boundary.
                OFFSET: u23,
            }),
            reserved32: [20]u8,
            /// Channel Enable read and Set for all DMA channels.
            ENABLESET0: mmio.Mmio(packed struct(u32) {
                /// Enable for DMA channels. Bit n enables or disables DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = disabled. 1 = enabled.
                ENA: u32,
            }),
            reserved40: [4]u8,
            /// Channel Enable Clear for all DMA channels.
            ENABLECLR0: mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register clears the corresponding bits in ENABLESET0. Bit n clears the channel enable bit n. The number of bits = number of DMA channels in this device. Other bits are reserved.
                CLR: u32,
            }),
            reserved48: [4]u8,
            /// Channel Active status for all DMA channels.
            ACTIVE0: mmio.Mmio(packed struct(u32) {
                /// Active flag for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = not active. 1 = active.
                ACT: u32,
            }),
            reserved56: [4]u8,
            /// Channel Busy status for all DMA channels.
            BUSY0: mmio.Mmio(packed struct(u32) {
                /// Busy flag for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = not busy. 1 = busy.
                BSY: u32,
            }),
            reserved64: [4]u8,
            /// Error Interrupt status for all DMA channels.
            ERRINT0: mmio.Mmio(packed struct(u32) {
                /// Error Interrupt flag for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = error interrupt is not active. 1 = error interrupt is active.
                ERR: u32,
            }),
            reserved72: [4]u8,
            /// Interrupt Enable read and Set for all DMA channels.
            INTENSET0: mmio.Mmio(packed struct(u32) {
                /// Interrupt Enable read and set for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = interrupt for DMA channel is disabled. 1 = interrupt for DMA channel is enabled.
                INTEN: u32,
            }),
            reserved80: [4]u8,
            /// Interrupt Enable Clear for all DMA channels.
            INTENCLR0: mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register clears corresponding bits in the INTENSET0. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved.
                CLR: u32,
            }),
            reserved88: [4]u8,
            /// Interrupt A status for all DMA channels.
            INTA0: mmio.Mmio(packed struct(u32) {
                /// Interrupt A status for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = the DMA channel interrupt A is not active. 1 = the DMA channel interrupt A is active.
                IA: u32,
            }),
            reserved96: [4]u8,
            /// Interrupt B status for all DMA channels.
            INTB0: mmio.Mmio(packed struct(u32) {
                /// Interrupt B status for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = the DMA channel interrupt B is not active. 1 = the DMA channel interrupt B is active.
                IB: u32,
            }),
            reserved104: [4]u8,
            /// Set ValidPending control bits for all DMA channels.
            SETVALID0: mmio.Mmio(packed struct(u32) {
                /// SETVALID control for DMA channel n. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = no effect. 1 = sets the VALIDPENDING control bit for DMA channel n
                SV: u32,
            }),
            reserved112: [4]u8,
            /// Set Trigger control bits for all DMA channels.
            SETTRIG0: mmio.Mmio(packed struct(u32) {
                /// Set Trigger control bit for DMA channel 0. Bit n corresponds to DMA channel n. The number of bits = number of DMA channels in this device. Other bits are reserved. 0 = no effect. 1 = sets the TRIG bit for DMA channel n.
                TRIG: u32,
            }),
            reserved120: [4]u8,
            /// Channel Abort control for all DMA channels.
            ABORT0: mmio.Mmio(packed struct(u32) {
                /// Abort control for DMA channel 0. Bit n corresponds to DMA channel n. 0 = no effect. 1 = aborts DMA operations on channel n.
                ABORTCTRL: u32,
            }),
        };

        /// LPC5411x DMIC Subsystem (DMIC))
        pub const DMIC0 = extern struct {
            reserved3840: [3840]u8,
            /// Channel Enable register
            CHANEN: mmio.Mmio(packed struct(u32) {
                /// Enable channel 0. When 1, PDM channel 0 is enabled.
                EN_CH0: u1,
                /// Enable channel 1. When 1, PDM channel 1 is enabled.
                EN_CH1: u1,
                padding: u30,
            }),
            reserved3852: [8]u8,
            /// I/O Configuration register
            IOCFG: mmio.Mmio(packed struct(u32) {
                /// Bypass CLK0. When 1, PDM_DATA1 becomes the clock for PDM channel 0. This provides for the possibility of an external codec taking over the PDM bus.
                CLK_BYPASS0: u1,
                /// Bypass CLK1. When 1, PDM_DATA1 becomes the clock for PDM channel 1. This provides for the possibility of an external codec taking over the PDM bus.
                CLK_BYPASS1: u1,
                /// Stereo PDM select. When 1, PDM_DATA0 is routed to both PDM channels in a configuration that supports a single stereo digital microphone.
                STEREO_DATA0: u1,
                padding: u29,
            }),
            /// Use 2FS register
            USE2FS: mmio.Mmio(packed struct(u32) {
                /// Use 2FS register
                USE2FS: enum(u1) {
                    /// Use 1FS output for PCM data.
                    USE_1FS = 0x0,
                    /// Use 2FS output for PCM data.
                    USE_2FS = 0x1,
                },
                padding: u31,
            }),
            reserved3968: [108]u8,
            /// HWVAD input gain register
            HWVADGAIN: mmio.Mmio(packed struct(u32) {
                /// Shift value for input bits 0x00 -10 bits 0x01 -8 bits 0x02 -6 bits 0x03 -4 bits 0x04 -2 bits 0x05 0 bits (default) 0x06 +2 bits 0x07 +4 bits 0x08 +6 bits 0x09 +8 bits 0x0A +10 bits 0x0B +12 bits 0x0C +14 bits 0x0D to 0x0F Reserved.
                INPUTGAIN: u4,
                padding: u28,
            }),
            /// HWVAD filter control register
            HWVADHPFS: mmio.Mmio(packed struct(u32) {
                /// High pass filter
                HPFS: enum(u2) {
                    /// First filter by-pass.
                    BYPASS = 0x0,
                    /// High pass filter with -3dB cut-off at 1750Hz.
                    HIGH_PASS_1750HZ = 0x1,
                    /// High pass filter with -3dB cut-off at 215Hz.
                    HIGH_PASS_215HZ = 0x2,
                    _,
                },
                padding: u30,
            }),
            /// HWVAD control register
            HWVADST10: mmio.Mmio(packed struct(u32) {
                /// Stage 0
                ST10: enum(u1) {
                    /// Normal operation, waiting for HWVAD trigger event (stage 0).
                    NORMAL = 0x0,
                    /// Reset internal interrupt flag by writing a '1' pulse.
                    RESET = 0x1,
                },
                padding: u31,
            }),
            /// HWVAD filter reset register
            HWVADRSTT: mmio.Mmio(packed struct(u32) {
                /// Writing a 1 resets all filter values
                RSTT: u1,
                padding: u31,
            }),
            /// HWVAD noise estimator gain register
            HWVADTHGN: mmio.Mmio(packed struct(u32) {
                /// Gain value for the noise estimator. Values 0 to 14. 0 corresponds to a gain of 1.
                THGN: u4,
                padding: u28,
            }),
            /// HWVAD signal estimator gain register
            HWVADTHGS: mmio.Mmio(packed struct(u32) {
                /// Gain value for the signal estimator. Values 0 to 14. 0 corresponds to a gain of 1.
                THGS: u4,
                padding: u28,
            }),
            /// HWVAD noise envelope estimator register
            HWVADLOWZ: mmio.Mmio(packed struct(u32) {
                /// Noise envelope estimator value.
                LOWZ: u16,
                padding: u16,
            }),
            reserved4092: [96]u8,
            /// Module Identification register
            ID: mmio.Mmio(packed struct(u32) {
                /// Indicates module ID and the number of channels in this DMIC interface.
                ID: u32,
            }),
        };

        /// LPC5460x EEPROM controller
        pub const EEPROM = extern struct {
            /// EEPROM command register
            CMD: mmio.Mmio(packed struct(u32) {
                /// Command.
                CMD: u3,
                padding: u29,
            }),
            reserved8: [4]u8,
            /// EEPROM read wait state register
            RWSTATE: mmio.Mmio(packed struct(u32) {
                /// Wait states 2 (minus 1 encoded).
                RPHASE2: u8,
                /// Wait states 1 (minus 1 encoded).
                RPHASE1: u8,
                padding: u16,
            }),
            /// EEPROM auto programming register
            AUTOPROG: mmio.Mmio(packed struct(u32) {
                /// Auto programming mode: 00 = auto programming off 01 = erase/program cycle is triggered after 1 word is written 10 = erase/program cycle is triggered after a write to AHB address ending with .
                AUTOPROG: u2,
                padding: u30,
            }),
            /// EEPROM wait state register
            WSTATE: mmio.Mmio(packed struct(u32) {
                /// Wait states for phase 3 (minus 1 encoded).
                PHASE3: u8,
                /// Wait states for phase 2 (minus 1 encoded).
                PHASE2: u8,
                /// Wait states for phase 1 (minus 1 encoded).
                PHASE1: u8,
                reserved31: u7,
                /// Lock timing parameters for write, erase and program operation 0 = WSTATE and CLKDIV registers have R/W access 1 = WSTATE and CLKDIV registers have R only access.
                LCK_PARWEP: u1,
            }),
            /// EEPROM clock divider register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                /// Division factor (minus 1 encoded).
                CLKDIV: u16,
                padding: u16,
            }),
            /// EEPROM power-down register
            PWRDWN: mmio.Mmio(packed struct(u32) {
                /// Power down mode bit.
                PWRDWN: u1,
                padding: u31,
            }),
            reserved4056: [4028]u8,
            /// EEPROM interrupt enable clear
            INTENCLR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Clear program operation finished interrupt enable bit for EEPROM.
                PROG_CLR_EN: u1,
                padding: u29,
            }),
            /// EEPROM interrupt enable set
            INTENSET: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Set program operation finished interrupt enable bit for EEPROM device 1.
                PROG_SET_EN: u1,
                padding: u29,
            }),
            /// EEPROM interrupt status
            INTSTAT: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// EEPROM program operation finished interrupt status bit.
                END_OF_PROG: u1,
                padding: u29,
            }),
            /// EEPROM interrupt enable
            INTEN: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// EEPROM program operation finished interrupt enable bit.
                EE_PROG_DONE: u1,
                padding: u29,
            }),
            /// EEPROM interrupt status clear
            INTSTATCLR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Clear program operation finished interrupt status bit for EEPROM device.
                PROG_CLR_ST: u1,
                padding: u29,
            }),
            /// EEPROM interrupt status set
            INTSTATSET: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Set program operation finished interrupt status bit for EEPROM device.
                PROG_SET_ST: u1,
                padding: u29,
            }),
        };

        /// LPC5460x External Memory Controller (EMC)
        pub const EMC = extern struct {
            /// Controls operation of the memory controller
            CONTROL: mmio.Mmio(packed struct(u32) {
                /// EMC Enable.
                E: u1,
                /// Address mirror.
                M: u1,
                /// Low-power mode.
                L: u1,
                padding: u29,
            }),
            /// Provides EMC status information
            STATUS: mmio.Mmio(packed struct(u32) {
                /// Busy.
                B: u1,
                /// Write buffer status.
                S: u1,
                /// Self-refresh acknowledge.
                SA: u1,
                padding: u29,
            }),
            /// Configures operation of the memory controller
            CONFIG: mmio.Mmio(packed struct(u32) {
                /// Endian mode.
                EM: u1,
                reserved8: u7,
                /// This bit must contain 0 for proper operation of the EMC.
                CLKR: u1,
                padding: u23,
            }),
            reserved32: [20]u8,
            /// Controls dynamic memory operation
            DYNAMICCONTROL: mmio.Mmio(packed struct(u32) {
                /// Dynamic memory clock enable.
                CE: u1,
                /// Dynamic memory clock control.
                CS: u1,
                /// Self-refresh request, EMCSREFREQ.
                SR: u1,
                reserved5: u2,
                /// Memory clock control.
                MMC: u1,
                reserved7: u1,
                /// SDRAM initialization.
                I: u2,
                padding: u23,
            }),
            /// Configures dynamic memory refresh
            DYNAMICREFRESH: mmio.Mmio(packed struct(u32) {
                /// Refresh timer.
                REFRESH: u11,
                padding: u21,
            }),
            /// Configures dynamic memory read strategy
            DYNAMICREADCONFIG: mmio.Mmio(packed struct(u32) {
                /// Read data strategy.
                RD: u2,
                padding: u30,
            }),
            reserved48: [4]u8,
            /// Precharge command period
            DYNAMICRP: mmio.Mmio(packed struct(u32) {
                /// Precharge command period.
                TRP: u4,
                padding: u28,
            }),
            /// Active to precharge command period
            DYNAMICRAS: mmio.Mmio(packed struct(u32) {
                /// Active to precharge command period.
                TRAS: u4,
                padding: u28,
            }),
            /// Self-refresh exit time
            DYNAMICSREX: mmio.Mmio(packed struct(u32) {
                /// Self-refresh exit time.
                TSREX: u4,
                padding: u28,
            }),
            /// Last-data-out to active command time
            DYNAMICAPR: mmio.Mmio(packed struct(u32) {
                /// Last-data-out to active command time.
                TAPR: u4,
                padding: u28,
            }),
            /// Data-in to active command time
            DYNAMICDAL: mmio.Mmio(packed struct(u32) {
                /// Data-in to active command.
                TDAL: u4,
                padding: u28,
            }),
            /// Write recovery time
            DYNAMICWR: mmio.Mmio(packed struct(u32) {
                /// Write recovery time.
                TWR: u4,
                padding: u28,
            }),
            /// Selects the active to active command period
            DYNAMICRC: mmio.Mmio(packed struct(u32) {
                /// Active to active command period.
                TRC: u5,
                padding: u27,
            }),
            /// Selects the auto-refresh period
            DYNAMICRFC: mmio.Mmio(packed struct(u32) {
                /// Auto-refresh period and auto-refresh to active command period.
                TRFC: u5,
                padding: u27,
            }),
            /// Time for exit self-refresh to active command
            DYNAMICXSR: mmio.Mmio(packed struct(u32) {
                /// Exit self-refresh to active command time.
                TXSR: u5,
                padding: u27,
            }),
            /// Latency for active bank A to active bank B
            DYNAMICRRD: mmio.Mmio(packed struct(u32) {
                /// Active bank A to active bank B latency 0x0 - 0xE = n + 1 clock cycles.
                TRRD: u4,
                padding: u28,
            }),
            /// Time for load mode register to active command
            DYNAMICMRD: mmio.Mmio(packed struct(u32) {
                /// Load mode register to active command time.
                TMRD: u4,
                padding: u28,
            }),
            reserved128: [36]u8,
            /// Time for long static memory read and write transfers
            STATICEXTENDEDWAIT: mmio.Mmio(packed struct(u32) {
                /// Extended wait time out.
                EXTENDEDWAIT: u10,
                padding: u22,
            }),
        };

        /// LPC5460x Ethernet controller
        pub const ENET = extern struct {
            /// MAC configuration register
            MAC_CONFIG: mmio.Mmio(packed struct(u32) {
                /// Receiver Enable When this bit is set, the receiver state machine of the MAC is enabled for receiving frames from the MII.
                RE: u1,
                /// Transmitter Enable When this bit is set, the transmit state machine of the MAC is enabled for transmission on the MII.
                TE: u1,
                /// Preamble Length for Transmit packets These bits control the number of preamble bytes that are added to the beginning of every Tx packet.
                PRELEN: u2,
                /// Deferral Check When this bit is set, the deferral check function is enabled in the MAC.
                DC: u1,
                /// Back-Off Limit The Back-Off limit determines the random integer number (r) of slot time delays (4,096 bit times for 1000 Mbps and 512 bit times for 10/100 Mbps) the MAC waits before rescheduling a transmission attempt during retries after a collision.
                BL: u2,
                reserved8: u1,
                /// Disable Retry When this bit is set, the MAC will attempt only one transmission.
                DR: u1,
                /// Disable Carrier Sense During Transmission When this bit is set, the MAC transmitter ignores the MII CRS signal during packet transmission in the half-duplex mode.
                DCRS: u1,
                /// Disable Receive Own When this bit is set, the MAC disables the reception of frames when the gmii_txen_o is asserted in Half-Duplex mode.
                DO: u1,
                /// Enable Carrier Sense Before Transmission in Full-Duplex Mode When this bit is set, the MAC transmitter checks the CRS signal before packet transmission in the full-duplex mode.
                ECRSFD: u1,
                /// Loopback Mode When this bit is set, the MAC operates in loopback mode at MII.
                LM: u1,
                /// Duplex Mode When this bit is set, the MAC operates in a Full-Duplex mode where it can transmit and receive simultaneously.
                DM: u1,
                /// Speed Indicates the speed in Fast Ethernet (MII) mode: This bit is reserved (RO) by default and is enabled only when RMII/SMII is enabled during configuration.
                FES: u1,
                /// Portselect.
                PS: u1,
                /// Jumbo Frame Enable When this bit is set, MAC allows Jumbo frames of 9,018 bytes (9,022 bytes for tagged frames) without reporting a giant frame error in the receive frame status.
                JE: u1,
                /// Jabber Disable When this bit is set, the MAC disables the jabber timer on the transmitter, and can transfer frames of up to 16,384 bytes.
                JD: u1,
                /// Packet Burst Enable When this bit is set, the MAC allows packet bursting during transmission in the MII half-duplex mode.
                BE: u1,
                /// Watchdog Disable When this bit is set, the MAC disables the watchdog timer on the receiver, and can receive frames of up to 16,384 bytes.
                WD: u1,
                /// Automatic Pad or CRC Stripping When this bit is set, the MAC strips the Pad or FCS field on the incoming packets only if the value of the length field is less than 1,536 bytes.
                ACS: u1,
                /// CRC stripping for Type packets When this bit is set, the last four bytes (FCS) of all packets of Ether type (type field greater than 1,536) are stripped and dropped before forwarding the packet to the application.
                CST: u1,
                /// IEEE 802.
                S2KP: u1,
                /// Giant Packet Size Limit Control Enable When this bit is set, the MAC considers the value in GPSL field in MAC Ext Configuration register to declare a received packet as Giant packet.
                GPSLCE: u1,
                /// Inter-Packet Gap These bits control the minimum IPG between packets during transmission.
                IPG: u3,
                /// Checksum Offload When set, this bit enables the IPv4 header checksum checking and IPv4 or IPv6 TCP, UDP, or ICMP payload checksum checking.
                IPC: u1,
                padding: u4,
            }),
            /// no description available
            MAC_EXT_CONFIG: mmio.Mmio(packed struct(u32) {
                /// Giant Packet Size Limit If the received packet size is greater than the value programmed in this field in units of bytes, the MAC declares the received packet as Giant packet.
                GPSL: u14,
                reserved16: u2,
                /// Disable CRC Checking for Received Packets When this bit is set, the MAC receiver does not check the CRC field in the received packets.
                DCRCC: u1,
                /// Slow Protocol Detection Enable When this bit is set, MAC processes the Slow Protocol packets (Ether Type 0x8809) and provides the Rx status.
                SPEN: u1,
                /// Unicast Slow Protocol Packet Detect When this bit is set, the MAC detects the Slow Protocol packets with unicast address of the station specified in the MAC Address High Table 747 and MAC Address Low Table 748 registers.
                USP: u1,
                padding: u13,
            }),
            /// MAC frame filter register
            MAC_FRAME_FILTER: mmio.Mmio(packed struct(u32) {
                /// Promiscuous Mode When this bit is set, the Address Filter module passes all incoming frames regardless of its destination or source address.
                PR: u1,
                reserved3: u2,
                /// DA Inverse Filtering When this bit is set, the Address Check block operates in inverse filtering mode for the DA address comparison for both unicast and multicast frames.
                DAIF: u1,
                /// Pass All Multicast When set, this bit indicates that all received frames with a multicast destination address (first bit in the destination address field is '1') are passed.
                PM: u1,
                /// Disable Broadcast Frames When this bit is set, the AFM module filters all incoming broadcast frames.
                DBF: u1,
                /// Pass Control Frames These bits control the forwarding of all control frames (including unicast and multicast PAUSE frames).
                PCF: u2,
                /// SA Inverse Filtering When this bit is set, the Address Check block operates in the inverse filtering mode for SA address comparison.
                SAIF: u1,
                /// Source Address Filter Enable When this bit is set, the MAC compares the SA field of the received packets with the values programmed in the enabled SA registers.
                SAF: u1,
                reserved31: u21,
                /// Receive all When this bit is set, the MAC Receiver module passes to the Application all frames received irrespective of whether they pass the address filter.
                RA: u1,
            }),
            /// MAC watchdog Timeout register
            MAC_WD_TIMEROUT: mmio.Mmio(packed struct(u32) {
                /// Watchdog Timeout When the PWE bit is set and the WD bit of the MAC Configuration register Table 722 is reset, this field is used as watchdog timeout for a received packet.
                WTO: u4,
                reserved8: u4,
                /// Programmable Watchdog Enable When this bit is set and the WD bit of the MAC Configuration register Table 722 is reset, the WTO field is used as watchdog timeout for a received packet.
                PWE: u1,
                padding: u23,
            }),
            reserved80: [64]u8,
            /// MAC vlan tag register
            MAC_VLAN_TAG: mmio.Mmio(packed struct(u32) {
                /// VLAN Tag Identifier for Receive Packets.
                VL: u16,
                /// Enable 12-Bit VLAN Tag Comparison.
                ETV: u1,
                /// VLAN Tag Inverse Match Enable.
                VTIM: u1,
                /// Enable S-VLAN.
                ESVL: u1,
                /// Enable Receive S-VLAN Match.
                ERSVLM: u1,
                /// Disable VLAN Type Check.
                DOVLTC: u1,
                /// Enable VLAN Tag Stripping on Receive.
                EVLS: u2,
                reserved24: u1,
                /// Enable VLAN Tag in Rx status.
                EVLRXS: u1,
                /// Disable VLAN Type Check.
                VTHM: u1,
                /// Enable Double VLAN Processing.
                EDVLP: u1,
                /// Enable Inner VLAN Tag.
                ERIVLT: u1,
                /// Enable Inner VLAN Tag Stripping on Receive.
                EIVLS: u2,
                reserved31: u1,
                /// Enable Inner VLAN Tag in Rx Status.
                EIVLRXS: u1,
            }),
            reserved112: [28]u8,
            /// Transmit flow control register
            MAC_TX_FLOW_CTRL_Q: [2]mmio.Mmio(packed struct(u32) {
                /// Flow Control Busy/Backpressure Activate This register field can be read by the application (Read), can be set to 1 by the application with a register write of 1 (Write Set), and is cleared to 0 by the core (Self Clear).
                FCB: u1,
                /// Transmit Flow Control Enable In Full-Duplex mode, when this bit is set, the MAC enables the flow control operation to transmit Pause frames.
                TFE: u1,
                reserved4: u2,
                /// Pause Low Threshold This field configures the threshold of the PAUSE timer at which the input flow control signal is checked for automatic retransmission of PAUSE Frame.
                PLT: u3,
                /// Disable Zero-Quanta Pause When set, this bit disables the automatic generation of Zero-Quanta Pause Control frames on the deassertion of the flow-control signal from the FIFO layer.
                DZPQ: u1,
                reserved16: u8,
                /// Pause time This field holds the value to be used in the Pause Time field in the transmit control frame.
                PT: u16,
            }),
            reserved144: [24]u8,
            /// Receive flow control register
            MAC_RX_FLOW_CTRL: mmio.Mmio(packed struct(u32) {
                /// Receive Flow Control Enable When this bit is set and the MAC is operating in full-duplex mode, the MAC decodes the received Pause packet and disables its transmitter for a specified (Pause) time.
                RFE: u1,
                /// Unicast Pause Packet Detect A pause packet is processed when it has the unique multicast address specified in the IEEE 802.
                UP: u1,
                padding: u30,
            }),
            reserved152: [4]u8,
            /// no description available
            MAC_TXQ_PRIO_MAP: mmio.Mmio(packed struct(u32) {
                /// Priorities Selected in Transmit Queue 0 This field holds the priorities assigned to Tx Queue 0 by the software.
                PSTQ0: u8,
                /// Priorities Selected in Transmit Queue 1 This bit is similar to the PSTQ0 bit.
                PSTQ1: u8,
                padding: u16,
            }),
            reserved160: [4]u8,
            /// Receive Queue Control 0 register 0x0000
            MAC_RXQ_CTRL0: mmio.Mmio(packed struct(u32) {
                /// Receive Queue 0 Enable.
                RXQ0EN: u2,
                /// Receive Queue 1 Enable.
                RXQ1EN: u2,
                padding: u28,
            }),
            /// Receive Queue Control 0 register 0x0000
            MAC_RXQ_CTRL1: mmio.Mmio(packed struct(u32) {
                /// AV Untagged Control Packets Queue.
                AVCPQ: u3,
                reserved4: u1,
                /// AV PTP Packets Queue.
                AVPTPQ: u3,
                reserved12: u5,
                /// Untagged Packet Queue.
                UPQ: u3,
                reserved16: u1,
                /// Multicast and Broadcast Queue.
                MCBCQ: u3,
                reserved20: u1,
                /// Multicast and Broadcast Queue Enable.
                MCBCQEN: u1,
                padding: u11,
            }),
            /// Receive Queue Control 0 register 0x0000
            MAC_RXQ_CTRL2: mmio.Mmio(packed struct(u32) {
                /// Priorities Selected in the Receive Queue 0.
                PSRQ0: u8,
                /// Priorities Selected in the Receive Queue 1.
                PSRQ1: u8,
                /// Priorities Selected in the Receive Queue 2.
                PSRQ2: u8,
                /// Priorities Selected in the Receive Queue 3.
                PSRQ3: u8,
            }),
            reserved176: [4]u8,
            /// Interrupt status register 0x0000
            MAC_INTR_STAT: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// PHY Interrupt.
                PHYIS: u1,
                /// PMT Interrupt Status.
                PMTIS: u1,
                /// LPI Interrupt Status.
                LPIIS: u1,
                reserved12: u6,
                /// Timestamp interrupt status.
                TSIS: u1,
                /// Transmit Status Interrupt.
                TXSTSIS: u1,
                /// Receive Status Interrupt.
                RXSTSIS: u1,
                padding: u17,
            }),
            /// Interrupt enable register 0x0000
            MAC_INTR_EN: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// PHY Interrupt Enable.
                PHYIE: u1,
                /// PMT Interrupt Enable.
                PMTIE: u1,
                /// LPI Interrupt Enable.
                LPIIE: u1,
                reserved12: u6,
                /// Timestamp Interrupt Enable.
                TSIE: u1,
                /// Transmit Status Interrupt Enable.
                TXSTSIE: u1,
                /// Receive Status Interrupt Enable.
                RXSTSIS: u1,
                padding: u17,
            }),
            /// Receive Transmit Status register
            MAC_RXTX_STAT: mmio.Mmio(packed struct(u32) {
                /// PHY Interrupt Enable When this bit is set, it enables the assertion of the interrupt signal because of the setting of PHYIS bit in MAC Interrupt Status register Table 731.
                TJT: u1,
                /// No Carrier When the DTXSTS bit is set in the MTL Operation Mode register Table 758, this bit indicates that the carrier signal from the PHY is not present at the end of preamble transmission.
                NCARR: u1,
                /// Loss of Carrier When the DTXSTS bit is set in the MTL Operation Mode register Table 758, this bit indicates that the loss of carrier occurred during packet transmission, that is, the PHY Carrier signal was inactive for one or more transmission clock periods during packet transmission.
                LCARR: u1,
                /// Excessive Deferral When the DTXSTS bit is set in the MTL Operation Mode register Table 758 and the DC bit is set in the MAC Configuration register Table 758, this bit indicates that the transmission ended because of excessive deferral of over 24,288 bit times (155,680 when Jumbo packet is enabled).
                EXDEF: u1,
                /// Late Collision When the DTXSTS bit is set in the MTL Operation Mode register Table 758, this bit indicates that the packet transmission aborted because a collision occurred after the collision window (64 bytes including Preamble in MII mode).
                LCOL: u1,
                /// Excessive Collisions When the DTXSTS bit is set in the MTL Operation Mode register Table 758, this bit indicates that the transmission aborted after 16 successive collisions while attempting to transmit the current packet.
                EXCOL: u1,
                reserved8: u2,
                /// Receive Watchdog Timeout This bit is set when a packet with length greater than 2,048 bytes is received (10,240 bytes when Jumbo Packet mode is enabled) and the WD bit is reset in the MAC Configuration register Table 722.
                RWT: u1,
                padding: u23,
            }),
            reserved192: [4]u8,
            /// no description available
            MAC_PMT_CRTL_STAT: mmio.Mmio(packed struct(u32) {
                /// Transmit LPI Entry When this bit is set, it indicates that the MAC Transmitter has entered the LPI state because of the setting of the LPIEN bit.
                PWRDWN: u1,
                /// Magic Packet Enable.
                MGKPKTEN: u1,
                /// Remote Wake-Up Packet Enable When this bit is set, a power management event is generated when the MAC receives a remote wake-up packet.
                RWKPKTEN: u1,
                reserved5: u2,
                /// Magic Packet Received.
                MGKPRCVD: u1,
                /// Remote Wake-Up Packet Received.
                RWKPRCVD: u1,
                reserved9: u2,
                /// Global Unicast When this bit set, any unicast packet filtered by the MAC (DAF) address recognition is detected as a remote wake-up packet.
                GLBLUCAST: u1,
                /// Remote Wake-up Packet Forwarding Enable When this bit is set along with RWKPKTEN, the MAC receiver drops all received frames until it receives the expected wake-up frame.
                RWKPFE: u1,
                reserved24: u13,
                /// Remote Wake-up FIFO Pointer This field gives the current value (0 to 7) of the Remote Wake-up Packet Filter register pointer.
                RWKPTR: u5,
                reserved31: u2,
                /// Remote Wake-Up Packet Filter Register Pointer Reset When this bit is set, the remote wake-up packet filter register pointer is reset to 3'b000.
                RWKFILTRST: u1,
            }),
            /// Remote wake-up frame filter
            MAC_RWAKE_FRFLT: mmio.Mmio(packed struct(u32) {
                /// WKUPFMFILTER address.
                ADDR: u32,
            }),
            reserved208: [8]u8,
            /// LPI Control and Status Register
            MAC_LPI_CTRL_STAT: mmio.Mmio(packed struct(u32) {
                /// Transmit LPI Entry When this bit is set, it indicates that the MAC Transmitter has entered the LPI state because of the setting of the LPIEN bit.
                TLPIEN: u1,
                /// Transmit LPI Exit When this bit is set, it indicates that the MAC transmitter exited the LPI state after the application cleared the LPIEN bit and the LPI TW Timer has expired.
                TLPIEX: u1,
                /// Receive LPI Entry When this bit is set, it indicates that the MAC Receiver has received an LPI pattern and entered the LPI state.
                RLPIEN: u1,
                /// Receive LPI Exit When this bit is set, it indicates that the MAC Receiver has stopped receiving the LPI pattern on the MII interface, exited the LPI state, and resumed the normal reception.
                RLPIEX: u1,
                reserved8: u4,
                /// Transmit LPI State When this bit is set, it indicates that the MAC is transmitting the LPI pattern on the MII interface.
                TLPIST: u1,
                /// Receive LPI State When this bit is set, it indicates that the MAC is receiving the LPI pattern on the MII interface.
                RLPIST: u1,
                reserved16: u6,
                /// LPI Enable When this bit is set, it instructs the MAC Transmitter to enter the LPI state.
                LPIEN: u1,
                /// PHY Link Status This bit indicates the link status of the PHY.
                PLS: u1,
                reserved19: u1,
                /// LPI Tx Automate This bit controls the behavior of the MAC when it is entering or coming out of the LPI mode on the Transmit side.
                LPITXA: u1,
                /// LPI Timer Enable This bit controls the automatic entry of the MAC Transmitter into and exit out of the LPI state.
                LPIATE: u1,
                /// LPI Tx Clock Stop Enable When this bit is set, the MAC asserts LPI Tx Clock Gating Control signal high after it enters Tx LPI mode to indicate that the Tx clock to MAC can be stopped.
                LPITCSE: u1,
                padding: u10,
            }),
            /// LPI Timers Control register
            MAC_LPI_TIMER_CTRL: mmio.Mmio(packed struct(u32) {
                /// LPI TW Timer This field specifies the minimum time (in microseconds) for which the MAC waits after it stops transmitting the LPI pattern to the PHY and before it resumes the normal transmission.
                TWT: u16,
                /// LPI LS Timer This field specifies the minimum time (in milliseconds) for which the link status from the PHY should be up (OKAY) before the LPI pattern can be transmitted to the PHY.
                LST: u10,
                padding: u6,
            }),
            /// LPI entry Timer register
            MAC_LPI_ENTR_TIMR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// LPI Entry Timer This field specifies the time in microseconds the MAC will wait to enter LPI mode, after it has transmitted all the frames.
                LPIET: u17,
                padding: u12,
            }),
            /// no description available
            MAC_1US_TIC_COUNTR: mmio.Mmio(packed struct(u32) {
                /// 1US TIC Counter The application must program this counter so that the number of clock cycles of CSR clock is 1us.
                TIC_1US_CNTR: u12,
                padding: u20,
            }),
            reserved272: [48]u8,
            /// MAC version register
            MAC_VERSION: mmio.Mmio(packed struct(u32) {
                /// NXP defined version.
                SNPVER: u8,
                /// User defined version.
                USERVER: u8,
                padding: u16,
            }),
            /// MAC debug register
            MAC_DBG: mmio.Mmio(packed struct(u32) {
                /// MAC MII Receive Protocol Engine Status When this bit is set, it indicates that the MAC MII receive protocol engine is actively receiving data, and it is not in the Idle state.
                REPESTS: u1,
                /// MAC Receive Packet Controller FIFO Status When this bit is set, this field indicates the active state of the small FIFO Read and Write controllers of the MAC Receive Packet Controller module.
                RFCFCSTS: u2,
                reserved16: u13,
                /// MAC MII Transmit Protocol Engine Status When this bit is set, it indicates that the MAC or MII transmit protocol engine is actively transmitting data, and it is not in the Idle state.
                TPESTS: u1,
                /// MAC Transmit Packet Controller Status This field indicates the state of the MAC Transmit Packet Controller module.
                TFCSTS: u2,
                padding: u13,
            }),
            reserved284: [4]u8,
            /// MAC hardware feature register 0x0201
            MAC_HW_FEAT0: mmio.Mmio(packed struct(u32) {
                /// 10 or 100 Mbps Support.
                MIISEL: u1,
                reserved2: u1,
                /// Half-duplex Support.
                HDSEL: u1,
                reserved4: u1,
                /// Hash Table Based Filtering option.
                VLHASH: u1,
                /// SMA (MDIO) Interface.
                SMASEL: u1,
                /// PMT Remote Wake-up Packet Detection.
                RWKSEL: u1,
                /// PMT magic packet detection.
                MGKSEL: u1,
                /// RMON Module Enable.
                MMCSEL: u1,
                /// ARP Offload Enabled.
                ARPOFFSEL: u1,
                reserved12: u2,
                /// IEEE 1588-2008 Timestamp support .
                TSSEL: u1,
                /// Energy Efficient Ethernet Support .
                EEESEL: u1,
                /// Transmit Checksum Offload Support.
                TXCOESEL: u1,
                reserved16: u1,
                /// Receive Checksum Offload Support.
                RXCOESEL: u1,
                reserved25: u8,
                /// Timestamp System Time Source.
                TSSTSSEL: u2,
                reserved28: u1,
                /// Active PHY Selected.
                ACTPHYSEL: u3,
                padding: u1,
            }),
            /// MAC hardware feature register 0x0201
            MAC_HW_FEAT1: mmio.Mmio(packed struct(u32) {
                /// MTL Receive FIFO Size.
                RXFIFOSIZE: u5,
                reserved6: u1,
                /// MTL Transmit FIFO Size.
                TXFIFOSIZE: u5,
                /// One-Step Timestamping Feature.
                OSTEN: u1,
                /// PTP OffLoad Feature.
                PTOEN: u1,
                /// IEEE 1588 High Word Register Feature.
                ADVTHWORD: u1,
                /// Address width.
                ADDR64: u2,
                /// Data Center Bridging feature.
                DCBEN: u1,
                /// Split Header Structure feature.
                SPEN: u1,
                /// TCP Segment Offload Feature.
                TSOEN: u1,
                /// DMA Debug Register Feature.
                DBGMEMA: u1,
                /// Audio Video Bridging Feature.
                AVSEL: u1,
                reserved23: u2,
                /// Low Power Mode Feature Support .
                LPMODEEN: u1,
                /// Hash Table Size.
                HASHTBLSZ: u2,
                reserved27: u1,
                /// Total Number of L3 and L4 Filters .
                L3_L4_FILTER: u4,
                padding: u1,
            }),
            /// MAC hardware feature register 0x0201
            MAC_HW_FEAT2: mmio.Mmio(packed struct(u32) {
                /// Number of MTL Receive Queues.
                RXQCNT: u4,
                reserved6: u2,
                /// Number of MTL Transmit Queues.
                TXQCNT: u4,
                reserved12: u2,
                /// Number of DMA Receive Channels.
                RXCHCNT: u4,
                reserved18: u2,
                /// Number of DMA Transmit Channels.
                TXCHCNT: u4,
                reserved24: u2,
                /// Number of PPS Outputs.
                PPSOUTNUM: u3,
                reserved28: u1,
                /// Number of Auxiliary Snapshot Inputs.
                AUXSNAPNUM: u3,
                padding: u1,
            }),
            reserved512: [216]u8,
            /// MIDO address Register
            MAC_MDIO_ADDR: mmio.Mmio(packed struct(u32) {
                /// MII busy.
                MB: u1,
                reserved2: u1,
                /// MII Operation Command.
                MOC: u2,
                reserved8: u4,
                /// CSR Clock Range.
                CR: u4,
                /// Number of Training Clocks This field controls the number of trailing clock cycles generated on MDC after the end of transmission of MDIO frame.
                NTC: u3,
                reserved16: u1,
                /// Register/Device Address These bits select the PHY register in selected PHY device.
                RDA: u5,
                /// Physical Layer Address This field indicates which PHY devices (out of 32 devices) the MAC is accessing.
                PA: u5,
                /// Back to Back transactions When this bit is set and the NTC has value greater than 0, then the MAC will inform the completion of a read or write command at the end of frame transfer (before the trailing clocks are transmitted).
                BTB: u1,
                /// Preamble Suppression Enable When this bit is set, the SMA will suppress the 32-bit preamble and transmit MDIO frames with only 1 preamble bit.
                PSE: u1,
                padding: u4,
            }),
            /// MDIO Data register
            MAC_MDIO_DATA: mmio.Mmio(packed struct(u32) {
                /// MII Data This field contains the 16-bit data value read from the PHY after a Management Read operation or the 16-bit data value to be written to the PHY before a Management Write operation.
                MD: u16,
                padding: u16,
            }),
            reserved768: [248]u8,
            /// MAC address0 high register
            MAC_ADDR_HIGH: mmio.Mmio(packed struct(u32) {
                /// MAC Address0 [47:32] This field contains the upper 16 bits (47:32) of the 6-byte first MAC address.
                A47_32: u16,
                /// DMA Channel Select This field contains the DMA Channel number to which the Rx packet whose DA matches the MAC Address content is routed.
                DCS: u1,
                reserved31: u14,
                /// Address Enable.
                AE: u1,
            }),
            /// MAC address0 low register
            MAC_ADDR_LOW: mmio.Mmio(packed struct(u32) {
                /// MAC Address0 [31:0] This field contains the lower 32 bits of the 6-byte first MAC address.
                A31_0: u32,
            }),
            reserved2816: [2040]u8,
            /// Time stamp control register
            MAC_TIMESTAMP_CTRL: mmio.Mmio(packed struct(u32) {
                /// Enable Timestamp When this bit is set, the timestamp is added for Transmit and Receive packets.
                TSENA: u1,
                /// Fine or Coarse Timestamp Update When this bit is set, the Fine method is used to update system timestamp.
                TSCFUPDT: u1,
                /// Initialize Timestamp When this bit is set, the system time is initialized (overwritten) with the value specified in the MAC Register 80 (System Time Seconds Update.
                TSINIT: u1,
                /// Update Timestamp When this bit is set, the system time is updated (added or subtracted) with the value specified in MAC System Time Seconds Update Table 753 and MAC System Time Nanoseconds Update Table 754.
                TSUPDT: u1,
                /// Enable Timestamp Interrupt Trigger When this bit is set, the timestamp interrupt is generated when the System Time becomes greater than the value written in the Target Time register.
                TSTRIG: u1,
                /// Update Addend Register When this bit is set, the content of the Timestamp Addend register is updated in the PTP block for fine correction.
                TADDREG: u1,
                reserved8: u2,
                /// Enable Timestamp for All Packets When this bit is set, the timestamp snapshot is enabled for all packets received by the MAC.
                TSENALL: u1,
                /// Timestamp Digital or Binary Rollover Control When this bit is set, the Timestamp Low register rolls over after 0x3B9AC9FF value (that is, 1 nanosecond accuracy) and increments the timestamp (High) seconds.
                TSCTRLSSR: u1,
                /// Enable PTP Packet Processing for Version 2 Format When this bit is set, the IEEE 1588 version 2 format is used to process the PTP packets.
                TSVER2ENA: u1,
                /// Enable Processing of PTP over Ethernet Packets When this bit is set, the MAC receiver processes the PTP packets encapsulated directly in the Ethernet packets.
                TSIPENA: u1,
                /// Enable Processing of PTP Packets Sent over 1Pv6-UDP When this bit is set, the MAC receiver processes the PTP packets encapsulated in IPv6-UDP packets.
                TSIPV6ENA: u1,
                /// Enable Processing of PTP Packets Sent over IPv4-UDP When this bit is set, the MAC receiver processes the PTP packets encapsulated in IPv4-UDP packets.
                TSIPV4ENA: u1,
                /// Enable Timestamp Snapshot for Event Messages When this bit is set, the timestamp snapshot is taken only for event messages (SYNC, Delay_Req, Pdelay_Req, or Pdelay_Resp).
                TSEVTENA: u1,
                /// Enable Snapshot for Messages Relevant to Master When this bit is set, the snapshot is taken only for the messages that are relevant to the master node.
                TSMSTRENA: u1,
                /// Select PTP packets for Taking Snapshots These bits, along with Bits 15 and 14, decide the set of PTP packet types for which snapshot needs to be taken.
                SNAPTYPSEL: u2,
                /// Enable MAC Address for PTP Packet Filtering When this bit is set, the DA MAC address (that matches any MAC Address register) is used to filter the PTP packets when PTP is directly sent over Ethernet.
                TSENMACADDR: u1,
                reserved24: u5,
                /// Transmit Timestamp Status Mode When this bit is set, the MAC overwrites the earlier transmit timestamp status even if it is not read by the software.
                TXTTSSTSM: u1,
                reserved28: u3,
                /// AV 802.
                AV8021ASMEN: u1,
                padding: u3,
            }),
            /// Sub-second increment register
            MAC_SUB_SCND_INCR: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                /// Sub-second increment value.
                SSINC: u8,
                padding: u8,
            }),
            /// System time seconds register
            MAC_SYS_TIME_SCND: mmio.Mmio(packed struct(u32) {
                /// Time stamp second The value in this field indicates the current value in seconds of the System Time maintained by the MAC.
                TSS: u32,
            }),
            /// System time nanoseconds register
            MAC_SYS_TIME_NSCND: mmio.Mmio(packed struct(u32) {
                /// Time stamp sub seconds The value in this field has the sub second representation of time, with an accuracy of 0.
                TSSS: u31,
                padding: u1,
            }),
            /// no description available
            MAC_SYS_TIME_SCND_UPD: mmio.Mmio(packed struct(u32) {
                /// Time stamp second The value in this field indicates the time, in seconds, to be initialized or added to the system time.
                TSS: u32,
            }),
            /// no description available
            MAC_SYS_TIME_NSCND_UPD: mmio.Mmio(packed struct(u32) {
                /// Time stamp sub seconds The value in this field has the sub second representation of time, with an accuracy of 0.
                TSSS: u31,
                /// Add or subtract time When this bit is set, the time value is subtracted with the contents of the update register.
                ADDSUB: u1,
            }),
            /// Time stamp addend register
            MAC_SYS_TIMESTMP_ADDEND: mmio.Mmio(packed struct(u32) {
                /// Time stamp addend This register indicates the 32-bit time value to be added to the Accumulator register to achieve time synchronization.
                TSAR: u32,
            }),
            /// no description available
            MAC_SYS_TIME_HWORD_SCND: mmio.Mmio(packed struct(u32) {
                /// Time stamp higher word Contains the most significant 16-bits of the Time stamp seconds value.
                TSHWR: u16,
                padding: u16,
            }),
            /// Time stamp status register
            MAC_SYS_TIMESTMP_STAT: mmio.Mmio(packed struct(u32) {
                /// Time stamp seconds overflow When set, indicates that the seconds value of the Time stamp has overflowed beyond 0xFFFF_FFFF.
                TSSOVF: u1,
                padding: u31,
            }),
            reserved2864: [12]u8,
            /// Tx timestamp status nanoseconds
            MAC_Tx_TIMESTAMP_STATUS_NANOSECONDS: mmio.Mmio(packed struct(u32) {
                /// Transmit timestamp status low.
                TXTSSTSLO: u31,
                /// Transmit timestamp status missed.
                TXTSSTSMIS: u1,
            }),
            /// Tx timestamp status seconds
            MAC_Tx_TIMESTAMP_STATUS_SECONDS: mmio.Mmio(packed struct(u32) {
                /// Transmit timestamp status high.
                TXTSSTSHI: u32,
            }),
            reserved2904: [32]u8,
            /// Timestamp ingress correction
            MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND: mmio.Mmio(packed struct(u32) {
                /// Transmit ingress correction.
                TSIC: u32,
            }),
            /// Timestamp egress correction
            MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND: mmio.Mmio(packed struct(u32) {
                /// Transmit egress correction.
                TSEC: u32,
            }),
            reserved3072: [160]u8,
            /// MTL Operation Mode Register
            MTL_OP_MODE: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// Drop Transmit Status When this bit is set, the Tx packet status received from the MAC is dropped in the MTL.
                DTXSTS: u1,
                /// Receive Arbitration Algorithm This field is used to select the arbitration algorithm for the Rx side.
                RAA: u1,
                reserved5: u2,
                /// Tx Scheduling Algorithm This field indicates the algorithm for Tx scheduling: 0x00: WRR algorithm 0x1: Reserved 0x2: Reserved 0x3: Strict priority algorithm.
                SCHALG: u2,
                reserved8: u1,
                /// Counters Preset When this bit is set, MTL TxQ0 Underflow register (Table 762) and MTL_TxQ1_Underflow (Table 762) registers are initialized/preset to 0x7F0.
                CNTPRST: u1,
                /// Counters Reset When this bit is set, all counters are reset.
                CNTCLR: u1,
                padding: u22,
            }),
            reserved3104: [28]u8,
            /// MTL Interrupt Status register
            MTL_INTR_STAT: mmio.Mmio(packed struct(u32) {
                /// Queue 0 Interrupt status This bit indicates that there is an interrupt from Queue 0.
                Q0IS: u1,
                /// Queue 1 Interrupt status This bit indicates that there is an interrupt from Queue 1.
                Q1IS: u1,
                padding: u30,
            }),
            reserved3120: [12]u8,
            /// MTL Receive Queue and DMA Channel Mapping register
            MTL_RXQ_DMA_MAP: mmio.Mmio(packed struct(u32) {
                /// Queue 0 Mapped to DMA Channel This field controls the routing of the packet received in Queue 0 to the DMA channel: 0: DMA Channel 0 1: DMA Channel 1 This field is valid when the Q0DDMACH field is reset.
                Q0MDMACH: u1,
                reserved4: u3,
                /// Queue 0 Enabled for DA-based DMA Channel Selection When set, this bit indicates that the packets received in Queue 0 are routed to a particular DMA channel as decided in the MAC Receiver based on the DMA channel number programmed in the L3-L4 filter registers, or the Ethernet DA address.
                Q0DDMACH: u1,
                reserved8: u3,
                /// Queue 1 Mapped to DMA Channel This field controls the routing of the received packet in Queue 1 to the DMA channel: 0: DMA Channel 0 1: DMA Channel 1 This field is valid when the Q1DDMACH field is reset.
                Q1MDMACH: u1,
                reserved12: u3,
                /// Queue 1 Enabled for DA-based DMA Channel Selection When set, this bit indicates that the packets received in Queue 1 are routed to a particular DMA channel as decided in the MAC Receiver based on the DMA channel number programmed in the L3-L4 filter registers, or the Ethernet DA address.
                Q1DDMACH: u1,
                padding: u19,
            }),
            reserved4096: [972]u8,
            /// DMA mode register
            DMA_MODE: mmio.Mmio(packed struct(u32) {
                /// Software Reset When this bit is set, the MAC and the OMA controller reset the logic and all internal registers of the OMA, MTL, and MAC.
                SWR: u1,
                /// DMA Tx or Rx Arbitration Scheme This bit specifies the arbitration scheme between the Transmit and Receive paths of all channels: The Tx path has priority over the Rx path when the TXPR bit is set.
                DA: u1,
                /// Transmit Arbitration Algorithm This field is used to select the arbitration algorithm for the Transmit side when multiple Tx DMAs are selected.
                TAA: u3,
                reserved11: u6,
                /// Transmit Priority When set, this bit indicates that the Tx DMA has higher priority than the Rx DMA during arbitration for the system-side bus.
                TXPR: u1,
                /// Priority Ratio These bits control the priority ratio in weighted round-robin arbitration between the Rx DMA and Tx DMA.
                PR: u3,
                padding: u17,
            }),
            /// DMA System Bus mode
            DMA_SYSBUS_MODE: mmio.Mmio(packed struct(u32) {
                /// Fixed Burst Length When this bit is set to 1, the AHB master will initiate burst transfers of specified length (INCRx or SINGLE).
                FB: u1,
                reserved12: u11,
                /// Address-Aligned Beats When this bit is set to 1, the AHB master performs address-aligned burst transfers on Read and Write channels.
                AAL: u1,
                reserved14: u1,
                /// Mixed Burst When this bit is set high and the FB bit is low, the AHB master performs undefined bursts transfers (INCR) for burst length of 16 or more.
                MB: u1,
                /// Rebuild INCRx Burst When this bit is set high and the AHB master gets SPLIT, RETRY, or EarlyBurst Termination (EBT) response, the AHB master interface rebuilds the pending beats of any initiated burst transfer with INCRx and SINGLEtransfers.
                RB: u1,
                padding: u16,
            }),
            /// DMA Interrupt status
            DMA_INTR_STAT: mmio.Mmio(packed struct(u32) {
                /// DMA Channel 0 Interrupt Status This bit indicates an interrupt event in DMA Channel 0.
                DC0IS: u1,
                /// DMA Channel 1 Interrupt Status This bit indicates an interrupt event in DMA Channel 1.
                DC1IS: u1,
                reserved16: u14,
                /// MTL Interrupt Status This bit indicates an interrupt event in the MTL.
                MTLIS: u1,
                /// MAC Interrupt Status This bit indicates an interrupt event in the MAC.
                MACIS: u1,
                padding: u14,
            }),
            /// DMA Debug Status
            DMA_DBG_STAT: mmio.Mmio(packed struct(u32) {
                /// AHB Master Status When high, this bit indicates that the AHB master FSMs are in the non-idle state.
                AHSTS: u1,
                reserved8: u7,
                /// DMA Channel 0 Receive Process State This field indicates the Rx DMA FSM state for Channel 0: 0x0: Stopped (Reset or Stop Receive Command issued) 0x1: Running (Fetching Rx Transfer ) 0x2: Reserved 0x3: Running (Waiting for Rx packet) 0x4: Suspended (Rx Unavailable) 0x5: Running (Closing the Rx) 0x6: Timestamp write state 0x7: Running (Transferring the received packet data from the Rx buffer to the system memory) This field does not generate an interrupt.
                RPS0: u4,
                /// DMA Channel 0 Transmit Process State This field indicates the Tx DMA FSM state for Channel 0: 000: Stopped (Reset or Stop Transmit Command issued) 0x1: Running (Fetching Tx Transfer) 0x2: Running (Waiting for status) 0x3: Running (Reading Data from system memory buffer and queuing it to the Tx buffer (Tx FIFO)) 0x4: Timestamp write state 0x5: Reserved for future use 0x6: Suspended (Tx Unavailable or Tx Buffer Underflow) 0x7: Running (Closing Tx ) This field does not generate an interrupt.
                TPS0: u4,
                /// DMA Channel 1 Receive Process State This field indicates the Rx DMA FSM state for Channel 1.
                RPS1: u4,
                /// DMA Channel 1 Transmit Process State This field indicates the Tx DMA FSM state for Channel 1.
                TPS1: u4,
                padding: u8,
            }),
        };

        /// Embedded Trace Macrocell Registers
        pub const ETM = extern struct {
            /// Main Control Register
            CR: mmio.Mmio(packed struct(u32) {
                /// ETM power down. This bit can be used by an implementation to control if the ETM is in a low power state. This bit must be cleared by the trace software tools at the beginning of a debug session. When this bit is set to 1, writes to some registers and fields might be ignored.
                ETMPD: u1,
                reserved4: u3,
                /// Port size. The ETM-M4 has no influence over the external pins used for trace. These bits are implemented but not used. On an ETM reset these bits reset to 0b001.
                PS: u3,
                /// Stall processor. The FIFOFULL output can be used to stall the processor to prevent overflow. The FIFOFULL output is only enabled when the stall processor bit is set to 1. When the bit is 0 the FIFOFULL output remains LOW at all times and the FIFO overflows if there are too many trace packets. Trace resumes without corruption once the FIFO has drained, if overflow does occur. An ETM reset sets this bit to 0.
                SP: u1,
                /// Branch output. When set to 1 all branch addresses are output, even if the branch was because of a direct branch instruction. Setting this bit enables reconstruction of the program flow without having access to the memory image of the code being executed. When this bit is set to 1, more trace data is generated, and this may affect the performance of the trace system. Information about the execution of a branch is traced regardless of the state of this bit. An ETM reset sets this bit to 0.
                BO: u1,
                /// Debug request control. When set to 1 and the trigger event occurs, the DBGRQ output is asserted until DBGACK is observed. This enables the ARM processor to be forced into Debug state. An ETM reset sets this bit to 0.
                DRC: u1,
                /// ETM programming. This bit must be set to 1 at the start of the ETM programming sequence. Tracing is prevented while this bit is set to 1. On an ETM reset this bit is set to b1.
                ETMP: u1,
                /// ETM port selection. This bit can be used to control other trace components in an implementation. This bit must be set by the trace software tools to ensure that trace output is enabled from this ETM. An ETM reset sets this bit to 0.
                ETMPS: enum(u1) {
                    /// ETMEN is LOW.
                    ETMPS_0 = 0x0,
                    /// ETMEN is HIGH.
                    ETMPS_1 = 0x1,
                },
                reserved13: u1,
                /// This bit is implemented but has no function. An ETM reset sets this bit to 0.
                PM2: u1,
                reserved16: u2,
                /// These bits are implemented but have no function. An ETM reset sets these bits to 0.
                PM: u2,
                reserved21: u3,
                /// This bit is implemented but has no function. An ETM reset sets this bit to 0.
                PS3: u1,
                reserved28: u6,
                /// When set, this bit enables timestamping. An ETM reset sets this bit to 0.
                TE: u1,
                padding: u3,
            }),
            /// Configuration Code Register
            CCR: mmio.Mmio(packed struct(u32) {
                /// Number of address comparator pairs. The value of these bits is b0000, indicating that address comparator pairs are not implemented.
                NumberOfAddressComparatorPairs: u4,
                /// Number of data value comparators. The value of these bits is b0000, indicating that data value comparators are not implemented.
                NDVC: u4,
                /// Number of memory map decoders. The value of these bits is b00000, indicating that memory map decoder inputs are not implemented.
                NMMD: u5,
                /// Number of counters. The value of these bits is b001, indicating that one counter is implemented.
                NC: u3,
                /// Sequencer present. The value of this bit is 0, indicating that the sequencer is not implemented.
                SP: u1,
                /// Number of external inputs. The value of these bits is between b000 and b010, indicating the number of external inputs, from 0 to 2, implemented in the system.
                NEI: u3,
                /// Number of external outputs. The value of these bits is b000, indicating that no external outputs are supported.
                NEO: u3,
                /// FIFOFULL logic present. The value of this bit is 1, indicating that FIFOFULL logic is present in the ETM. To use FIFOFULL the system must also support the function, as indicated by bit [8] of ETMSCR.
                FFLP: u1,
                /// Number of Context ID comparators. The value of these bits is b00, indicating that Context ID comparators are not implemented.
                NCIDC: u2,
                /// Trace start/stop block present. The value of this bit is 1, indicating that the Trace start/stop block is present.
                TSSBP: u1,
                /// Coprocessor and memory access. The value of this bit is 1, indicating that memory-mapped access to registers is supported.
                CMA: u1,
                reserved31: u3,
                /// The value of this bit is 1, indicating that the ETMIDR, register 0x79, is present and defines the ETM architecture version in use.
                ETMIDRP: u1,
            }),
            /// Trigger Event Register
            TRIGGER: mmio.Mmio(packed struct(u32) {
                /// Trigger event
                TriggerEvent: u17,
                padding: u15,
            }),
            reserved16: [4]u8,
            /// ETM Status Register
            SR: mmio.Mmio(packed struct(u32) {
                /// Untraced overflow flag. If set to 1, there is an overflow that has not yet been traced. This bit is cleared to 0 when either: - trace is restarted - the ETM Power Down bit, bit [0] of the ETM Control Register, 0x00, is set to 1. Note: Setting or clearing the ETM programming bit does not cause this bit to be cleared to 0.
                UOF: u1,
                /// ETM programming bit value (Progbit). The current effective value of the ETM Programming bit (ETM Control Register bit [10]). Tou must wait for this bit to go to 1 before you start to program the ETM.
                Progbit: u1,
                /// Holds the current status of the trace start/stop resource. If set to 1, it indicates that a trace on address has been matched, without a corresponding trace off address match.
                Status: u1,
                /// Trigger bit. Set when the trigger occurs, and prevents the trigger from being output until the ETM is next programmed.
                Trigger: u1,
                padding: u28,
            }),
            /// System Configuration Register
            SCR: mmio.Mmio(packed struct(u32) {
                /// Maximum ETM port size bits [2:0]. These bits are used in conjunction with bit [9]. The value of these bits is b001.
                MaximumPortSize: u3,
                reserved8: u5,
                /// FIFOFULL supported. The value of this bit is 1, indicating that FIFOFULL is supported. This bit is used in conjunction with bit [23] of the ETMCCR.
                FIFOFULLsupported: u1,
                /// Maximum ETM port size bit [3]. This bit is used in conjunction with bits [2:0]. Its value is 0. This has no effect on the TPIU trace port.
                MaximumPortSize3: u1,
                /// Port size supported. This bit reads as 1 if the currently selected port size is supported. This has no effect on the TPIU trace port.
                PortSizeSupported: u1,
                /// Port mode supported. This bit reads as 1 if the currently selected port mode is supported. This has no effect on the TPIU trace port.
                PortModeSupported: u1,
                /// These bits give the number of supported processors minus 1. The value of these bits is b000, indicating that there is only one processor connected.
                N: u3,
                reserved17: u2,
                /// No Fetch comparisons. The value of this bit is 1, indicating that fetch comparisons are not implemented.
                NoFetchComparisons: u1,
                padding: u14,
            }),
            reserved32: [8]u8,
            /// Trace Enable Event Register
            EEVR: mmio.Mmio(packed struct(u32) {
                /// Trace Enable event.
                TraceEnableEvent: u17,
                padding: u15,
            }),
            /// Trace Enable Control 1 Register
            TECR1: mmio.Mmio(packed struct(u32) {
                reserved25: u25,
                /// Trace start/stop enable. The trace start/stop resource, resource 0x5F, is unaffected by the value of this bit.
                TraceControlEnable: enum(u1) {
                    /// Tracing is unaffected by the trace start/stop logic.
                    TraceControlEnable_0 = 0x0,
                    /// Tracing is controlled by the trace on and off addresses configured for the trace start/stop logic.
                    TraceControlEnable_1 = 0x1,
                },
                padding: u6,
            }),
            /// FIFOFULL Level Register
            FFLR: mmio.Mmio(packed struct(u32) {
                /// FIFO full level. The number of bytes left in FIFO, below which the FIFOFULL or SupressData signal is asserted. For example, setting this value to 15 causes data trace suppression or processor stalling, if enabled, when there are less than 15 free bytes in the FIFO.
                FIFOFullLevel: u8,
                padding: u24,
            }),
            reserved320: [276]u8,
            /// Free-running counter reload value
            CNTRLDVR1: mmio.Mmio(packed struct(u32) {
                /// Initial count.
                IntitialCount: u16,
                padding: u16,
            }),
            reserved480: [156]u8,
            /// Synchronization Frequency Register
            SYNCFR: mmio.Mmio(packed struct(u32) {
                /// Synchronization frequency. Default value is 1024.
                SyncFrequency: u12,
                padding: u20,
            }),
            /// ID Register
            IDR: mmio.Mmio(packed struct(u32) {
                /// Implementation revision. The value of these bits is b0000, indicating implementation revision, 0.
                ImplementationRevision: u4,
                /// Minor ETM architecture version. The value of these bits is 0b0101, indicating minor architecture version number 5.
                MinorETMarchitectureVersion: u4,
                /// Major ETM architecture version. The value of these bits is 0b0010, indicating major architecture version number 3, ETMv3.
                MajorETMarchitectureVersion: u4,
                /// Processor family. The value of these bits is 0b1111, indicating that the processor family is not identified in this register.
                ProcessorFamily: u4,
                /// Load PC first. The value of this bit is 0, indicating that data tracing is not supported.
                LoadPCfirst: u1,
                reserved18: u1,
                /// 32-bit Thumb instruction tracing. The value of this bit is 1, indicating that a 32-bit Thumb instruction is traced as a single instruction.
                ThumbInstructionTracing: enum(u1) {
                    /// A 32-bit Thumb instruction is traced as two instructions, and exceptions might occur between these two instructions.
                    ThumbInstructionTracing_0 = 0x0,
                    /// A 32-bit Thimb instruction is traced as a single instruction.
                    ThumbInstructionTracing_1 = 0x1,
                },
                /// Security Extensions support. The value of this bit is 0, indicating that the ETM behaves as if the processor is in Secure state at all times.
                SecurityExtensionSupport: enum(u1) {
                    /// The ETM behaves as if the processor is in Secure state at all times.
                    SecurityExtensionSupport_0 = 0x0,
                    /// The ARM architecture Security Extensions are implemented by the processor.
                    SecurityExtensionSupport_1 = 0x1,
                },
                /// Branch packet encoding. The value of this bit is 1, indicating that alternative branch packet encoding is implemented.
                BranchPacketEncoding: enum(u1) {
                    /// The ETM implements the original branch packet encoding.
                    BranchPacketEncoding_0 = 0x0,
                    /// The ETM implements the alternative branch packet encoding.
                    BranchPacketEncoding_1 = 0x1,
                },
                reserved24: u3,
                /// Implementor code. These bits identify ARM as the implementor of the processor. The value of these bits is 01000001.
                ImplementorCode: u8,
            }),
            /// Configuration Code Extension Register
            CCER: mmio.Mmio(packed struct(u32) {
                /// Extended external input selectors. The value of these bits is 0, indicating that extended external input selectors are not implemented.
                ExtendedExternalInputSelectors: u3,
                /// Extended external input bus. The value of these bits is 0, indicating that the extended external input bus is not implemented.
                ExtendedExternalInputBus: u8,
                /// Readable registers. The value of this bit is 1, indicating that all registers are readable.
                ReadableRegisters: u1,
                /// Data address comparisons. The value of this bit is 1, indicating that data address comparisons are not supported.
                DataAddressComparisons: u1,
                /// Instrumentation resources. The value of these bits is 0b000, indicating that no Instrumentation resources are supported.
                InstrumentationResources: u3,
                /// EmbeddedICE watchpoint inputs. The value of these bits is 0b0100, indicating that the number of EmbeddedICE watchpoint inputs implemented is four. These inputs come from the DWT.
                EmbeddedICEwatchpointInputs: u4,
                /// Trace Start/Stop block uses EmbeddedICE watchpoint inputs. The value of this bit is 1, indicating that the Trace Start/Stop block uses the EmbeddedICE watchpoint inputs.
                TraceStartStopBlockUsesEmbeddedICEwatchpointInputs: u1,
                /// EmbeddedICE behavior control implemented. The value of this bit is 0, indicating that the ETMEIBCR is not implemented.
                EmbeddedICEbehaviorControlImplemented: u1,
                /// Timestamping implemented. This bit is set to 1, indicating that timestamping is implemented.
                TimestampingImplemented: u1,
                reserved27: u4,
                /// Reduced function counter. Set to 1 to indicate that Counter 1 is a reduced function counter.
                ReducedFunctionCounter: u1,
                /// Timestamp encoding. Set to 1 to indicate that the timestamp is encoded as a natural binary number.
                TimestampEncoding: u1,
                /// Timestamp size. Set to 0 to indicate a size of 48 bits.
                TimestampSize: u1,
                padding: u2,
            }),
            reserved496: [4]u8,
            /// TraceEnable Start/Stop EmbeddedICE Control Register
            TESSEICR: mmio.Mmio(packed struct(u32) {
                /// Start resource selection. Setting any of these bits to 1 selects the corresponding EmbeddedICE watchpoint input as a TraceEnable start resource. Bit [0] corresponds to input 1, bit [1] corresponds to input 2, bit [2] corresponds to input 3, and bit [3] corresponds to input 4.
                StartResourceSelection: u4,
                reserved16: u12,
                /// Stop resource selection. Setting any of these bits to 1 selects the corresponding EmbeddedICE watchpoint input as a TraceEnable stop resource. Bit [16] corresponds to input 1, bit [17] corresponds to input 2, bit [18] corresponds to input 3, and bit [19] corresponds to input 4.
                StopResourceSelection: u4,
                padding: u12,
            }),
            reserved504: [4]u8,
            /// Timestamp Event Register
            TSEVR: mmio.Mmio(packed struct(u32) {
                /// Timestamp event.
                TimestampEvent: u12,
                padding: u20,
            }),
            reserved512: [4]u8,
            /// CoreSight Trace ID Register
            TRACEIDR: mmio.Mmio(packed struct(u32) {
                /// Trace ID to output onto the trace bus. On an ETM reset this field is cleared to 0x00.
                TraceID: u7,
                padding: u25,
            }),
            reserved520: [4]u8,
            /// ETM ID Register 2
            IDR2: u32,
            reserved788: [264]u8,
            /// Device Power-Down Status Register
            PDSR: mmio.Mmio(packed struct(u32) {
                /// The value of this bit indicates whether you can access the ETM Trace Registers. The value of this bit is always 1, indicating that the ETM Trace Registers can be accessed.
                ETMpoweredup: u1,
                padding: u31,
            }),
            reserved3808: [3016]u8,
            /// Integration Test Miscelaneous Inputs Register
            _ITMISCIN: mmio.Mmio(packed struct(u32) {
                /// A read of these bits returns the value of the EXTIN[1:0] input pins.
                EXTIN: u2,
                reserved4: u2,
                /// A read of this bit returns the value of the COREHALT input pin.
                COREHALT: u1,
                padding: u27,
            }),
            reserved3816: [4]u8,
            /// Integration Test Trigger Out Register
            _ITTRIGOUT: mmio.Mmio(packed struct(u32) {
                /// A write to this bit sets the TRIGGER output.
                TRIGGER: u1,
                padding: u31,
            }),
            reserved3824: [4]u8,
            /// ETM Integration Test ATB Control 2 Register
            _ITATBCTR2: mmio.Mmio(packed struct(u32) {
                /// A read of this bit returns the value of the ETM ATREADY input.
                ATREADY: u1,
                padding: u31,
            }),
            reserved3832: [4]u8,
            /// ETM Integration Test ATB Control 0 Register
            _ITATBCTR0: mmio.Mmio(packed struct(u32) {
                /// A write to this bit sets the value of the ETM ATVALID output.
                ATVALID: u1,
                padding: u31,
            }),
            reserved3840: [4]u8,
            /// Integration Mode Control Register
            ITCTRL: mmio.Mmio(packed struct(u32) {
                /// Enable integration mode. When this bit is set to 1, the device enters integration mode to enable Topology Detection or Integration Testing to be checked. On an ETM reset this bit is cleared to 0.
                Mode: u1,
                padding: u31,
            }),
            reserved4000: [156]u8,
            /// Claim Tag Set Register
            CLAIMSET: mmio.Mmio(packed struct(u32) {
                /// A bit programmable register bank which sets the Claim Tag Value. Write 1 to set the bit in the claim tag. A read will return a logic 1 for all implemented locations.
                CLAIMSET: u4,
                padding: u28,
            }),
            /// Claim Tag Clear Register
            CLAIMCLR: mmio.Mmio(packed struct(u32) {
                /// A bit programmable register bank that is zero at reset. Write 1 to clear the bit in the claim tag. On reads, returns the current setting of the claim tag.
                CLAIMCLR: u4,
                padding: u28,
            }),
            reserved4016: [8]u8,
            /// Lock Access Register
            LAR: mmio.Mmio(packed struct(u32) {
                /// Write Access Code. A write of 0xC5ACCE55 enables further write access to this device. An invalid write will have the affect of removing write access.
                WriteAccessCode: u32,
            }),
            /// Lock Status Register
            LSR: mmio.Mmio(packed struct(u32) {
                /// Lock mechanism is implemented. This bit always reads 1.
                IMP: u1,
                /// Lock Status. This bit is HIGH when the device is locked, and LOW when unlocked.
                STATUS: enum(u1) {
                    /// Access permitted.
                    STATUS_0 = 0x0,
                    /// Write access to the component is blocked. All writes to control registers are ignored. Reads are permitted.
                    STATUS_1 = 0x1,
                },
                /// Access Lock Register size. This bit reads 0 to indicate a 32-bit register is present.
                s8BIT: u1,
                padding: u29,
            }),
            /// Authentication Status Register
            AUTHSTATUS: mmio.Mmio(packed struct(u32) {
                /// Reads as b00, Non-secure invasive debug not supported by the ETM.
                NSID: u2,
                /// Permission for Non-secure non-invasive debug.
                NSNID: enum(u2) {
                    /// Non-secure non-invasive debug disabled
                    NSNID_2 = 0x2,
                    /// Non-secure non-invasive debug enabled
                    NSNID_3 = 0x3,
                    _,
                },
                /// Reads as b00, Secure invasive debug not supported by the ETM.
                SID: u2,
                /// Permission for Secure non-invasive debug.
                SNID: u2,
                padding: u24,
            }),
            reserved4044: [16]u8,
            /// CoreSight Device Type Register
            DEVTYPE: mmio.Mmio(packed struct(u32) {
                /// Major Type and Class
                MajorType: enum(u4) {
                    /// Trace source
                    MajorType_3 = 0x3,
                    _,
                },
                /// Sub Type
                SubType: enum(u4) {
                    /// Processor trace
                    SubType_1 = 0x1,
                    _,
                },
                padding: u24,
            }),
            /// Peripheral Identification Register 4
            PIDR4: mmio.Mmio(packed struct(u32) {
                /// JEP106 continuation code.
                JEP106: u4,
                /// 4KB Count
                c4KB: u4,
                padding: u24,
            }),
            /// Peripheral Identification Register 5
            PIDR5: u32,
            /// Peripheral Identification Register 6
            PIDR6: u32,
            /// Peripheral Identification Register 7
            PIDR7: u32,
            /// Peripheral Identification Register 0
            PIDR0: mmio.Mmio(packed struct(u32) {
                /// Part Number [7:0]
                PartNumber: u8,
                padding: u24,
            }),
            /// Peripheral Identification Register 1
            PIDR1: mmio.Mmio(packed struct(u32) {
                /// Part Number [11:8]
                PartNumber: u4,
                /// JEP106 identity code [3:0]
                JEP106_identity_code: u4,
                padding: u24,
            }),
            /// Peripheral Identification Register 2
            PIDR2: mmio.Mmio(packed struct(u32) {
                /// JEP106 identity code [6:4]
                JEP106_identity_code: u3,
                reserved4: u1,
                /// Revision
                Revision: u4,
                padding: u24,
            }),
            /// Peripheral Identification Register 3
            PIDR3: mmio.Mmio(packed struct(u32) {
                /// Customer Modified.
                CustomerModified: u4,
                /// RevAnd
                RevAnd: u4,
                padding: u24,
            }),
            /// Component Identification Register 0
            CIDR0: mmio.Mmio(packed struct(u32) {
                /// Preamble
                Preamble: u8,
                padding: u24,
            }),
            /// Component Identification Register 1
            CIDR1: mmio.Mmio(packed struct(u32) {
                /// Preamble
                Preamble: u4,
                /// Component class
                ComponentClass: enum(u4) {
                    /// ROM table.
                    ComponentClass_1 = 0x1,
                    /// CoreSight component.
                    ComponentClass_9 = 0x9,
                    /// PrimeCell of system component with no standardized register layout, for backward compatibility.
                    ComponentClass_15 = 0xf,
                    _,
                },
                padding: u24,
            }),
            /// Component Identification Register 2
            CIDR2: mmio.Mmio(packed struct(u32) {
                /// Preamble
                Preamble: u8,
                padding: u24,
            }),
            /// Component Identification Register 3
            CIDR3: mmio.Mmio(packed struct(u32) {
                /// Preamble
                Preamble: u8,
                padding: u24,
            }),
        };
        /// LPC5411x Flexcomm serial communication
        pub const FLEXCOMM0 = extern struct 
            reserved4088: [4088]u8,
            /// Peripheral Select and Flexcomm ID register.
            PSELID: mmio.Mmio(packed struct(u32) {
                /// Peripheral Select. This field is writable by software.
                PERSEL: enum(u3) {
                    /// No peripheral selected.
                    NO_PERIPH_SELECTED = 0x0,
                    /// USART function selected.
                    USART = 0x1,
                    /// SPI function selected.
                    SPI = 0x2,
                    /// I2C function selected.
                    I2C = 0x3,
                    /// I2S transmit function selected.
                    I2S_TRANSMIT = 0x4,
                    /// I2S receive function selected.
                    I2S_RECEIVE = 0x5,
                    _,
                },
                /// Lock the peripheral select. This field is writable by software.
                LOCK: enum(u1) {
                    /// Peripheral select can be changed by software.
                    UNLOCKED = 0x0,
                    /// Peripheral select is locked and cannot be changed until this Flexcomm or the entire device is reset.
                    LOCKED = 0x1,
                },
                /// USART present indicator. This field is Read-only.
                USARTPRESENT: enum(u1) {
                    /// This Flexcomm does not include the USART function.
                    NOT_PRESENT = 0x0,
                    /// This Flexcomm includes the USART function.
                    PRESENT = 0x1,
                },
                /// SPI present indicator. This field is Read-only.
                SPIPRESENT: enum(u1) {
                    /// This Flexcomm does not include the SPI function.
                    NOT_PRESENT = 0x0,
                    /// This Flexcomm includes the SPI function.
                    PRESENT = 0x1,
                },
                /// I2C present indicator. This field is Read-only.
                I2CPRESENT: enum(u1) {
                    /// This Flexcomm does not include the I2C function.
                    NOT_PRESENT = 0x0,
                    /// This Flexcomm includes the I2C function.
                    PRESENT = 0x1,
                },
                /// I 2S present indicator. This field is Read-only.
                I2SPRESENT: enum(u1) {
                    /// This Flexcomm does not include the I2S function.
                    NOT_PRESENT = 0x0,
                    /// This Flexcomm includes the I2S function.
                    PRESENT = 0x1,
                },
                reserved12: u4,
                /// Flexcomm ID.
                ID: u20,
            }),
            /// Peripheral identification register.
            PID: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                /// Minor revision of module implementation.
                Minor_Rev: u4,
                /// Major revision of module implementation.
                Major_Rev: u4,
                /// Module identifier for the selected function.
                ID: u16,
            }),
        };

        /// LPC5460x Flash signature generator
        pub const FMC = extern struct {
            /// Control register
            FCTR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// Value must be 0 for signature generation.
                FS_RD0: u1,
                /// Value must be 1 for signature generation.
                FS_RD1: u1,
                padding: u27,
            }),
            reserved16: [12]u8,
            /// Wait state register
            FBWST: mmio.Mmio(packed struct(u32) {
                /// Wait states for signature generation.
                WAITSTATES: u8,
                padding: u24,
            }),
            reserved32: [12]u8,
            /// Signature start address register
            FMSSTART: mmio.Mmio(packed struct(u32) {
                /// Signature generation start address (corresponds to AHB byte address bits[20:4]).
                START: u17,
                padding: u15,
            }),
            /// Signature stop-address register
            FMSSTOP: mmio.Mmio(packed struct(u32) {
                /// Stop address for signature generation (the word specified by STOP is included in the address range).
                STOP: u17,
                /// When this bit is written to 1, signature generation starts.
                SIG_START: u1,
                padding: u14,
            }),
            reserved44: [4]u8,
            /// Words of 128-bit signature word
            FMSW: [4]mmio.Mmio(packed struct(u32) {
                /// Words of 128-bit signature (bits).
                SW: u32,
            }),
            reserved4064: [4004]u8,
            /// Signature generation status register
            FMSTAT: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// When 1, a previously started signature generation has completed.
                SIG_DONE: u1,
                padding: u29,
            }),
            reserved4072: [4]u8,
            /// Signature generation status clear register
            FMSTATCLR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Writing a 1 to this bits clears the signature generation completion flag (SIG_DONE) in the FMSTAT register.
                SIG_DONE_CLR: u1,
                padding: u29,
            }),
        };

        /// LPC5411x Group GPIO input interrupt (GINT0/1)
        pub const GINT0 = extern struct {
            /// GPIO grouped interrupt control register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Group interrupt status. This bit is cleared by writing a one to it. Writing zero has no effect.
                INT: enum(u1) {
                    /// No request. No interrupt request is pending.
                    NO_REQUEST = 0x0,
                    /// Request active. Interrupt request is active.
                    REQUEST_ACTIVE = 0x1,
                },
                /// Combine enabled inputs for group interrupt
                COMB: enum(u1) {
                    /// Or. OR functionality: A grouped interrupt is generated when any one of the enabled inputs is active (based on its programmed polarity).
                    OR = 0x0,
                    /// And. AND functionality: An interrupt is generated when all enabled bits are active (based on their programmed polarity).
                    AND = 0x1,
                },
                /// Group interrupt trigger
                TRIG: enum(u1) {
                    /// Edge-triggered.
                    EDGE_TRIGGERED = 0x0,
                    /// Level-triggered.
                    LEVEL_TRIGGERED = 0x1,
                },
                padding: u29,
            }),
            reserved32: [28]u8,
            /// GPIO grouped interrupt port 0 polarity register
            PORT_POL: [2]mmio.Mmio(packed struct(u32) {
                /// Configure pin polarity of port m pins for group interrupt. Bit n corresponds to pin PIOm_n of port m. 0 = the pin is active LOW. If the level on this pin is LOW, the pin contributes to the group interrupt. 1 = the pin is active HIGH. If the level on this pin is HIGH, the pin contributes to the group interrupt.
                POL: u32,
            }),
            reserved64: [24]u8,
            /// GPIO grouped interrupt port 0 enable register
            PORT_ENA: [2]mmio.Mmio(packed struct(u32) {
                /// Enable port 0 pin for group interrupt. Bit n corresponds to pin Pm_n of port m. 0 = the port 0 pin is disabled and does not contribute to the grouped interrupt. 1 = the port 0 pin is enabled and contributes to the grouped interrupt.
                ENA: u32,
            }),
        };

        /// LPC5411x General Purpose I/O (GPIO)
        pub const GPIO = extern struct {
            reserved8192: [8192]u8,
            /// Direction registers
            DIR: [6]mmio.Mmio(packed struct(u32) {
                /// Selects pin direction for pin PIOm_n (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = input. 1 = output.
                DIRP: u32,
            }),
            reserved8320: [104]u8,
            /// Mask register
            MASK: [6]mmio.Mmio(packed struct(u32) {
                /// Controls which bits corresponding to PIOm_n are active in the MPORT register (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.
                MASKP: u32,
            }),
            reserved8448: [104]u8,
            /// Port pin register
            PIN: [6]mmio.Mmio(packed struct(u32) {
                /// Reads pin states or loads output bits (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.
                PORT: u32,
            }),
            reserved8576: [104]u8,
            /// Masked port register
            MPIN: [6]mmio.Mmio(packed struct(u32) {
                /// Masked port register (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.
                MPORTP: u32,
            }),
            reserved8704: [104]u8,
            /// Write: Set register for port Read: output bits for port
            SET: [6]mmio.Mmio(packed struct(u32) {
                /// Read or set output bits (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.
                SETP: u32,
            }),
            reserved8832: [104]u8,
            /// Clear port
            CLR: [6]mmio.Mmio(packed struct(u32) {
                /// Clear output bits (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = No operation. 1 = Clear output bit.
                CLRP: u32,
            }),
            reserved8960: [104]u8,
            /// Toggle port
            NOT: [6]mmio.Mmio(packed struct(u32) {
                /// Toggle output bits (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = no operation. 1 = Toggle output bit.
                NOTP: u32,
            }),
            reserved9088: [104]u8,
            /// Set pin direction bits for port
            DIRSET: [6]mmio.Mmio(packed struct(u32) {
                /// Set direction bits (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = No operation. 1 = Set direction bit.
                DIRSETP: u29,
                padding: u3,
            }),
            reserved9216: [104]u8,
            /// Clear pin direction bits for port
            DIRCLR: [6]mmio.Mmio(packed struct(u32) {
                /// Clear direction bits (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = No operation. 1 = Clear direction bit.
                DIRCLRP: u29,
                padding: u3,
            }),
            reserved9344: [104]u8,
            /// Toggle pin direction bits for port
            DIRNOT: [6]mmio.Mmio(packed struct(u32) {
                /// Toggle direction bits (bit 0 = PIOn_0, bit 1 = PIOn_1, etc.). Supported pins depends on the specific device and package. 0 = no operation. 1 = Toggle direction bit.
                DIRNOTP: u29,
                padding: u3,
            }),
        };

        /// LPC5411x I2C-bus interfaces
        pub const I2C0 = extern struct {
            reserved2048: [2048]u8,
            /// Configuration for shared functions.
            CFG: mmio.Mmio(packed struct(u32) {
                /// Master Enable. When disabled, configurations settings for the Master function are not changed, but the Master function is internally reset.
                MSTEN: enum(u1) {
                    /// Disabled. The I2C Master function is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The I2C Master function is enabled.
                    ENABLED = 0x1,
                },
                /// Slave Enable. When disabled, configurations settings for the Slave function are not changed, but the Slave function is internally reset.
                SLVEN: enum(u1) {
                    /// Disabled. The I2C slave function is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The I2C slave function is enabled.
                    ENABLED = 0x1,
                },
                /// Monitor Enable. When disabled, configurations settings for the Monitor function are not changed, but the Monitor function is internally reset.
                MONEN: enum(u1) {
                    /// Disabled. The I2C Monitor function is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The I2C Monitor function is enabled.
                    ENABLED = 0x1,
                },
                /// I2C bus Time-out Enable. When disabled, the time-out function is internally reset.
                TIMEOUTEN: enum(u1) {
                    /// Disabled. Time-out function is disabled.
                    DISABLED = 0x0,
                    /// Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one time-out will be used in a system.
                    ENABLED = 0x1,
                },
                /// Monitor function Clock Stretching.
                MONCLKSTR: enum(u1) {
                    /// Disabled. The Monitor function will not perform clock stretching. Software or DMA may not always be able to read data provided by the Monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical.
                    DISABLED = 0x0,
                    /// Enabled. The Monitor function will perform clock stretching in order to ensure that software or DMA can read all incoming data supplied by the Monitor function.
                    ENABLED = 0x1,
                },
                /// High-speed mode Capable enable. Since High Speed mode alters the way I2C pins drive and filter, as well as the timing for certain I2C signalling, enabling High-speed mode applies to all functions: Master, Slave, and Monitor.
                HSCAPABLE: enum(u1) {
                    /// Fast-mode plus. The I 2C interface will support Standard-mode, Fast-mode, and Fast-mode Plus, to the extent that the pin electronics support these modes. Any changes that need to be made to the pin controls, such as changing the drive strength or filtering, must be made by software via the IOCON register associated with each I2C pin,
                    FAST_MODE_PLUS = 0x0,
                    /// High-speed. In addition to Standard-mode, Fast-mode, and Fast-mode Plus, the I 2C interface will support High-speed mode to the extent that the pin electronics support these modes. See Section 25.7.2.2 for more information.
                    HIGH_SPEED = 0x1,
                },
                padding: u26,
            }),
            /// Status register for Master, Slave, and Monitor functions.
            STAT: mmio.Mmio(packed struct(u32) {
                /// Master Pending. Indicates that the Master is waiting to continue communication on the I2C-bus (pending) or is idle. When the master is pending, the MSTSTATE bits indicate what type of software service if any the master expects. This flag will cause an interrupt when set if, enabled via the INTENSET register. The MSTPENDING flag is not set when the DMA is handling an event (if the MSTDMA bit in the MSTCTL register is set). If the master is in the idle state, and no communication is needed, mask this interrupt.
                MSTPENDING: enum(u1) {
                    /// In progress. Communication is in progress and the Master function is busy and cannot currently accept a command.
                    IN_PROGRESS = 0x0,
                    /// Pending. The Master function needs software service or is in the idle state. If the master is not in the idle state, it is waiting to receive or transmit data or the NACK bit.
                    PENDING = 0x1,
                },
                /// Master State code. The master state code reflects the master state when the MSTPENDING bit is set, that is the master is pending or in the idle state. Each value of this field indicates a specific required service for the Master function. All other values are reserved. See Table 400 for details of state values and appropriate responses.
                MSTSTATE: enum(u3) {
                    /// Idle. The Master function is available to be used for a new transaction.
                    IDLE = 0x0,
                    /// Receive ready. Received data available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave.
                    RECEIVE_READY = 0x1,
                    /// Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave.
                    TRANSMIT_READY = 0x2,
                    /// NACK Address. Slave NACKed address.
                    NACK_ADDRESS = 0x3,
                    /// NACK Data. Slave NACKed transmitted data.
                    NACK_DATA = 0x4,
                    _,
                },
                /// Master Arbitration Loss flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE.
                MSTARBLOSS: enum(u1) {
                    /// No Arbitration Loss has occurred.
                    NO_LOSS = 0x0,
                    /// Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle.
                    ARBITRATION_LOSS = 0x1,
                },
                reserved6: u1,
                /// Master Start/Stop Error flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE.
                MSTSTSTPERR: enum(u1) {
                    /// No Start/Stop Error has occurred.
                    NO_ERROR = 0x0,
                    /// The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled.
                    ERROR = 0x1,
                },
                reserved8: u1,
                /// Slave Pending. Indicates that the Slave function is waiting to continue communication on the I2C-bus and needs software service. This flag will cause an interrupt when set if enabled via INTENSET. The SLVPENDING flag is not set when the DMA is handling an event (if the SLVDMA bit in the SLVCTL register is set). The SLVPENDING flag is read-only and is automatically cleared when a 1 is written to the SLVCONTINUE bit in the SLVCTL register. The point in time when SlvPending is set depends on whether the I2C interface is in HSCAPABLE mode. See Section 25.7.2.2.2. When the I2C interface is configured to be HSCAPABLE, HS master codes are detected automatically. Due to the requirements of the HS I2C specification, slave addresses must also be detected automatically, since the address must be acknowledged before the clock can be stretched.
                SLVPENDING: enum(u1) {
                    /// In progress. The Slave function does not currently need service.
                    IN_PROGRESS = 0x0,
                    /// Pending. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field.
                    PENDING = 0x1,
                },
                /// Slave State code. Each value of this field indicates a specific required service for the Slave function. All other values are reserved. See Table 401 for state values and actions. note that the occurrence of some states and how they are handled are affected by DMA mode and Automatic Operation modes.
                SLVSTATE: enum(u2) {
                    /// Slave address. Address plus R/W received. At least one of the four slave addresses has been matched by hardware.
                    SLAVE_ADDRESS = 0x0,
                    /// Slave receive. Received data is available (Slave Receiver mode).
                    SLAVE_RECEIVE = 0x1,
                    /// Slave transmit. Data can be transmitted (Slave Transmitter mode).
                    SLAVE_TRANSMIT = 0x2,
                    _,
                },
                /// Slave Not Stretching. Indicates when the slave function is stretching the I2C clock. This is needed in order to gracefully invoke Deep Sleep or Power-down modes during slave operation. This read-only flag reflects the slave function status in real time.
                SLVNOTSTR: enum(u1) {
                    /// Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time.
                    STRETCHING = 0x0,
                    /// Not stretching. The slave function is not currently stretching the I 2C bus clock. Deep-sleep or Power-down mode could be entered at this time.
                    NOT_STRETCHING = 0x1,
                },
                /// Slave address match Index. This field is valid when the I2C slave function has been selected by receiving an address that matches one of the slave addresses defined by any enabled slave address registers, and provides an identification of the address that was matched. It is possible that more than one address could be matched, but only one match can be reported here.
                SLVIDX: enum(u2) {
                    /// Address 0. Slave address 0 was matched.
                    ADDRESS0 = 0x0,
                    /// Address 1. Slave address 1 was matched.
                    ADDRESS1 = 0x1,
                    /// Address 2. Slave address 2 was matched.
                    ADDRESS2 = 0x2,
                    /// Address 3. Slave address 3 was matched.
                    ADDRESS3 = 0x3,
                },
                /// Slave selected flag. SLVSEL is set after an address match when software tells the Slave function to acknowledge the address, or when the address has been automatically acknowledged. It is cleared when another address cycle presents an address that does not match an enabled address on the Slave function, when slave software decides to NACK a matched address, when there is a Stop detected on the bus, when the master NACKs slave data, and in some combinations of Automatic Operation. SLVSEL is not cleared if software NACKs data.
                SLVSEL: enum(u1) {
                    /// Not selected. The Slave function is not currently selected.
                    NOT_SELECTED = 0x0,
                    /// Selected. The Slave function is currently selected.
                    SELECTED = 0x1,
                },
                /// Slave Deselected flag. This flag will cause an interrupt when set if enabled via INTENSET. This flag can be cleared by writing a 1 to this bit.
                SLVDESEL: enum(u1) {
                    /// Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag.
                    NOT_DESELECTED = 0x0,
                    /// Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs.
                    DESELECTED = 0x1,
                },
                /// Monitor Ready. This flag is cleared when the MONRXDAT register is read.
                MONRDY: enum(u1) {
                    /// No data. The Monitor function does not currently have data available.
                    NO_DATA = 0x0,
                    /// Data waiting. The Monitor function has data waiting to be read.
                    DATA_WAITING = 0x1,
                },
                /// Monitor Overflow flag.
                MONOV: enum(u1) {
                    /// No overrun. Monitor data has not overrun.
                    NO_OVERRUN = 0x0,
                    /// Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag.
                    OVERRUN = 0x1,
                },
                /// Monitor Active flag. Indicates when the Monitor function considers the I 2C bus to be active. Active is defined here as when some Master is on the bus: a bus Start has occurred more recently than a bus Stop.
                MONACTIVE: enum(u1) {
                    /// Inactive. The Monitor function considers the I2C bus to be inactive.
                    INACTIVE = 0x0,
                    /// Active. The Monitor function considers the I2C bus to be active.
                    ACTIVE = 0x1,
                },
                /// Monitor Idle flag. This flag is set when the Monitor function sees the I2C bus change from active to inactive. This can be used by software to decide when to process data accumulated by the Monitor function. This flag will cause an interrupt when set if enabled via the INTENSET register. The flag can be cleared by writing a 1 to this bit.
                MONIDLE: enum(u1) {
                    /// Not idle. The I2C bus is not idle, or this flag has been cleared by software.
                    NOT_IDLE = 0x0,
                    /// Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software.
                    IDLE = 0x1,
                },
                reserved24: u4,
                /// Event Time-out Interrupt flag. Indicates when the time between events has been longer than the time specified by the TIMEOUT register. Events include Start, Stop, and clock edges. The flag is cleared by writing a 1 to this bit. No time-out is created when the I2C-bus is idle.
                EVENTTIMEOUT: enum(u1) {
                    /// No time-out. I2C bus events have not caused a time-out.
                    NO_TIMEOUT = 0x0,
                    /// Event time-out. The time between I2C bus events has been longer than the time specified by the TIMEOUT register.
                    EVEN_TIMEOUT = 0x1,
                },
                /// SCL Time-out Interrupt flag. Indicates when SCL has remained low longer than the time specific by the TIMEOUT register. The flag is cleared by writing a 1 to this bit.
                SCLTIMEOUT: enum(u1) {
                    /// No time-out. SCL low time has not caused a time-out.
                    NO_TIMEOUT = 0x0,
                    /// Time-out. SCL low time has caused a time-out.
                    TIMEOUT = 0x1,
                },
                padding: u6,
            }),
            /// Interrupt Enable Set and read register.
            INTENSET: mmio.Mmio(packed struct(u32) {
                /// Master Pending interrupt Enable.
                MSTPENDINGEN: enum(u1) {
                    /// Disabled. The MstPending interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The MstPending interrupt is enabled.
                    ENABLED = 0x1,
                },
                reserved4: u3,
                /// Master Arbitration Loss interrupt Enable.
                MSTARBLOSSEN: enum(u1) {
                    /// Disabled. The MstArbLoss interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The MstArbLoss interrupt is enabled.
                    ENABLED = 0x1,
                },
                reserved6: u1,
                /// Master Start/Stop Error interrupt Enable.
                MSTSTSTPERREN: enum(u1) {
                    /// Disabled. The MstStStpErr interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The MstStStpErr interrupt is enabled.
                    ENABLED = 0x1,
                },
                reserved8: u1,
                /// Slave Pending interrupt Enable.
                SLVPENDINGEN: enum(u1) {
                    /// Disabled. The SlvPending interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The SlvPending interrupt is enabled.
                    ENABLED = 0x1,
                },
                reserved11: u2,
                /// Slave Not Stretching interrupt Enable.
                SLVNOTSTREN: enum(u1) {
                    /// Disabled. The SlvNotStr interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The SlvNotStr interrupt is enabled.
                    ENABLED = 0x1,
                },
                reserved15: u3,
                /// Slave Deselect interrupt Enable.
                SLVDESELEN: enum(u1) {
                    /// Disabled. The SlvDeSel interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The SlvDeSel interrupt is enabled.
                    ENABLED = 0x1,
                },
                /// Monitor data Ready interrupt Enable.
                MONRDYEN: enum(u1) {
                    /// Disabled. The MonRdy interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The MonRdy interrupt is enabled.
                    ENABLED = 0x1,
                },
                /// Monitor Overrun interrupt Enable.
                MONOVEN: enum(u1) {
                    /// Disabled. The MonOv interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The MonOv interrupt is enabled.
                    ENABLED = 0x1,
                },
                reserved19: u1,
                /// Monitor Idle interrupt Enable.
                MONIDLEEN: enum(u1) {
                    /// Disabled. The MonIdle interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The MonIdle interrupt is enabled.
                    ENABLED = 0x1,
                },
                reserved24: u4,
                /// Event time-out interrupt Enable.
                EVENTTIMEOUTEN: enum(u1) {
                    /// Disabled. The Event time-out interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The Event time-out interrupt is enabled.
                    ENABLED = 0x1,
                },
                /// SCL time-out interrupt Enable.
                SCLTIMEOUTEN: enum(u1) {
                    /// Disabled. The SCL time-out interrupt is disabled.
                    DISABLED = 0x0,
                    /// Enabled. The SCL time-out interrupt is enabled.
                    ENABLED = 0x1,
                },
                padding: u6,
            }),
            /// Interrupt Enable Clear register.
            INTENCLR: mmio.Mmio(packed struct(u32) {
                /// Master Pending interrupt clear. Writing 1 to this bit clears the corresponding bit in the INTENSET register if implemented.
                MSTPENDINGCLR: u1,
                reserved4: u3,
                /// Master Arbitration Loss interrupt clear.
                MSTARBLOSSCLR: u1,
                reserved6: u1,
                /// Master Start/Stop Error interrupt clear.
                MSTSTSTPERRCLR: u1,
                reserved8: u1,
                /// Slave Pending interrupt clear.
                SLVPENDINGCLR: u1,
                reserved11: u2,
                /// Slave Not Stretching interrupt clear.
                SLVNOTSTRCLR: u1,
                reserved15: u3,
                /// Slave Deselect interrupt clear.
                SLVDESELCLR: u1,
                /// Monitor data Ready interrupt clear.
                MONRDYCLR: u1,
                /// Monitor Overrun interrupt clear.
                MONOVCLR: u1,
                reserved19: u1,
                /// Monitor Idle interrupt clear.
                MONIDLECLR: u1,
                reserved24: u4,
                /// Event time-out interrupt clear.
                EVENTTIMEOUTCLR: u1,
                /// SCL time-out interrupt clear.
                SCLTIMEOUTCLR: u1,
                padding: u6,
            }),
            /// Time-out value register.
            TIMEOUT: mmio.Mmio(packed struct(u32) {
                /// Time-out time value, bottom four bits. These are hard-wired to 0xF. This gives a minimum time-out of 16 I2C function clocks and also a time-out resolution of 16 I2C function clocks.
                TOMIN: u4,
                /// Time-out time value. Specifies the time-out interval value in increments of 16 I 2C function clocks, as defined by the CLKDIV register. To change this value while I2C is in operation, disable all time-outs, write a new value to TIMEOUT, then re-enable time-outs. 0x000 = A time-out will occur after 16 counts of the I2C function clock. 0x001 = A time-out will occur after 32 counts of the I2C function clock. 0xFFF = A time-out will occur after 65,536 counts of the I2C function clock.
                TO: u12,
                padding: u16,
            }),
            /// Clock pre-divider for the entire I2C interface. This determines what time increments are used for the MSTTIME register, and controls some timing of the Slave function.
            CLKDIV: mmio.Mmio(packed struct(u32) {
                /// This field controls how the Flexcomm clock (FCLK) is used by the I2C functions that need an internal clock in order to operate. 0x0000 = FCLK is used directly by the I2C. 0x0001 = FCLK is divided by 2 before use. 0x0002 = FCLK is divided by 3 before use. 0xFFFF = FCLK is divided by 65,536 before use.
                DIVVAL: u16,
                padding: u16,
            }),
            /// Interrupt Status register for Master, Slave, and Monitor functions.
            INTSTAT: mmio.Mmio(packed struct(u32) {
                /// Master Pending.
                MSTPENDING: u1,
                reserved4: u3,
                /// Master Arbitration Loss flag.
                MSTARBLOSS: u1,
                reserved6: u1,
                /// Master Start/Stop Error flag.
                MSTSTSTPERR: u1,
                reserved8: u1,
                /// Slave Pending.
                SLVPENDING: u1,
                reserved11: u2,
                /// Slave Not Stretching status.
                SLVNOTSTR: u1,
                reserved15: u3,
                /// Slave Deselected flag.
                SLVDESEL: u1,
                /// Monitor Ready.
                MONRDY: u1,
                /// Monitor Overflow flag.
                MONOV: u1,
                reserved19: u1,
                /// Monitor Idle flag.
                MONIDLE: u1,
                reserved24: u4,
                /// Event time-out Interrupt flag.
                EVENTTIMEOUT: u1,
                /// SCL time-out Interrupt flag.
                SCLTIMEOUT: u1,
                padding: u6,
            }),
            reserved2080: [4]u8,
            /// Master control register.
            MSTCTL: mmio.Mmio(packed struct(u32) {
                /// Master Continue. This bit is write-only.
                MSTCONTINUE: enum(u1) {
                    /// No effect.
                    NO_EFFECT = 0x0,
                    /// Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation.
                    CONTINUE = 0x1,
                },
                /// Master Start control. This bit is write-only.
                MSTSTART: enum(u1) {
                    /// No effect.
                    NO_EFFECT = 0x0,
                    /// Start. A Start will be generated on the I2C bus at the next allowed time.
                    START = 0x1,
                },
                /// Master Stop control. This bit is write-only.
                MSTSTOP: enum(u1) {
                    /// No effect.
                    NO_EFFECT = 0x0,
                    /// Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a NACK to the slave if the master is receiving data from the slave (Master Receiver mode).
                    STOP = 0x1,
                },
                /// Master DMA enable. Data operations of the I2C can be performed with DMA. Protocol type operations such as Start, address, Stop, and address match must always be done with software, typically via an interrupt. Address acknowledgement must also be done by software except when the I2C is configured to be HSCAPABLE (and address acknowledgement is handled entirely by hardware) or when Automatic Operation is enabled. When a DMA data transfer is complete, MSTDMA must be cleared prior to beginning the next operation, typically a Start or Stop.This bit is read/write.
                MSTDMA: enum(u1) {
                    /// Disable. No DMA requests are generated for master operation.
                    DISABLED = 0x0,
                    /// Enable. A DMA request is generated for I2C master data operations. When this I2C master is generating Acknowledge bits in Master Receiver mode, the acknowledge is generated automatically.
                    ENABLED = 0x1,
                },
                padding: u28,
            }),
            /// Master timing configuration.
            MSTTIME: mmio.Mmio(packed struct(u32) {
                /// Master SCL Low time. Specifies the minimum low time that will be asserted by this master on SCL. Other devices on the bus (masters or slaves) could lengthen this time. This corresponds to the parameter t LOW in the I2C bus specification. I2C bus specification parameters tBUF and tSU;STA have the same values and are also controlled by MSTSCLLOW.
                MSTSCLLOW: enum(u3) {
                    /// 2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider.
                    CLOCKS_2 = 0x0,
                    /// 3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider.
                    CLOCKS_3 = 0x1,
                    /// 4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider.
                    CLOCKS_4 = 0x2,
                    /// 5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider.
                    CLOCKS_5 = 0x3,
                    /// 6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider.
                    CLOCKS_6 = 0x4,
                    /// 7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider.
                    CLOCKS_7 = 0x5,
                    /// 8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider.
                    CLOCKS_8 = 0x6,
                    /// 9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider.
                    CLOCKS_9 = 0x7,
                },
                reserved4: u1,
                /// Master SCL High time. Specifies the minimum high time that will be asserted by this master on SCL. Other masters in a multi-master system could shorten this time. This corresponds to the parameter tHIGH in the I2C bus specification. I2C bus specification parameters tSU;STO and tHD;STA have the same values and are also controlled by MSTSCLHIGH.
                MSTSCLHIGH: enum(u3) {
                    /// 2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider.
                    CLOCKS_2 = 0x0,
                    /// 3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider .
                    CLOCKS_3 = 0x1,
                    /// 4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider.
                    CLOCKS_4 = 0x2,
                    /// 5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider.
                    CLOCKS_5 = 0x3,
                    /// 6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider.
                    CLOCKS_6 = 0x4,
                    /// 7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider.
                    CLOCKS_7 = 0x5,
                    /// 8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider.
                    CLOCKS_8 = 0x6,
                    /// 9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider.
                    CLOCKS_9 = 0x7,
                },
                padding: u25,
            }),
            /// Combined Master receiver and transmitter data register.
            MSTDAT: mmio.Mmio(packed struct(u32) {
                /// Master function data register. Read: read the most recently received data for the Master function. Write: transmit data using the Master function.
                DATA: u8,
                padding: u24,
            }),
            reserved2112: [20]u8,
            /// Slave control register.
            SLVCTL: mmio.Mmio(packed struct(u32) {
                /// Slave Continue.
                SLVCONTINUE: enum(u1) {
                    /// No effect.
                    NO_EFFECT = 0x0,
                    /// Continue. Informs the Slave function to continue to the next operation, by clearing the SLVPENDING flag in the STAT register. This must be done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation. Automatic Operation has different requirements. SLVCONTINUE should not be set unless SLVPENDING = 1.
                    CONTINUE = 0x1,
                },
                /// Slave NACK.
                SLVNACK: enum(u1) {
                    /// No effect.
                    NO_EFFECT = 0x0,
                    /// NACK. Causes the Slave function to NACK the master when the slave is receiving data from the master (Slave Receiver mode).
                    NACK = 0x1,
                },
                reserved3: u1,
                /// Slave DMA enable.
                SLVDMA: enum(u1) {
                    /// Disabled. No DMA requests are issued for Slave mode operation.
                    DISABLED = 0x0,
                    /// Enabled. DMA requests are issued for I2C slave data transmission and reception.
                    ENABLED = 0x1,
                },
                reserved8: u4,
                /// Automatic Acknowledge.When this bit is set, it will cause an I2C header which matches SLVADR0 and the direction set by AUTOMATCHREAD to be ACKed immediately; this is used with DMA to allow processing of the data without intervention. If this bit is clear and a header matches SLVADR0, the behavior is controlled by AUTONACK in the SLVADR0 register: allowing NACK or interrupt.
                AUTOACK: enum(u1) {
                    /// Normal, non-automatic operation. If AUTONACK = 0, an SlvPending interrupt is generated when a matching address is received. If AUTONACK = 1, received addresses are NACKed (ignored).
                    NORMAL = 0x0,
                    /// A header with matching SLVADR0 and matching direction as set by AUTOMATCHREAD will be ACKed immediately, allowing the master to move on to the data bytes. If the address matches SLVADR0, but the direction does not match AUTOMATCHREAD, the behavior will depend on the AUTONACK bit in the SLVADR0 register: if AUTONACK is set, then it will be Nacked; else if AUTONACK is clear, then a SlvPending interrupt is generated.
                    AUTOMATIC_ACK = 0x1,
                },
                /// When AUTOACK is set, this bit controls whether it matches a read or write request on the next header with an address matching SLVADR0. Since DMA needs to be configured to match the transfer direction, the direction needs to be specified. This bit allows a direction to be chosen for the next operation.
                AUTOMATCHREAD: enum(u1) {
                    /// The expected next operation in Automatic Mode is an I2C write.
                    I2C_WRITE = 0x0,
                    /// The expected next operation in Automatic Mode is an I2C read.
                    I2C_READ = 0x1,
                },
                padding: u22,
            }),
            /// Combined Slave receiver and transmitter data register.
            SLVDAT: mmio.Mmio(packed struct(u32) {
                /// Slave function data register. Read: read the most recently received data for the Slave function. Write: transmit data using the Slave function.
                DATA: u8,
                padding: u24,
            }),
            /// Slave address register.
            SLVADR: [4]mmio.Mmio(packed struct(u32) {
                /// Slave Address n Disable.
                SADISABLE: enum(u1) {
                    /// Enabled. Slave Address n is enabled.
                    ENABLED = 0x0,
                    /// Ignored Slave Address n is ignored.
                    DISABLED = 0x1,
                },
                /// Slave Address. Seven bit slave address that is compared to received addresses if enabled.
                SLVADR: u7,
                reserved15: u7,
                /// Automatic NACK operation. Used in conjunction with AUTOACK and AUTOMATCHREAD, allows software to ignore I2C traffic while handling previous I2C data or other operations.
                AUTONACK: enum(u1) {
                    /// Normal operation, matching I2C addresses are not ignored.
                    NORMAL = 0x0,
                    /// Automatic-only mode. All incoming addresses are ignored (NACKed), unless AUTOACK is set, it matches SLVADRn, and AUTOMATCHREAD matches the direction.
                    AUTOMATIC = 0x1,
                },
                padding: u16,
            }),
            /// Slave Qualification for address 0.
            SLVQUAL0: mmio.Mmio(packed struct(u32) {
                /// Qualify mode for slave address 0.
                QUALMODE0: enum(u1) {
                    /// Mask. The SLVQUAL0 field is used as a logical mask for matching address 0.
                    MASK = 0x0,
                    /// Extend. The SLVQUAL0 field is used to extend address 0 matching in a range of addresses.
                    EXTEND = 0x1,
                },
                /// Slave address Qualifier for address 0. A value of 0 causes the address in SLVADR0 to be used as-is, assuming that it is enabled. If QUALMODE0 = 0, any bit in this field which is set to 1 will cause an automatic match of the corresponding bit of the received address when it is compared to the SLVADR0 register. If QUALMODE0 = 1, an address range is matched for address 0. This range extends from the value defined by SLVADR0 to the address defined by SLVQUAL0 (address matches when SLVADR0[7:1] <= received address <= SLVQUAL0[7:1]).
                SLVQUAL0: u7,
                padding: u24,
            }),
            reserved2176: [36]u8,
            /// Monitor receiver data register.
            MONRXDAT: mmio.Mmio(packed struct(u32) {
                /// Monitor function Receiver Data. This reflects every data byte that passes on the I2C pins.
                MONRXDAT: u8,
                /// Monitor Received Start.
                MONSTART: enum(u1) {
                    /// No start detected. The Monitor function has not detected a Start event on the I2C bus.
                    NO_START_DETECTED = 0x0,
                    /// Start detected. The Monitor function has detected a Start event on the I2C bus.
                    START_DETECTED = 0x1,
                },
                /// Monitor Received Repeated Start.
                MONRESTART: enum(u1) {
                    /// No repeated start detected. The Monitor function has not detected a Repeated Start event on the I2C bus.
                    NOT_DETECTED = 0x0,
                    /// Repeated start detected. The Monitor function has detected a Repeated Start event on the I2C bus.
                    DETECTED = 0x1,
                },
                /// Monitor Received NACK.
                MONNACK: enum(u1) {
                    /// Acknowledged. The data currently being provided by the Monitor function was acknowledged by at least one master or slave receiver.
                    ACKNOWLEDGED = 0x0,
                    /// Not acknowledged. The data currently being provided by the Monitor function was not acknowledged by any receiver.
                    NOT_ACKNOWLEDGED = 0x1,
                },
                padding: u21,
            }),
            reserved4092: [1912]u8,
            /// Peripheral identification register.
            ID: mmio.Mmio(packed struct(u32) {
                /// Aperture: encoded as (aperture size/4K) -1, so 0x00 means a 4K aperture.
                APERTURE: u8,
                /// Minor revision of module implementation.
                MINOR_REV: u4,
                /// Major revision of module implementation.
                MAJOR_REV: u4,
                /// Module identifier for the selected function.
                ID: u16,
            }),
        };

        /// LPC5411x I2S interface
        pub const I2S0 = extern struct {
            reserved3072: [3072]u8,
            /// Configuration register 1 for the primary channel pair.
            CFG1: mmio.Mmio(packed struct(u32) {
                /// Main enable for I 2S function in this Flexcomm
                MAINENABLE: enum(u1) {
                    /// All I 2S channel pairs in this Flexcomm are disabled and the internal state machines, counters, and flags are reset. No other channel pairs can be enabled.
                    DISABLED = 0x0,
                    /// This I 2S channel pair is enabled. Other channel pairs in this Flexcomm may be enabled in their individual PAIRENABLE bits.
                    ENABLED = 0x1,
                },
                /// Data flow Pause. Allows pausing data flow between the I2S serializer/deserializer and the FIFO. This could be done in order to change streams, or while restarting after a data underflow or overflow. When paused, FIFO operations can be done without corrupting data that is in the process of being sent or received. Once a data pause has been requested, the interface may need to complete sending data that was in progress before interrupting the flow of data. Software must check that the pause is actually in effect before taking action. This is done by monitoring the DATAPAUSED flag in the STAT register. When DATAPAUSE is cleared, data transfer will resume at the beginning of the next frame.
                DATAPAUSE: enum(u1) {
                    /// Normal operation, or resuming normal operation at the next frame if the I2S has already been paused.
                    NORMAL = 0x0,
                    /// A pause in the data flow is being requested. It is in effect when DATAPAUSED in STAT = 1.
                    PAUSE = 0x1,
                },
                /// Provides the number of I2S channel pairs in this Flexcomm This is a read-only field whose value may be different in other Flexcomms. 00 = there is 1 I2S channel pair in this Flexcomm. 01 = there are 2 I2S channel pairs in this Flexcomm. 10 = there are 3 I2S channel pairs in this Flexcomm. 11 = there are 4 I2S channel pairs in this Flexcomm.
                PAIRCOUNT: enum(u2) {
                    /// 1 I2S channel pairs in this flexcomm
                    PAIRS_1 = 0x0,
                    /// 2 I2S channel pairs in this flexcomm
                    PAIRS_2 = 0x1,
                    /// 3 I2S channel pairs in this flexcomm
                    PAIRS_3 = 0x2,
                    /// 4 I2S channel pairs in this flexcomm
                    PAIRS_4 = 0x3,
                },
                /// Master / slave configuration selection, determining how SCK and WS are used by all channel pairs in this Flexcomm.
                MSTSLVCFG: enum(u2) {
                    /// Normal slave mode, the default mode. SCK and WS are received from a master and used to transmit or receive data.
                    NORMAL_SLAVE_MODE = 0x0,
                    /// WS synchronized master. WS is received from another master and used to synchronize the generation of SCK, when divided from the Flexcomm function clock.
                    WS_SYNC_MASTER = 0x1,
                    /// Master using an existing SCK. SCK is received and used directly to generate WS, as well as transmitting or receiving data.
                    MASTER_USING_SCK = 0x2,
                    /// Normal master mode. SCK and WS are generated so they can be sent to one or more slave devices.
                    NORMAL_MASTER = 0x3,
                },
                /// Selects the basic I2S operating mode. Other configurations modify this to obtain all supported cases. See Formats and modes for examples.
                MODE: enum(u2) {
                    /// I2S mode a.k.a. 'classic' mode. WS has a 50% duty cycle, with (for each enabled channel pair) one piece of left channel data occurring during the first phase, and one pieces of right channel data occurring during the second phase. In this mode, the data region begins one clock after the leading WS edge for the frame. For a 50% WS duty cycle, FRAMELEN must define an even number of I2S clocks for the frame. If FRAMELEN defines an odd number of clocks per frame, the extra clock will occur on the right.
                    CLASSIC_MODE = 0x0,
                    /// DSP mode where WS has a 50% duty cycle. See remark for mode 0.
                    DSP_MODE_WS_50_DUTYCYCLE = 0x1,
                    /// DSP mode where WS has a one clock long pulse at the beginning of each data frame.
                    DSP_MODE_WS_1_CLOCK = 0x2,
                    /// DSP mode where WS has a one data slot long pulse at the beginning of each data frame.
                    DSP_MODE_WS_1_DATA = 0x3,
                },
                /// Right channel data is in the Low portion of FIFO data. Essentially, this swaps left and right channel data as it is transferred to or from the FIFO. This bit is not used if the data width is greater than 24 bits or if PDMDATA = 1. Note that if the ONECHANNEL field (bit 10 of this register) = 1, the one channel to be used is the nominally the left channel. POSITION can still place that data in the frame where right channel data is normally located. if all enabled channel pairs have ONECHANNEL = 1, then RIGHTLOW = 1 is not allowed.
                RIGHTLOW: enum(u1) {
                    /// The right channel is taken from the high part of the FIFO data. For example, when data is 16 bits, FIFO bits 31:16 are used for the right channel.
                    RIGHT_HIGH = 0x0,
                    /// The right channel is taken from the low part of the FIFO data. For example, when data is 16 bits, FIFO bits 15:0 are used for the right channel.
                    RIGHT_LOW = 0x1,
                },
                /// Left Justify data.
                LEFTJUST: enum(u1) {
                    /// Data is transferred between the FIFO and the I2S serializer/deserializer right justified, i.e. starting from bit 0 and continuing to the position defined by DATALEN. This would correspond to right justified data in the stream on the data bus.
                    RIGHT_JUSTIFIED = 0x0,
                    /// Data is transferred between the FIFO and the I2S serializer/deserializer left justified, i.e. starting from the MSB of the FIFO entry and continuing for the number of bits defined by DATALEN. This would correspond to left justified data in the stream on the data bus.
                    LEFT_JUSTIFIED = 0x1,
                },
                /// Single channel mode. Applies to both transmit and receive. This configuration bit applies only to the first I2S channel pair. Other channel pairs may select this mode independently in their separate CFG1 registers.
                ONECHANNEL: enum(u1) {
                    /// I2S data for this channel pair is treated as left and right channels.
                    DUAL_CHANNEL = 0x0,
                    /// I2S data for this channel pair is treated as a single channel, functionally the left channel for this pair. In mode 0 only, the right side of the frame begins at POSITION = 0x100. This is because mode 0 makes a clear distinction between the left and right sides of the frame. When ONECHANNEL = 1, the single channel of data may be placed on the right by setting POSITION to 0x100 + the data position within the right side (e.g. 0x108 would place data starting at the 8th clock after the middle of the frame). In other modes, data for the single channel of data is placed at the clock defined by POSITION.
                    SINGLE_CHANNEL = 0x1,
                },
                /// PDM Data selection. This bit controls the data source for I2S transmit, and cannot be set in Rx mode. This bit only has an effect if the device the Flexcomm resides in includes a D-Mic subsystem. For the LPC5411x, this bit applies only to Flexcomm 7.
                PDMDATA: enum(u1) {
                    /// Normal operation, data is transferred to or from the Flexcomm FIFO.
                    NORMAL = 0x0,
                    /// The data source is the D-Mic subsystem. When PDMDATA = 1, only the primary channel pair can be used in this Flexcomm. If ONECHANNEL = 1, only the PDM left data is used. the WS rate must match the Fs (sample rate) of the D-Mic decimator. A rate mismatch will at some point cause the I2S to overrun or underrun.
                    DMIC_SUBSYSTEM = 0x1,
                },
                /// SCK polarity.
                SCK_POL: enum(u1) {
                    /// Data is launched on SCK falling edges and sampled on SCK rising edges (standard for I2S).
                    FALLING_EDGE = 0x0,
                    /// Data is launched on SCK rising edges and sampled on SCK falling edges.
                    RISING_EDGE = 0x1,
                },
                /// WS polarity.
                WS_POL: enum(u1) {
                    /// Data frames begin at a falling edge of WS (standard for classic I2S).
                    NOT_INVERTED = 0x0,
                    /// WS is inverted, resulting in a data frame beginning at a rising edge of WS (standard for most 'non-classic' variations of I2S).
                    INVERTED = 0x1,
                },
                reserved16: u2,
                /// Data Length, minus 1 encoded, defines the number of data bits to be transmitted or received for all I2S channel pairs in this Flexcomm. Note that data is only driven to or received from SDA for the number of bits defined by DATALEN. DATALEN is also used in these ways by the I2S: Determines the size of data transfers between the FIFO and the I2S serializer/deserializer. See FIFO buffer configurations and usage In mode 1, 2, and 3, determines the location of right data following left data in the frame. In mode 3 (where WS has a one data slot long pulse at the beginning of each data frame) determines the duration of the WS pulse. Values: 0x00 to 0x02 = not supported 0x03 = data is 4 bits in length 0x04 = data is 5 bits in length 0x1F = data is 32 bits in length
                DATALEN: u5,
                padding: u11,
            }),
            /// Configuration register 2 for the primary channel pair.
            CFG2: mmio.Mmio(packed struct(u32) {
                /// Frame Length, minus 1 encoded, defines the number of clocks and data bits in the frames that this channel pair participates in. See Frame format. 0x000 to 0x002 = not supported 0x003 = frame is 4 bits in total length 0x004 = frame is 5 bits in total length 0x1FF = frame is 512 bits in total length if FRAMELEN is an defines an odd length frame (e.g. 33 clocks) in mode 0 or 1, the extra clock appears in the right half. When MODE = 3, FRAMELEN must be larger than DATALEN in order for the WS pulse to be generated correctly.
                FRAMELEN: u9,
                reserved16: u7,
                /// Data Position. Defines the location within the frame of the data for this channel pair. POSITION + DATALEN must be less than FRAMELEN. See Frame format. When MODE = 0, POSITION defines the location of data in both the left phase and right phase, starting one clock after the WS edge. In other modes, POSITION defines the location of data within the entire frame. ONECHANNEL = 1 while MODE = 0 is a special case, see the description of ONECHANNEL. The combination of DATALEN and the POSITION fields of all channel pairs must be made such that the channels do not overlap within the frame. 0x000 = data begins at bit position 0 (the first bit position) within the frame or WS phase. 0x001 = data begins at bit position 1 within the frame or WS phase. 0x002 = data begins at bit position 2 within the frame or WS phase.
                POSITION: u9,
                padding: u7,
            }),
            /// Status register for the primary channel pair.
            STAT: mmio.Mmio(packed struct(u32) {
                /// Busy status for the primary channel pair. Other BUSY flags may be found in the STAT register for each channel pair.
                BUSY: enum(u1) {
                    /// The transmitter/receiver for channel pair is currently idle.
                    IDLE = 0x0,
                    /// The transmitter/receiver for channel pair is currently processing data.
                    BUSY = 0x1,
                },
                /// Slave Frame Error flag. This applies when at least one channel pair is operating as a slave. An error indicates that the incoming WS signal did not transition as expected due to a mismatch between FRAMELEN and the actual incoming I2S stream.
                SLVFRMERR: enum(u1) {
                    /// No error has been recorded.
                    NO_ERROR = 0x0,
                    /// An error has been recorded for some channel pair that is operating in slave mode. ERROR is cleared by writing a 1 to this bit position.
                    ERROR = 0x1,
                },
                /// Left/Right indication. This flag is considered to be a debugging aid and is not expected to be used by an I2S driver. Valid when one channel pair is busy. Indicates left or right data being processed for the currently busy channel pair.
                LR: enum(u1) {
                    /// Left channel.
                    LEFT_CHANNEL = 0x0,
                    /// Right channel.
                    RIGHT_CHANNEL = 0x1,
                },
                /// Data Paused status flag. Applies to all I2S channels
                DATAPAUSED: enum(u1) {
                    /// Data is not currently paused. A data pause may have been requested but is not yet in force, waiting for an allowed pause point. Refer to the description of the DATAPAUSE control bit in the CFG1 register.
                    NOT_PAUSED = 0x0,
                    /// A data pause has been requested and is now in force.
                    PAUSED = 0x1,
                },
                padding: u28,
            }),
            reserved3100: [16]u8,
            /// Clock divider, used by all channel pairs.
            DIV: mmio.Mmio(packed struct(u32) {
                /// This field controls how this I2S block uses the Flexcomm function clock. 0x000 = The Flexcomm function clock is used directly. 0x001 = The Flexcomm function clock is divided by 2. 0x002 = The Flexcomm function clock is divided by 3. 0xFFF = The Flexcomm function clock is divided by 4,096.
                DIV: u12,
                padding: u20,
            }),
            reserved3584: [480]u8,
            /// FIFO configuration and enable register.
            FIFOCFG: mmio.Mmio(packed struct(u32) {
                /// Enable the transmit FIFO.
                ENABLETX: enum(u1) {
                    /// The transmit FIFO is not enabled.
                    DISABLED = 0x0,
                    /// The transmit FIFO is enabled.
                    ENABLED = 0x1,
                },
                /// Enable the receive FIFO.
                ENABLERX: enum(u1) {
                    /// The receive FIFO is not enabled.
                    DISABLED = 0x0,
                    /// The receive FIFO is enabled.
                    ENABLED = 0x1,
                },
                /// Transmit I2S empty 0. Determines the value sent by the I2S in transmit mode if the TX FIFO becomes empty. This value is sent repeatedly until the I2S is paused, the error is cleared, new data is provided, and the I2S is un-paused.
                TXI2SE0: enum(u1) {
                    /// If the TX FIFO becomes empty, the last value is sent. This setting may be used when the data length is 24 bits or less, or when MONO = 1 for this channel pair.
                    LAST_VALUE = 0x0,
                    /// If the TX FIFO becomes empty, 0 is sent. Use if the data length is greater than 24 bits or if zero fill is preferred.
                    ZERO = 0x1,
                },
                /// Packing format for 48-bit data. This relates to how data is entered into or taken from the FIFO by software or DMA.
                PACK48: enum(u1) {
                    /// 48-bit I2S FIFO entries are handled as all 24-bit values.
                    BIT_24 = 0x0,
                    /// 48-bit I2S FIFO entries are handled as alternating 32-bit and 16-bit values.
                    BIT_32_16 = 0x1,
                },
                /// FIFO size configuration. This is a read-only field. 0x0 = FIFO is configured as 16 entries of 8 bits. 0x1, 0x2, 0x3 = not applicable to USART.
                SIZE: u2,
                reserved12: u6,
                /// DMA configuration for transmit.
                DMATX: enum(u1) {
                    /// DMA is not used for the transmit function.
                    DISABLED = 0x0,
                    /// Trigger DMA for the transmit function if the FIFO is not full. Generally, data interrupts would be disabled if DMA is enabled.
                    ENABLED = 0x1,
                },
                /// DMA configuration for receive.
                DMARX: enum(u1) {
                    /// DMA is not used for the receive function.
                    DISABLED = 0x0,
                    /// Trigger DMA for the receive function if the FIFO is not empty. Generally, data interrupts would be disabled if DMA is enabled.
                    ENABLED = 0x1,
                },
                /// Wake-up for transmit FIFO level. This allows the device to be woken from reduced power modes (up to power-down, as long as the peripheral function works in that power mode) without enabling the TXLVL interrupt. Only DMA wakes up, processes data, and goes back to sleep. The CPU will remain stopped until woken by another cause, such as DMA completion. See Hardware Wake-up control register.
                WAKETX: enum(u1) {
                    /// Only enabled interrupts will wake up the device form reduced power modes.
                    DISABLED = 0x0,
                    /// A device wake-up for DMA will occur if the transmit FIFO level reaches the value specified by TXLVL in FIFOTRIG, even when the TXLVL interrupt is not enabled.
                    ENABLED = 0x1,
                },
                /// Wake-up for receive FIFO level. This allows the device to be woken from reduced power modes (up to power-down, as long as the peripheral function works in that power mode) without enabling the TXLVL interrupt. Only DMA wakes up, processes data, and goes back to sleep. The CPU will remain stopped until woken by another cause, such as DMA completion. See Hardware Wake-up control register.
                WAKERX: enum(u1) {
                    /// Only enabled interrupts will wake up the device form reduced power modes.
                    DISABLED = 0x0,
                    /// A device wake-up for DMA will occur if the receive FIFO level reaches the value specified by RXLVL in FIFOTRIG, even when the RXLVL interrupt is not enabled.
                    ENABLED = 0x1,
                },
                /// Empty command for the transmit FIFO. When a 1 is written to this bit, the TX FIFO is emptied.
                EMPTYTX: u1,
                /// Empty command for the receive FIFO. When a 1 is written to this bit, the RX FIFO is emptied.
                EMPTYRX: u1,
                /// Pop FIFO for debug reads.
                POPDBG: enum(u1) {
                    /// Debug reads of the FIFO do not pop the FIFO.
                    DO_NOT_POP = 0x0,
                    /// A debug read will cause the FIFO to pop.
                    POP = 0x1,
                },
                padding: u13,
            }),
            /// FIFO status register.
            FIFOSTAT: mmio.Mmio(packed struct(u32) {
                /// TX FIFO error. Will be set if a transmit FIFO error occurs. This could be an overflow caused by pushing data into a full FIFO, or by an underflow if the FIFO is empty when data is needed. Cleared by writing a 1 to this bit.
                TXERR: u1,
                /// RX FIFO error. Will be set if a receive FIFO overflow occurs, caused by software or DMA not emptying the FIFO fast enough. Cleared by writing a 1 to this bit.
                RXERR: u1,
                reserved3: u1,
                /// Peripheral interrupt. When 1, this indicates that the peripheral function has asserted an interrupt. The details can be found by reading the peripheral's STAT register.
                PERINT: u1,
                /// Transmit FIFO empty. When 1, the transmit FIFO is empty. The peripheral may still be processing the last piece of data.
                TXEMPTY: u1,
                /// Transmit FIFO not full. When 1, the transmit FIFO is not full, so more data can be written. When 0, the transmit FIFO is full and another write would cause it to overflow.
                TXNOTFULL: u1,
                /// Receive FIFO not empty. When 1, the receive FIFO is not empty, so data can be read. When 0, the receive FIFO is empty.
                RXNOTEMPTY: u1,
                /// Receive FIFO full. When 1, the receive FIFO is full. Data needs to be read out to prevent the peripheral from causing an overflow.
                RXFULL: u1,
                /// Transmit FIFO current level. A 0 means the TX FIFO is currently empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other values tell how much data is actually in the TX FIFO at the point where the read occurs. If the TX FIFO is full, the TXEMPTY and TXNOTFULL flags will be 0.
                TXLVL: u5,
                reserved16: u3,
                /// Receive FIFO current level. A 0 means the RX FIFO is currently empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other values tell how much data is actually in the RX FIFO at the point where the read occurs. If the RX FIFO is full, the RXFULL and RXNOTEMPTY flags will be 1.
                RXLVL: u5,
                padding: u11,
            }),
            /// FIFO trigger settings for interrupt and DMA request.
            FIFOTRIG: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMATX in FIFOCFG is set.
                TXLVLENA: enum(u1) {
                    /// Transmit FIFO level does not generate a FIFO level trigger.
                    DISABLED = 0x0,
                    /// An trigger will be generated if the transmit FIFO level reaches the value specified by the TXLVL field in this register.
                    ENABLED = 0x1,
                },
                /// Receive FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMARX in FIFOCFG is set.
                RXLVLENA: enum(u1) {
                    /// Receive FIFO level does not generate a FIFO level trigger.
                    DISABLED = 0x0,
                    /// An trigger will be generated if the receive FIFO level reaches the value specified by the RXLVL field in this register.
                    ENABLED = 0x1,
                },
                reserved8: u6,
                /// Transmit FIFO level trigger point. This field is used only when TXLVLENA = 1. If enabled to do so, the FIFO level can wake up the device just enough to perform DMA, then return to the reduced power mode. See Hardware Wake-up control register. 0 = trigger when the TX FIFO becomes empty. 1 = trigger when the TX FIFO level decreases to one entry. 15 = trigger when the TX FIFO level decreases to 15 entries (is no longer full).
                TXLVL: u4,
                reserved16: u4,
                /// Receive FIFO level trigger point. The RX FIFO level is checked when a new piece of data is received. This field is used only when RXLVLENA = 1. If enabled to do so, the FIFO level can wake up the device just enough to perform DMA, then return to the reduced power mode. See Hardware Wake-up control register. 0 = trigger when the RX FIFO has received one entry (is no longer empty). 1 = trigger when the RX FIFO has received two entries. 15 = trigger when the RX FIFO has received 16 entries (has become full).
                RXLVL: u4,
                padding: u12,
            }),
            reserved3600: [4]u8,
            /// FIFO interrupt enable set (enable) and read register.
            FIFOINTENSET: mmio.Mmio(packed struct(u32) {
                /// Determines whether an interrupt occurs when a transmit error occurs, based on the TXERR flag in the FIFOSTAT register.
                TXERR: enum(u1) {
                    /// No interrupt will be generated for a transmit error.
                    DISABLED = 0x0,
                    /// An interrupt will be generated when a transmit error occurs.
                    ENABLED = 0x1,
                },
                /// Determines whether an interrupt occurs when a receive error occurs, based on the RXERR flag in the FIFOSTAT register.
                RXERR: enum(u1) {
                    /// No interrupt will be generated for a receive error.
                    DISABLED = 0x0,
                    /// An interrupt will be generated when a receive error occurs.
                    ENABLED = 0x1,
                },
                /// Determines whether an interrupt occurs when a the transmit FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.
                TXLVL: enum(u1) {
                    /// No interrupt will be generated based on the TX FIFO level.
                    DISABLED = 0x0,
                    /// If TXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the TX FIFO level decreases to the level specified by TXLVL in the FIFOTRIG register.
                    ENABLED = 0x1,
                },
                /// Determines whether an interrupt occurs when a the receive FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.
                RXLVL: enum(u1) {
                    /// No interrupt will be generated based on the RX FIFO level.
                    DISABLED = 0x0,
                    /// If RXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the when the RX FIFO level increases to the level specified by RXLVL in the FIFOTRIG register.
                    ENABLED = 0x1,
                },
                padding: u28,
            }),
            /// FIFO interrupt enable clear (disable) and read register.
            FIFOINTENCLR: mmio.Mmio(packed struct(u32) {
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                TXERR: u1,
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                RXERR: u1,
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                TXLVL: u1,
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                RXLVL: u1,
                padding: u28,
            }),
            /// FIFO interrupt status register.
            FIFOINTSTAT: mmio.Mmio(packed struct(u32) {
                /// TX FIFO error.
                TXERR: u1,
                /// RX FIFO error.
                RXERR: u1,
                /// Transmit FIFO level interrupt.
                TXLVL: u1,
                /// Receive FIFO level interrupt.
                RXLVL: u1,
                /// Peripheral interrupt.
                PERINT: u1,
                padding: u27,
            }),
            reserved3616: [4]u8,
            /// FIFO write data.
            FIFOWR: mmio.Mmio(packed struct(u32) {
                /// Transmit data to the FIFO. The number of bits used depends on configuration details.
                TXDATA: u32,
            }),
            /// FIFO write data for upper data bits. May only be used if the I2S is configured for 2x 24-bit data and not using DMA.
            FIFOWR48H: mmio.Mmio(packed struct(u32) {
                /// Transmit data to the FIFO. Whether this register is used and the number of bits used depends on configuration details.
                TXDATA: u24,
                padding: u8,
            }),
            reserved3632: [8]u8,
            /// FIFO read data.
            FIFORD: mmio.Mmio(packed struct(u32) {
                /// Received data from the FIFO. The number of bits used depends on configuration details.
                RXDATA: u32,
            }),
            /// FIFO read data for upper data bits. May only be used if the I2S is configured for 2x 24-bit data and not using DMA.
            FIFORD48H: mmio.Mmio(packed struct(u32) {
                /// Received data from the FIFO. Whether this register is used and the number of bits used depends on configuration details.
                RXDATA: u24,
                padding: u8,
            }),
            reserved3648: [8]u8,
            /// FIFO data read with no FIFO pop.
            FIFORDNOPOP: mmio.Mmio(packed struct(u32) {
                /// Received data from the FIFO.
                RXDATA: u32,
            }),
            /// FIFO data read for upper data bits with no FIFO pop. May only be used if the I2S is configured for 2x 24-bit data and not using DMA.
            FIFORD48HNOPOP: mmio.Mmio(packed struct(u32) {
                /// Received data from the FIFO. Whether this register is used and the number of bits used depends on configuration details.
                RXDATA: u24,
                padding: u8,
            }),
            reserved7676: [4020]u8,
            /// I2S Module identification
            ID: mmio.Mmio(packed struct(u32) {
                /// Aperture: encoded as (aperture size/4K) -1, so 0x00 means a 4K aperture.
                Aperture: u8,
                /// Minor revision of module implementation, starting at 0.
                Minor_Rev: u4,
                /// Major revision of module implementation, starting at 0.
                Major_Rev: u4,
                /// Unique module identifier for this IP block.
                ID: u16,
            }),
        };

        /// LPC5411x Input multiplexing (INPUT MUX)
        pub const INPUTMUX = extern struct {
            /// Trigger select register for DMA channel
            SCT0_INMUX: [7]mmio.Mmio(packed struct(u32) {
                /// Input number to SCT0 inputs 0 to 6..
                INP_N: u5,
                padding: u27,
            }),
            reserved192: [164]u8,
            /// Pin interrupt select register
            PINTSEL: [8]mmio.Mmio(packed struct(u32) {
                /// Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO1_31 correspond to numbers 0 to 63).
                INTPIN: u8,
                padding: u24,
            }),
            /// Trigger select register for DMA channel
            DMA_ITRIG_INMUX: [30]mmio.Mmio(packed struct(u32) {
                /// Trigger input number (decimal value) for DMA channel n (n = 0 to 21). 0 = ADC0 Sequence A interrupt 1 = ADC0 Sequence B interrupt 2 = SCT0 DMA request 0 3 = SCT0 DMA request 1 4 = Timer CTIMER0 Match 0 5 = Timer CTIMER0 Match 1 6 = Timer CTIMER1 Match 0 7 = Timer CTIMER2 Match 0 8 = Timer CTIMER2 Match 1 9 = Timer CTIMER3 Match 0 10 = Timer CTIMER4 Match 0 11 = Timer CTIMER4 Match 1 12 = Pin interrupt 0 13 = Pin interrupt 1 14 = Pin interrupt 2 15 = Pin interrupt 3 16 = DMA output trigger mux 0 17 = DMA output trigger mux 1 18 = DMA output trigger mux 2 19 = DMA output trigger mux 3
                INP: u5,
                padding: u27,
            }),
            reserved352: [8]u8,
            /// DMA output trigger selection to become DMA trigger
            DMA_OTRIG_INMUX: [4]mmio.Mmio(packed struct(u32) {
                /// DMA trigger output number (decimal value) for DMA channel n (n = 0 to 19).
                INP: u5,
                padding: u27,
            }),
            reserved384: [16]u8,
            /// Selection for frequency measurement reference clock
            FREQMEAS_REF: mmio.Mmio(packed struct(u32) {
                /// Clock source number (decimal value) for frequency measure function target clock: 0 = CLK_IN 1 = FRO 12 MHz oscillator 2 = Watchdog oscillator 3 = 32 kHz RTC oscillator 4 = Main clock (see Section 4.5.23) 5 = PIO0_4 6 = PIO0_20 7 = PIO0_24 8 = PIO1_4
                CLKIN: u5,
                padding: u27,
            }),
            /// Selection for frequency measurement target clock
            FREQMEAS_TARGET: mmio.Mmio(packed struct(u32) {
                /// Clock source number (decimal value) for frequency measure function target clock: 0 = CLK_IN 1 = FRO 12 MHz oscillator 2 = Watchdog oscillator 3 = 32 kHz RTC oscillator 4 = Main clock (see Section 4.5.23) 5 = PIO0_4 6 = PIO0_20 7 = PIO0_24 8 = PIO1_4
                CLKIN: u5,
                padding: u27,
            }),
        };

        /// LPC5411x I/O pin configuration (IOCON)
        pub const IOCON = extern struct {
            /// Digital I/O control for port 0 pins PIO0_0
            PIO00: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_1
            PIO01: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_2
            PIO02: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_3
            PIO03: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_4
            PIO04: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_5
            PIO05: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_6
            PIO06: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_7
            PIO07: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_8
            PIO08: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_9
            PIO09: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_10
            PIO010: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_11
            PIO011: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_12
            PIO012: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_13
            PIO013: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                reserved6: u2,
                /// Controls slew rate of I2C pad.
                I2CSLEW: enum(u1) {
                    /// I2C mode.
                    I2C_MODE = 0x0,
                    /// GPIO mode.
                    GPIO_MODE = 0x1,
                },
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Controls the current sink capability of the pin.
                I2CDRIVE: enum(u1) {
                    /// Low drive. Output drive sink is 4 mA. This is sufficient for standard and fast mode I2C.
                    LOW = 0x0,
                    /// High drive. Output drive sink is 20 mA. This is needed for Fast Mode Plus I 2C. Refer to the appropriate specific device data sheet for details.
                    HIGH = 0x1,
                },
                /// Configures I2C features for standard mode, fast mode, and Fast Mode Plus operation.
                I2CFILTER: enum(u1) {
                    /// Enabled. I2C 50 ns glitch filter enabled.
                    ENABLED = 0x0,
                    /// Disabled. I2C 50 ns glitch filter disabled.
                    DISABLED = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_14
            PIO014: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                reserved6: u2,
                /// Controls slew rate of I2C pad.
                I2CSLEW: enum(u1) {
                    /// I2C mode.
                    I2C_MODE = 0x0,
                    /// GPIO mode.
                    GPIO_MODE = 0x1,
                },
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Controls the current sink capability of the pin.
                I2CDRIVE: enum(u1) {
                    /// Low drive. Output drive sink is 4 mA. This is sufficient for standard and fast mode I2C.
                    LOW = 0x0,
                    /// High drive. Output drive sink is 20 mA. This is needed for Fast Mode Plus I 2C. Refer to the appropriate specific device data sheet for details.
                    HIGH = 0x1,
                },
                /// Configures I2C features for standard mode, fast mode, and Fast Mode Plus operation.
                I2CFILTER: enum(u1) {
                    /// Enabled. I2C 50 ns glitch filter enabled.
                    ENABLED = 0x0,
                    /// Disabled. I2C 50 ns glitch filter disabled.
                    DISABLED = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_15
            PIO015: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_16
            PIO016: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_17
            PIO017: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_18
            PIO018: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_19
            PIO019: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_20
            PIO020: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_21
            PIO021: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_22
            PIO022: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_23
            PIO023: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_24
            PIO024: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_25
            PIO025: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_26
            PIO026: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_27
            PIO027: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_28
            PIO028: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_29
            PIO029: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_30
            PIO030: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 0 pins PIO0_31
            PIO031: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_0
            PIO10: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_1
            PIO11: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_2
            PIO12: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_3
            PIO13: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_4
            PIO14: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_5
            PIO15: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_6
            PIO16: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_7
            PIO17: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_8
            PIO18: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_9
            PIO19: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_10
            PIO110: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_11
            PIO111: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_12
            PIO112: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_13
            PIO113: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_14
            PIO114: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_15
            PIO115: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_16
            PIO116: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_17
            PIO117: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_18
            PIO118: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_19
            PIO119: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_20
            PIO120: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_21
            PIO121: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_22
            PIO122: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_23
            PIO123: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_24
            PIO124: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_25
            PIO125: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_26
            PIO126: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_27
            PIO127: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_28
            PIO128: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_29
            PIO129: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_30
            PIO130: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 1 pins PIO1_31
            PIO131: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_0
            PIO20: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_1
            PIO21: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_2
            PIO22: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_3
            PIO23: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_4
            PIO24: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_5
            PIO25: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_6
            PIO26: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_7
            PIO27: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_8
            PIO28: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_9
            PIO29: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_10
            PIO210: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_11
            PIO211: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_12
            PIO212: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_13
            PIO213: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_14
            PIO214: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_15
            PIO215: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_16
            PIO216: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_17
            PIO217: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_18
            PIO218: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_19
            PIO219: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_20
            PIO220: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_21
            PIO221: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_22
            PIO222: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_23
            PIO223: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_24
            PIO224: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_25
            PIO225: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_26
            PIO226: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_27
            PIO227: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_28
            PIO228: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_29
            PIO229: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_30
            PIO230: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 2 pins PIO2_31
            PIO231: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_0
            PIO30: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_1
            PIO31: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_2
            PIO32: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_3
            PIO33: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_4
            PIO34: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_5
            PIO35: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_6
            PIO36: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_7
            PIO37: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_8
            PIO38: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_9
            PIO39: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_10
            PIO310: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_11
            PIO311: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_12
            PIO312: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_13
            PIO313: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_14
            PIO314: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_15
            PIO315: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_16
            PIO316: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_17
            PIO317: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_18
            PIO318: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_19
            PIO319: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_20
            PIO320: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_21
            PIO321: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_22
            PIO322: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                reserved11: u1,
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_23
            PIO323: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                reserved6: u2,
                /// Controls slew rate of I2C pad.
                I2CSLEW: enum(u1) {
                    /// I2C mode.
                    I2C_MODE = 0x0,
                    /// GPIO mode.
                    GPIO_MODE = 0x1,
                },
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Controls the current sink capability of the pin.
                I2CDRIVE: enum(u1) {
                    /// Low drive. Output drive sink is 4 mA. This is sufficient for standard and fast mode I2C.
                    LOW = 0x0,
                    /// High drive. Output drive sink is 20 mA. This is needed for Fast Mode Plus I 2C. Refer to the appropriate specific device data sheet for details.
                    HIGH = 0x1,
                },
                /// Configures I2C features for standard mode, fast mode, and Fast Mode Plus operation.
                I2CFILTER: enum(u1) {
                    /// Enabled. I2C 50 ns glitch filter enabled.
                    ENABLED = 0x0,
                    /// Disabled. I2C 50 ns glitch filter disabled.
                    DISABLED = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_24
            PIO324: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                reserved6: u2,
                /// Controls slew rate of I2C pad.
                I2CSLEW: enum(u1) {
                    /// I2C mode.
                    I2C_MODE = 0x0,
                    /// GPIO mode.
                    GPIO_MODE = 0x1,
                },
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Controls the current sink capability of the pin.
                I2CDRIVE: enum(u1) {
                    /// Low drive. Output drive sink is 4 mA. This is sufficient for standard and fast mode I2C.
                    LOW = 0x0,
                    /// High drive. Output drive sink is 20 mA. This is needed for Fast Mode Plus I 2C. Refer to the appropriate specific device data sheet for details.
                    HIGH = 0x1,
                },
                /// Configures I2C features for standard mode, fast mode, and Fast Mode Plus operation.
                I2CFILTER: enum(u1) {
                    /// Enabled. I2C 50 ns glitch filter enabled.
                    ENABLED = 0x0,
                    /// Disabled. I2C 50 ns glitch filter disabled.
                    DISABLED = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_25
            PIO325: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_26
            PIO326: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_27
            PIO327: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_28
            PIO328: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_29
            PIO329: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_30
            PIO330: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 3 pins PIO3_31
            PIO331: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_0
            PIO40: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_1
            PIO41: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_2
            PIO42: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_3
            PIO43: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_4
            PIO44: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_5
            PIO45: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_6
            PIO46: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_7
            PIO47: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_8
            PIO48: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_9
            PIO49: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_10
            PIO410: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_11
            PIO411: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_12
            PIO412: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_13
            PIO413: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_14
            PIO414: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_15
            PIO415: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_16
            PIO416: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_17
            PIO417: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_18
            PIO418: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_19
            PIO419: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_20
            PIO420: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_21
            PIO421: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_22
            PIO422: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_23
            PIO423: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_24
            PIO424: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_25
            PIO425: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_26
            PIO426: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_27
            PIO427: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_28
            PIO428: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_29
            PIO429: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_30
            PIO430: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 4 pins PIO4_31
            PIO431: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_0
            PIO50: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_1
            PIO51: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_2
            PIO52: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_3
            PIO53: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_4
            PIO54: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_5
            PIO55: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_6
            PIO56: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_7
            PIO57: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_8
            PIO58: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_9
            PIO59: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_10
            PIO510: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_11
            PIO511: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_12
            PIO512: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_13
            PIO513: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_14
            PIO514: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_15
            PIO515: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_16
            PIO516: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_17
            PIO517: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_18
            PIO518: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_19
            PIO519: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_20
            PIO520: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_21
            PIO521: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_22
            PIO522: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_23
            PIO523: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_24
            PIO524: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_25
            PIO525: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_26
            PIO526: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_27
            PIO527: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_28
            PIO528: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_29
            PIO529: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_30
            PIO530: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
            /// Digital I/O control for port 5 pins PIO5_31
            PIO531: mmio.Mmio(packed struct(u32) {
                /// Selects pin function.
                FUNC: enum(u4) {
                    /// Alternative connection 0.
                    ALT0 = 0x0,
                    /// Alternative connection 1.
                    ALT1 = 0x1,
                    /// Alternative connection 2.
                    ALT2 = 0x2,
                    /// Alternative connection 3.
                    ALT3 = 0x3,
                    /// Alternative connection 4.
                    ALT4 = 0x4,
                    /// Alternative connection 5.
                    ALT5 = 0x5,
                    /// Alternative connection 6.
                    ALT6 = 0x6,
                    /// Alternative connection 7.
                    ALT7 = 0x7,
                    _,
                },
                /// Selects function mode (on-chip pull-up/pull-down resistor control).
                MODE: enum(u2) {
                    /// Inactive. Inactive (no pull-down/pull-up resistor enabled).
                    INACTIVE = 0x0,
                    /// Pull-down. Pull-down resistor enabled.
                    PULL_DOWN = 0x1,
                    /// Pull-up. Pull-up resistor enabled.
                    PULL_UP = 0x2,
                    /// Repeater. Repeater mode.
                    REPEATER = 0x3,
                },
                reserved7: u1,
                /// Input polarity.
                INVERT: enum(u1) {
                    /// Disabled. Input function is not inverted.
                    DISABLED = 0x0,
                    /// Enabled. Input is function inverted.
                    ENABLED = 0x1,
                },
                /// Select Analog/Digital mode.
                DIGIMODE: enum(u1) {
                    /// Analog mode.
                    ANALOG = 0x0,
                    /// Digital mode.
                    DIGITAL = 0x1,
                },
                /// Controls input glitch filter.
                FILTEROFF: enum(u1) {
                    /// Filter enabled. Noise pulses below approximately 10 ns are filtered out.
                    ENABLED = 0x0,
                    /// Filter disabled. No input filtering is done.
                    DISABLED = 0x1,
                },
                /// Driver slew rate.
                SLEW: enum(u1) {
                    /// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
                    STANDARD = 0x0,
                    /// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
                    FAST = 0x1,
                },
                /// Controls open-drain mode.
                OD: enum(u1) {
                    /// Normal. Normal push-pull output
                    NORMAL = 0x0,
                    /// Open-drain. Simulated open-drain output (high drive disabled).
                    OPEN_DRAIN = 0x1,
                },
                padding: u20,
            }),
        };

        /// Instrumentation Trace Macrocell Registers
        pub const ITM = extern struct {
            /// Stimulus Port Register 0 (for reading)
            STIM0_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 1 (for reading)
            STIM1_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 2 (for reading)
            STIM2_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 3 (for reading)
            STIM3_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 4 (for reading)
            STIM4_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 5 (for reading)
            STIM5_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 6 (for reading)
            STIM6_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 7 (for reading)
            STIM7_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 8 (for reading)
            STIM8_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 9 (for reading)
            STIM9_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 10 (for reading)
            STIM10_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 11 (for reading)
            STIM11_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 12 (for reading)
            STIM12_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 13 (for reading)
            STIM13_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 14 (for reading)
            STIM14_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 15 (for reading)
            STIM15_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 16 (for reading)
            STIM16_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 17 (for reading)
            STIM17_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 18 (for reading)
            STIM18_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 19 (for reading)
            STIM19_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 20 (for reading)
            STIM20_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 21 (for reading)
            STIM21_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 22 (for reading)
            STIM22_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 23 (for reading)
            STIM23_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 24 (for reading)
            STIM24_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 25 (for reading)
            STIM25_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 26 (for reading)
            STIM26_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 27 (for reading)
            STIM27_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 28 (for reading)
            STIM28_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 29 (for reading)
            STIM29_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 30 (for reading)
            STIM30_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            /// Stimulus Port Register 31 (for reading)
            STIM31_READ: mmio.Mmio(packed struct(u32) {
                /// no description available
                FIFOREADY: u1,
                padding: u31,
            }),
            reserved3584: [3456]u8,
            /// Trace Enable Register
            TER: mmio.Mmio(packed struct(u32) {
                /// For bit STIMENA[n], in register ITM_TERx: 0 = Stimulus port (32x + n) disabled 1 = Stimulus port (32x + n) enabled
                STIMENA: u32,
            }),
            reserved3648: [60]u8,
            /// Trace Privilege Register
            TPR: mmio.Mmio(packed struct(u32) {
                /// Bit mask to enable tracing on ITM stimulus ports: Bit [0] = stimulus port [7:0] Bit [1] = stimulus port [15:8] Bit [2] = stimulus port [23:16] Bit [3] = stimulus port [31:24]
                PRIVMASK: u4,
                padding: u28,
            }),
            reserved3712: [60]u8,
            /// Trace Control Register
            TCR: mmio.Mmio(packed struct(u32) {
                /// no description available
                ITMENA: enum(u1) {
                    /// Disabled.
                    ITMENA_0 = 0x0,
                    /// Enabled.
                    ITMENA_1 = 0x1,
                },
                /// no description available
                TSENA: enum(u1) {
                    /// Disabled.
                    TSENA_0 = 0x0,
                    /// Enabled.
                    TSENA_1 = 0x1,
                },
                /// no description available
                SYNCENA: enum(u1) {
                    /// Disabled.
                    SYNCENA_0 = 0x0,
                    /// Enabled.
                    SYNCENA_1 = 0x1,
                },
                /// no description available
                TXENA: enum(u1) {
                    /// Disabled.
                    TXENA_0 = 0x0,
                    /// Enabled.
                    TXENA_1 = 0x1,
                },
                /// no description available
                SWOENA: enum(u1) {
                    /// Timestamp counter uses the processor system clock.
                    SWOENA_0 = 0x0,
                    /// Timestamp counter uses asynchronous clock from the TPIU interface.
                    SWOENA_1 = 0x1,
                },
                reserved8: u3,
                /// Local timestamp prescaler, used with the trace packet reference clock.
                TSPrescale: enum(u2) {
                    /// No prescaling.
                    TSPrescale_0 = 0x0,
                    /// Divide by 4.
                    TSPrescale_1 = 0x1,
                    /// Divide by 16.
                    TSPrescale_2 = 0x2,
                    /// Divide by 64.
                    TSPrescale_3 = 0x3,
                },
                /// Global timestamp frequency. Defines how often the ITM generates a global timestamp, based on the global timestamp clock frequency, or disables generation of global timestamps.
                GTSFREQ: enum(u2) {
                    /// Disable generation of global timestamps.
                    GTSFREQ_0 = 0x0,
                    /// Generate timestamp request whenever the ITM detects a change in global timestamp counter bits [47:7]. This is approximately every 128 cycles.
                    GTSFREQ_1 = 0x1,
                    /// Generate timestamp request whenever the ITM detects a change in global timestamp counter bits [47:13]. This is approximately every 8192 cycles.
                    GTSFREQ_2 = 0x2,
                    /// Generate a timestamp after every packet, if the output FIFO is empty.
                    GTSFREQ_3 = 0x3,
                },
                reserved16: u4,
                /// Identifier for multi-source trace stream formatting. If multi-source trace is in use, the debugger must write a non-zero value to this field.
                TraceBusID: u7,
                /// Indicates whether the ITM is currently processing events: 0: ITM is not processing any events. 1: ITM events present and being drained.
                BUSY: enum(u1) {
                    /// ITM is not processing any events.
                    BUSY_0 = 0x0,
                    /// ITM events present and beeing drained.
                    BUSY_1 = 0x1,
                },
                padding: u8,
            }),
            reserved4016: [300]u8,
            /// Lock Access Register
            LAR: mmio.Mmio(packed struct(u32) {
                /// Write Access Code. A write of 0xC5ACCE55 enables further write access to this device. An invalid write will have the affect of removing write access.
                WriteAccessCode: u32,
            }),
            /// Lock Status Register
            LSR: mmio.Mmio(packed struct(u32) {
                /// Lock mechanism is implemented. This bit always reads 1.
                IMP: u1,
                /// Lock Status. This bit is HIGH when the device is locked, and LOW when unlocked.
                STATUS: u1,
                /// Access Lock Register size. This bit reads 0 to indicate a 32-bit register is present.
                s8BIT: u1,
                padding: u29,
            }),
            reserved4048: [24]u8,
            /// Peripheral Identification Register 4.
            PID4: mmio.Mmio(packed struct(u32) {
                /// JEP106 continuation code.
                JEP106: u4,
                /// 4KB Count
                c4KB: u4,
                padding: u24,
            }),
            /// Peripheral Identification Register 5.
            PID5: u32,
            /// Peripheral Identification Register 6.
            PID6: u32,
            /// Peripheral Identification Register 7.
            PID7: u32,
            /// Peripheral Identification Register 0.
            PID0: mmio.Mmio(packed struct(u32) {
                /// Part Number [7:0]
                PartNumber: u8,
                padding: u24,
            }),
            /// Peripheral Identification Register 1.
            PID1: mmio.Mmio(packed struct(u32) {
                /// Part Number [11:8]
                PartNumber: u4,
                /// JEP106 identity code [3:0]
                JEP106_identity_code: u4,
                padding: u24,
            }),
            /// Peripheral Identification Register 2.
            PID2: mmio.Mmio(packed struct(u32) {
                /// JEP106 identity code [6:4]
                JEP106_identity_code: u3,
                reserved4: u1,
                /// Revision
                Revision: u4,
                padding: u24,
            }),
            /// Peripheral Identification Register 3.
            PID3: mmio.Mmio(packed struct(u32) {
                /// Customer Modified.
                CustomerModified: u4,
                /// RevAnd
                RevAnd: u4,
                padding: u24,
            }),
            /// Component Identification Register 0.
            CID0: mmio.Mmio(packed struct(u32) {
                /// Preamble
                Preamble: u8,
                padding: u24,
            }),
            /// Component Identification Register 1.
            CID1: mmio.Mmio(packed struct(u32) {
                /// Preamble
                Preamble: u4,
                /// Component class
                ComponentClass: enum(u4) {
                    /// ROM table.
                    ComponentClass_1 = 0x1,
                    /// CoreSight component.
                    ComponentClass_9 = 0x9,
                    /// PrimeCell of system component with no standardized register layout, for backward compatibility.
                    ComponentClass_15 = 0xf,
                    _,
                },
                padding: u24,
            }),
            /// Component Identification Register 2.
            CID2: mmio.Mmio(packed struct(u32) {
                /// Preamble
                Preamble: u8,
                padding: u24,
            }),
            /// Component Identification Register 3.
            CID3: mmio.Mmio(packed struct(u32) {
                /// Preamble
                Preamble: u8,
                padding: u24,
            }),
        };

        /// LPC5460x LCD controller
        pub const LCD = extern struct {
            /// Horizontal Timing Control register
            TIMH: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Pixels-per-line.
                PPL: u6,
                /// Horizontal synchronization pulse width.
                HSW: u8,
                /// Horizontal front porch.
                HFP: u8,
                /// Horizontal back porch.
                HBP: u8,
            }),
            /// Vertical Timing Control register
            TIMV: mmio.Mmio(packed struct(u32) {
                /// Lines per panel.
                LPP: u10,
                /// Vertical synchronization pulse width.
                VSW: u6,
                /// Vertical front porch.
                VFP: u8,
                /// Vertical back porch.
                VBP: u8,
            }),
            /// Clock and Signal Polarity Control register
            POL: mmio.Mmio(packed struct(u32) {
                /// Lower five bits of panel clock divisor.
                PCD_LO: u5,
                reserved6: u1,
                /// AC bias pin frequency.
                ACB: u5,
                /// Invert vertical synchronization.
                IVS: u1,
                /// Invert horizontal synchronization.
                IHS: u1,
                /// Invert panel clock.
                IPC: u1,
                /// Invert output enable.
                IOE: u1,
                reserved16: u1,
                /// Clocks per line.
                CPL: u10,
                /// Bypass panel clock divider.
                BCD: u1,
                /// Upper five bits of panel clock divisor.
                PCD_HI: u5,
            }),
            /// Line End Control register
            LE: mmio.Mmio(packed struct(u32) {
                /// Line-end delay.
                LED: u7,
                reserved16: u9,
                /// LCD Line end enable.
                LEE: u1,
                padding: u15,
            }),
            /// Upper Panel Frame Base Address register
            UPBASE: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// LCD upper panel base address.
                LCDUPBASE: u29,
            }),
            /// Lower Panel Frame Base Address register
            LPBASE: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// LCD lower panel base address.
                LCDLPBASE: u29,
            }),
            /// LCD Control register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// LCD enable control bit.
                LCDEN: u1,
                /// LCD bits per pixel.
                LCDBPP: u3,
                /// STN LCD monochrome/color selection.
                LCDBW: u1,
                /// LCD panel TFT type selection.
                LCDTFT: u1,
                /// Monochrome LCD interface width.
                LCDMONO8: u1,
                /// Single or Dual LCD panel selection.
                LCDDUAL: u1,
                /// Color format selection.
                BGR: u1,
                /// Big-endian Byte Order.
                BEBO: u1,
                /// Big-Endian Pixel Ordering.
                BEPO: u1,
                /// LCD power enable.
                LCDPWR: u1,
                /// LCD Vertical Compare Interrupt.
                LCDVCOMP: u2,
                reserved16: u2,
                /// LCD DMA FIFO watermark level.
                WATERMARK: u1,
                padding: u15,
            }),
            /// Interrupt Mask register
            INTMSK: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// FIFO underflow interrupt enable.
                FUFIM: u1,
                /// LCD next base address update interrupt enable.
                LNBUIM: u1,
                /// Vertical compare interrupt enable.
                VCOMPIM: u1,
                /// AHB master error interrupt enable.
                BERIM: u1,
                padding: u27,
            }),
            /// Raw Interrupt Status register
            INTRAW: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// FIFO underflow raw interrupt status.
                FUFRIS: u1,
                /// LCD next address base update raw interrupt status.
                LNBURIS: u1,
                /// Vertical compare raw interrupt status.
                VCOMPRIS: u1,
                /// AHB master bus error raw interrupt status.
                BERRAW: u1,
                padding: u27,
            }),
            /// Masked Interrupt Status register
            INTSTAT: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// FIFO underflow masked interrupt status.
                FUFMIS: u1,
                /// LCD next address base update masked interrupt status.
                LNBUMIS: u1,
                /// Vertical compare masked interrupt status.
                VCOMPMIS: u1,
                /// AHB master bus error masked interrupt status.
                BERMIS: u1,
                padding: u27,
            }),
            /// Interrupt Clear register
            INTCLR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// FIFO underflow interrupt clear.
                FUFIC: u1,
                /// LCD next address base update interrupt clear.
                LNBUIC: u1,
                /// Vertical compare interrupt clear.
                VCOMPIC: u1,
                /// AHB master error interrupt clear.
                BERIC: u1,
                padding: u27,
            }),
            /// Upper Panel Current Address Value register
            UPCURR: mmio.Mmio(packed struct(u32) {
                /// LCD Upper Panel Current Address.
                LCDUPCURR: u32,
            }),
            /// Lower Panel Current Address Value register
            LPCURR: mmio.Mmio(packed struct(u32) {
                /// LCD Lower Panel Current Address.
                LCDLPCURR: u32,
            }),
            reserved512: [460]u8,
            /// 256x16-bit Color Palette registers
            PAL: [128]mmio.Mmio(packed struct(u32) {
                /// Red palette data.
                R04_0: u5,
                /// Green palette data.
                G04_0: u5,
                /// Blue palette data.
                B04_0: u5,
                /// Intensity / unused bit.
                I0: u1,
                /// Red palette data.
                R14_0: u5,
                /// Green palette data.
                G14_0: u5,
                /// Blue palette data.
                B14_0: u5,
                /// Intensity / unused bit.
                I1: u1,
            }),
            reserved2048: [1024]u8,
            /// Cursor Image registers
            CRSR_IMG: [256]mmio.Mmio(packed struct(u32) {
                /// Cursor Image data.
                CRSR_IMG: u32,
            }),
            /// Cursor Control register
            CRSR_CTRL: mmio.Mmio(packed struct(u32) {
                /// Cursor enable.
                CRSRON: u1,
                reserved4: u3,
                /// Cursor image number.
                CRSRNUM1_0: u2,
                padding: u26,
            }),
            /// Cursor Configuration register
            CRSR_CFG: mmio.Mmio(packed struct(u32) {
                /// Cursor size selection.
                CRSRSIZE: u1,
                /// Cursor frame synchronization type.
                FRAMESYNC: u1,
                padding: u30,
            }),
            /// Cursor Palette register 0
            CRSR_PAL0: mmio.Mmio(packed struct(u32) {
                /// Red color component.
                RED: u8,
                /// Green color component.
                GREEN: u8,
                /// Blue color component.
                BLUE: u8,
                padding: u8,
            }),
            /// Cursor Palette register 1
            CRSR_PAL1: mmio.Mmio(packed struct(u32) {
                /// Red color component.
                RED: u8,
                /// Green color component.
                GREEN: u8,
                /// Blue color component.
                BLUE: u8,
                padding: u8,
            }),
            /// Cursor XY Position register
            CRSR_XY: mmio.Mmio(packed struct(u32) {
                /// X ordinate of the cursor origin measured in pixels.
                CRSRX: u10,
                reserved16: u6,
                /// Y ordinate of the cursor origin measured in pixels.
                CRSRY: u10,
                padding: u6,
            }),
            /// Cursor Clip Position register
            CRSR_CLIP: mmio.Mmio(packed struct(u32) {
                /// Cursor clip position for X direction.
                CRSRCLIPX: u6,
                reserved8: u2,
                /// Cursor clip position for Y direction.
                CRSRCLIPY: u6,
                padding: u18,
            }),
            reserved3104: [8]u8,
            /// Cursor Interrupt Mask register
            CRSR_INTMSK: mmio.Mmio(packed struct(u32) {
                /// Cursor interrupt mask.
                CRSRIM: u1,
                padding: u31,
            }),
            /// Cursor Interrupt Clear register
            CRSR_INTCLR: mmio.Mmio(packed struct(u32) {
                /// Cursor interrupt clear.
                CRSRIC: u1,
                padding: u31,
            }),
            /// Cursor Raw Interrupt Status register
            CRSR_INTRAW: mmio.Mmio(packed struct(u32) {
                /// Cursor raw interrupt status.
                CRSRRIS: u1,
                padding: u31,
            }),
            /// Cursor Masked Interrupt Status register
            CRSR_INTSTAT: mmio.Mmio(packed struct(u32) {
                /// Cursor masked interrupt status.
                CRSRMIS: u1,
                padding: u31,
            }),
        };

        /// LPC5411x Multi-Rate Timer (MRT)
        pub const MRT0 = extern struct {
            reserved240: [240]u8,
            /// Module Configuration register. This register provides information about this particular MRT instance, and allows choosing an overall mode for the idle channel feature.
            MODCFG: mmio.Mmio(packed struct(u32) {
                /// Identifies the number of channels in this MRT.(4 channels on this device.)
                NOC: u4,
                /// Identifies the number of timer bits in this MRT. (24 bits wide on this device.)
                NOB: u5,
                reserved31: u22,
                /// Selects the operating mode for the INUSE flags and the IDLE_CH register.
                MULTITASK: enum(u1) {
                    /// Hardware status mode. In this mode, the INUSE(n) flags for all channels are reset.
                    HARDWARE_STATUS_MODE = 0x0,
                    /// Multi-task mode.
                    MULTI_TASK_MODE = 0x1,
                },
            }),
            /// Idle channel register. This register returns the number of the first idle channel.
            IDLE_CH: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// Idle channel. Reading the CHAN bits, returns the lowest idle timer channel. The number is positioned such that it can be used as an offset from the MRT base address in order to access the registers for the allocated channel. If all timer channels are running, CHAN = 0xF. See text above for more details.
                CHAN: u4,
                padding: u24,
            }),
            /// Global interrupt flag register
            IRQ_FLAG: mmio.Mmio(packed struct(u32) {
                /// Monitors the interrupt flag of TIMER0.
                GFLAG0: enum(u1) {
                    /// No pending interrupt. Writing a zero is equivalent to no operation.
                    NO_PENDING_INTERRUPT = 0x0,
                    /// Pending interrupt. The interrupt is pending because TIMER0 has reached the end of the time interval. If the INTEN bit in the CONTROL0 register is also set to 1, the interrupt for timer channel 0 and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request.
                    PENDING_INTERRUPT = 0x1,
                },
                /// Monitors the interrupt flag of TIMER1. See description of channel 0.
                GFLAG1: u1,
                /// Monitors the interrupt flag of TIMER2. See description of channel 0.
                GFLAG2: u1,
                /// Monitors the interrupt flag of TIMER3. See description of channel 0.
                GFLAG3: u1,
                padding: u28,
            }),
        };

        /// Nested Vectored Interrupt Controller
        pub const NVIC = extern struct {
            /// Interrupt Set Enable Register n
            NVICISER0: mmio.Mmio(packed struct(u32) {
                /// Interrupt set enable bits
                SETENA: u32,
            }),
            /// Interrupt Set Enable Register n
            NVICISER1: mmio.Mmio(packed struct(u32) {
                /// Interrupt set enable bits
                SETENA: u32,
            }),
            /// Interrupt Set Enable Register n
            NVICISER2: mmio.Mmio(packed struct(u32) {
                /// Interrupt set enable bits
                SETENA: u32,
            }),
            /// Interrupt Set Enable Register n
            NVICISER3: mmio.Mmio(packed struct(u32) {
                /// Interrupt set enable bits
                SETENA: u32,
            }),
            reserved128: [112]u8,
            /// Interrupt Clear Enable Register n
            NVICICER0: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-enable bits
                CLRENA: u32,
            }),
            /// Interrupt Clear Enable Register n
            NVICICER1: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-enable bits
                CLRENA: u32,
            }),
            /// Interrupt Clear Enable Register n
            NVICICER2: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-enable bits
                CLRENA: u32,
            }),
            /// Interrupt Clear Enable Register n
            NVICICER3: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-enable bits
                CLRENA: u32,
            }),
            reserved256: [112]u8,
            /// Interrupt Set Pending Register n
            NVICISPR0: mmio.Mmio(packed struct(u32) {
                /// Interrupt set-pending bits
                SETPEND: u32,
            }),
            /// Interrupt Set Pending Register n
            NVICISPR1: mmio.Mmio(packed struct(u32) {
                /// Interrupt set-pending bits
                SETPEND: u32,
            }),
            /// Interrupt Set Pending Register n
            NVICISPR2: mmio.Mmio(packed struct(u32) {
                /// Interrupt set-pending bits
                SETPEND: u32,
            }),
            /// Interrupt Set Pending Register n
            NVICISPR3: mmio.Mmio(packed struct(u32) {
                /// Interrupt set-pending bits
                SETPEND: u32,
            }),
            reserved384: [112]u8,
            /// Interrupt Clear Pending Register n
            NVICICPR0: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-pending bits
                CLRPEND: u32,
            }),
            /// Interrupt Clear Pending Register n
            NVICICPR1: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-pending bits
                CLRPEND: u32,
            }),
            /// Interrupt Clear Pending Register n
            NVICICPR2: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-pending bits
                CLRPEND: u32,
            }),
            /// Interrupt Clear Pending Register n
            NVICICPR3: mmio.Mmio(packed struct(u32) {
                /// Interrupt clear-pending bits
                CLRPEND: u32,
            }),
            reserved512: [112]u8,
            /// Interrupt Active bit Register n
            NVICIABR0: mmio.Mmio(packed struct(u32) {
                /// Interrupt active flags
                ACTIVE: u32,
            }),
            /// Interrupt Active bit Register n
            NVICIABR1: mmio.Mmio(packed struct(u32) {
                /// Interrupt active flags
                ACTIVE: u32,
            }),
            /// Interrupt Active bit Register n
            NVICIABR2: mmio.Mmio(packed struct(u32) {
                /// Interrupt active flags
                ACTIVE: u32,
            }),
            /// Interrupt Active bit Register n
            NVICIABR3: mmio.Mmio(packed struct(u32) {
                /// Interrupt active flags
                ACTIVE: u32,
            }),
            reserved768: [240]u8,
            /// Interrupt Priority Register n
            NVICIP0: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 0
                PRI0: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP1: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 1
                PRI1: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP2: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 2
                PRI2: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP3: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 3
                PRI3: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP4: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 4
                PRI4: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP5: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 5
                PRI5: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP6: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 6
                PRI6: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP7: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 7
                PRI7: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP8: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 8
                PRI8: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP9: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 9
                PRI9: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP10: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 10
                PRI10: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP11: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 11
                PRI11: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP12: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 12
                PRI12: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP13: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 13
                PRI13: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP14: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 14
                PRI14: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP15: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 15
                PRI15: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP16: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 16
                PRI16: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP17: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 17
                PRI17: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP18: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 18
                PRI18: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP19: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 19
                PRI19: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP20: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 20
                PRI20: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP21: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 21
                PRI21: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP22: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 22
                PRI22: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP23: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 23
                PRI23: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP24: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 24
                PRI24: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP25: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 25
                PRI25: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP26: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 26
                PRI26: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP27: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 27
                PRI27: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP28: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 28
                PRI28: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP29: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 29
                PRI29: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP30: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 30
                PRI30: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP31: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 31
                PRI31: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP32: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 32
                PRI32: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP33: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 33
                PRI33: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP34: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 34
                PRI34: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP35: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 35
                PRI35: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP36: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 36
                PRI36: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP37: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 37
                PRI37: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP38: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 38
                PRI38: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP39: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 39
                PRI39: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP40: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 40
                PRI40: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP41: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 41
                PRI41: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP42: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 42
                PRI42: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP43: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 43
                PRI43: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP44: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 44
                PRI44: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP45: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 45
                PRI45: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP46: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 46
                PRI46: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP47: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 47
                PRI47: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP48: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 48
                PRI48: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP49: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 49
                PRI49: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP50: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 50
                PRI50: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP51: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 51
                PRI51: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP52: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 52
                PRI52: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP53: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 53
                PRI53: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP54: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 54
                PRI54: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP55: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 55
                PRI55: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP56: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 56
                PRI56: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP57: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 57
                PRI57: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP58: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 58
                PRI58: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP59: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 59
                PRI59: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP60: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 60
                PRI60: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP61: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 61
                PRI61: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP62: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 62
                PRI62: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP63: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 63
                PRI63: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP64: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 64
                PRI64: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP65: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 65
                PRI65: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP66: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 66
                PRI66: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP67: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 67
                PRI67: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP68: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 68
                PRI68: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP69: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 69
                PRI69: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP70: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 70
                PRI70: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP71: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 71
                PRI71: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP72: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 72
                PRI72: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP73: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 73
                PRI73: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP74: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 74
                PRI74: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP75: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 75
                PRI75: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP76: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 76
                PRI76: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP77: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 77
                PRI77: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP78: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 78
                PRI78: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP79: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 79
                PRI79: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP80: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 80
                PRI80: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP81: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 81
                PRI81: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP82: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 82
                PRI82: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP83: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 83
                PRI83: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP84: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 84
                PRI84: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP85: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 85
                PRI85: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP86: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 86
                PRI86: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP87: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 87
                PRI87: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP88: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 88
                PRI88: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP89: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 89
                PRI89: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP90: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 90
                PRI90: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP91: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 91
                PRI91: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP92: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 92
                PRI92: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP93: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 93
                PRI93: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP94: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 94
                PRI94: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP95: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 95
                PRI95: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP96: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 96
                PRI96: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP97: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 97
                PRI97: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP98: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 98
                PRI98: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP99: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 99
                PRI99: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP100: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 100
                PRI100: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP101: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 101
                PRI101: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP102: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 102
                PRI102: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP103: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 103
                PRI103: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP104: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 104
                PRI104: u8,
            }),
            /// Interrupt Priority Register n
            NVICIP105: mmio.Mmio(packed struct(u8) {
                /// Priority of interrupt 105
                PRI105: u8,
            }),
            reserved3584: [2710]u8,
            /// Software Trigger Interrupt Register
            NVICSTIR: mmio.Mmio(packed struct(u32) {
                /// Interrupt ID of the interrupt to trigger, in the range 0-239. For example, a value of 0x03 specifies interrupt IRQ3.
                INTID: u9,
                padding: u23,
            }),
        };

        /// This is the description of component otpc It is an eFUSE OTP (One Time Programmable memory) controller with APB bus interface. More details will follow.
        pub const OTPC = extern struct {
            reserved16: [16]u8,
            /// Register for reading the AES key.
            AESKEY: [8]mmio.Mmio(packed struct(u32) {
                /// AES key.
                KEY: u32,
            }),
            /// ECRP options.
            ECRP: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// Disable or enable CRP mass erase.
                CRP_MASS_ERASE_DISABLE: u1,
                /// This bit controls the ability to enable checking for ECRP in IAP functions.
                IAP_PROTECTION_ENABLE: u1,
                /// This bit controls the ability to enter ISP mode using the ISP pin.
                CRP_ISP_DISABLE_PIN: u1,
                /// This bit controls the ability to re-invoke ISP using IAP routines.
                CRP_ISP_DISABLE_IAP: u1,
                reserved9: u1,
                /// This bit controls how 0 is treated when read as a ECRP value..
                CRP_ALLOW_ZERO: u1,
                reserved31: u21,
                /// 0 => Enable SWD/JTAG; 1 => Disable SWD/JTAG..
                JTAG_DISABLE: u1,
            }),
            reserved56: [4]u8,
            /// User application specific options.
            USER0: mmio.Mmio(packed struct(u32) {
                /// User application specific option.
                USER0: u32,
            }),
            /// User application specific options.
            USER1: mmio.Mmio(packed struct(u32) {
                /// User application specific option.
                USER1: u32,
            }),
        };

        /// LPC5411x Pin interrupt and pattern match (PINT)
        pub const PINT = extern struct {
            /// Pin Interrupt Mode register
            ISEL: mmio.Mmio(packed struct(u32) {
                /// Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive
                PMODE: u8,
                padding: u24,
            }),
            /// Pin interrupt level or rising edge interrupt enable register
            IENR: mmio.Mmio(packed struct(u32) {
                /// Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.
                ENRL: u8,
                padding: u24,
            }),
            /// Pin interrupt level or rising edge interrupt set register
            SIENR: mmio.Mmio(packed struct(u32) {
                /// Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.
                SETENRL: u8,
                padding: u24,
            }),
            /// Pin interrupt level (rising edge interrupt) clear register
            CIENR: mmio.Mmio(packed struct(u32) {
                /// Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.
                CENRL: u8,
                padding: u24,
            }),
            /// Pin interrupt active level or falling edge interrupt enable register
            IENF: mmio.Mmio(packed struct(u32) {
                /// Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.
                ENAF: u8,
                padding: u24,
            }),
            /// Pin interrupt active level or falling edge interrupt set register
            SIENF: mmio.Mmio(packed struct(u32) {
                /// Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.
                SETENAF: u8,
                padding: u24,
            }),
            /// Pin interrupt active level or falling edge interrupt clear register
            CIENF: mmio.Mmio(packed struct(u32) {
                /// Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.
                CENAF: u8,
                padding: u24,
            }),
            /// Pin interrupt rising edge register
            RISE: mmio.Mmio(packed struct(u32) {
                /// Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.
                RDET: u8,
                padding: u24,
            }),
            /// Pin interrupt falling edge register
            FALL: mmio.Mmio(packed struct(u32) {
                /// Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.
                FDET: u8,
                padding: u24,
            }),
            /// Pin interrupt status register
            IST: mmio.Mmio(packed struct(u32) {
                /// Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).
                PSTAT: u8,
                padding: u24,
            }),
            /// Pattern match interrupt control register
            PMCTRL: mmio.Mmio(packed struct(u32) {
                /// Specifies whether the 8 pin interrupts are controlled by the pin interrupt function or by the pattern match function.
                SEL_PMATCH: enum(u1) {
                    /// Pin interrupt. Interrupts are driven in response to the standard pin interrupt function.
                    PIN_INTERRUPT = 0x0,
                    /// Pattern match. Interrupts are driven in response to pattern matches.
                    PATTERN_MATCH = 0x1,
                },
                /// Enables the RXEV output to the CPU and/or to a GPIO output when the specified boolean expression evaluates to true.
                ENA_RXEV: enum(u1) {
                    /// Disabled. RXEV output to the CPU is disabled.
                    DISABLED = 0x0,
                    /// Enabled. RXEV output to the CPU is enabled.
                    ENABLED = 0x1,
                },
                reserved24: u22,
                /// This field displays the current state of pattern matches. A 1 in any bit of this field indicates that the corresponding product term is matched by the current state of the appropriate inputs.
                PMAT: u8,
            }),
            /// Pattern match interrupt bit-slice source register
            PMSRC: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                /// Selects the input source for bit slice 0
                SRC0: enum(u3) {
                    /// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 0.
                    INPUT0 = 0x0,
                    /// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 0.
                    INPUT1 = 0x1,
                    /// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 0.
                    INPUT2 = 0x2,
                    /// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 0.
                    INPUT3 = 0x3,
                    /// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 0.
                    INPUT4 = 0x4,
                    /// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 0.
                    INPUT5 = 0x5,
                    /// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 0.
                    INPUT6 = 0x6,
                    /// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 0.
                    INPUT7 = 0x7,
                },
                /// Selects the input source for bit slice 1
                SRC1: enum(u3) {
                    /// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 1.
                    INPUT0 = 0x0,
                    /// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 1.
                    INPUT1 = 0x1,
                    /// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 1.
                    INPUT2 = 0x2,
                    /// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 1.
                    INPUT3 = 0x3,
                    /// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 1.
                    INPUT4 = 0x4,
                    /// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 1.
                    INPUT5 = 0x5,
                    /// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 1.
                    INPUT6 = 0x6,
                    /// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 1.
                    INPUT7 = 0x7,
                },
                /// Selects the input source for bit slice 2
                SRC2: enum(u3) {
                    /// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 2.
                    INPUT0 = 0x0,
                    /// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 2.
                    INPUT1 = 0x1,
                    /// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 2.
                    INPUT2 = 0x2,
                    /// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 2.
                    INPUT3 = 0x3,
                    /// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 2.
                    INPUT4 = 0x4,
                    /// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 2.
                    INPUT5 = 0x5,
                    /// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 2.
                    INPUT6 = 0x6,
                    /// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 2.
                    INPUT7 = 0x7,
                },
                /// Selects the input source for bit slice 3
                SRC3: enum(u3) {
                    /// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 3.
                    INPUT0 = 0x0,
                    /// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 3.
                    INPUT1 = 0x1,
                    /// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 3.
                    INPUT2 = 0x2,
                    /// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 3.
                    INPUT3 = 0x3,
                    /// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 3.
                    INPUT4 = 0x4,
                    /// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 3.
                    INPUT5 = 0x5,
                    /// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 3.
                    INPUT6 = 0x6,
                    /// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 3.
                    INPUT7 = 0x7,
                },
                /// Selects the input source for bit slice 4
                SRC4: enum(u3) {
                    /// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 4.
                    INPUT0 = 0x0,
                    /// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 4.
                    INPUT1 = 0x1,
                    /// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 4.
                    INPUT2 = 0x2,
                    /// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 4.
                    INPUT3 = 0x3,
                    /// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 4.
                    INPUT4 = 0x4,
                    /// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 4.
                    INPUT5 = 0x5,
                    /// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 4.
                    INPUT6 = 0x6,
                    /// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 4.
                    INPUT7 = 0x7,
                },
                /// Selects the input source for bit slice 5
                SRC5: enum(u3) {
                    /// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 5.
                    INPUT0 = 0x0,
                    /// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 5.
                    INPUT1 = 0x1,
                    /// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 5.
                    INPUT2 = 0x2,
                    /// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 5.
                    INPUT3 = 0x3,
                    /// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 5.
                    INPUT4 = 0x4,
                    /// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 5.
                    INPUT5 = 0x5,
                    /// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 5.
                    INPUT6 = 0x6,
                    /// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 5.
                    INPUT7 = 0x7,
                },
                /// Selects the input source for bit slice 6
                SRC6: enum(u3) {
                    /// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 6.
                    INPUT0 = 0x0,
                    /// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 6.
                    INPUT1 = 0x1,
                    /// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 6.
                    INPUT2 = 0x2,
                    /// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 6.
                    INPUT3 = 0x3,
                    /// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 6.
                    INPUT4 = 0x4,
                    /// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 6.
                    INPUT5 = 0x5,
                    /// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 6.
                    INPUT6 = 0x6,
                    /// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 6.
                    INPUT7 = 0x7,
                },
                /// Selects the input source for bit slice 7
                SRC7: enum(u3) {
                    /// Input 0. Selects the pin selected in the PINTSEL0 register as the source to bit slice 7.
                    INPUT0 = 0x0,
                    /// Input 1. Selects the pin selected in the PINTSEL1 register as the source to bit slice 7.
                    INPUT1 = 0x1,
                    /// Input 2. Selects the pin selected in the PINTSEL2 register as the source to bit slice 7.
                    INPUT2 = 0x2,
                    /// Input 3. Selects the pin selected in the PINTSEL3 register as the source to bit slice 7.
                    INPUT3 = 0x3,
                    /// Input 4. Selects the pin selected in the PINTSEL4 register as the source to bit slice 7.
                    INPUT4 = 0x4,
                    /// Input 5. Selects the pin selected in the PINTSEL5 register as the source to bit slice 7.
                    INPUT5 = 0x5,
                    /// Input 6. Selects the pin selected in the PINTSEL6 register as the source to bit slice 7.
                    INPUT6 = 0x6,
                    /// Input 7. Selects the pin selected in the PINTSEL7 register as the source to bit slice 7.
                    INPUT7 = 0x7,
                },
            }),
            /// Pattern match interrupt bit slice configuration register
            PMCFG: mmio.Mmio(packed struct(u32) {
                /// Determines whether slice 0 is an endpoint.
                PROD_ENDPTS0: enum(u1) {
                    /// No effect. Slice 0 is not an endpoint.
                    NO_EFFECT = 0x0,
                    /// endpoint. Slice 0 is the endpoint of a product term (minterm). Pin interrupt 0 in the NVIC is raised if the minterm evaluates as true.
                    ENDPOINT = 0x1,
                },
                /// Determines whether slice 1 is an endpoint.
                PROD_ENDPTS1: enum(u1) {
                    /// No effect. Slice 1 is not an endpoint.
                    NO_EFFECT = 0x0,
                    /// endpoint. Slice 1 is the endpoint of a product term (minterm). Pin interrupt 1 in the NVIC is raised if the minterm evaluates as true.
                    ENDPOINT = 0x1,
                },
                /// Determines whether slice 2 is an endpoint.
                PROD_ENDPTS2: enum(u1) {
                    /// No effect. Slice 2 is not an endpoint.
                    NO_EFFECT = 0x0,
                    /// endpoint. Slice 2 is the endpoint of a product term (minterm). Pin interrupt 2 in the NVIC is raised if the minterm evaluates as true.
                    ENDPOINT = 0x1,
                },
                /// Determines whether slice 3 is an endpoint.
                PROD_ENDPTS3: enum(u1) {
                    /// No effect. Slice 3 is not an endpoint.
                    NO_EFFECT = 0x0,
                    /// endpoint. Slice 3 is the endpoint of a product term (minterm). Pin interrupt 3 in the NVIC is raised if the minterm evaluates as true.
                    ENDPOINT = 0x1,
                },
                /// Determines whether slice 4 is an endpoint.
                PROD_ENDPTS4: enum(u1) {
                    /// No effect. Slice 4 is not an endpoint.
                    NO_EFFECT = 0x0,
                    /// endpoint. Slice 4 is the endpoint of a product term (minterm). Pin interrupt 4 in the NVIC is raised if the minterm evaluates as true.
                    ENDPOINT = 0x1,
                },
                /// Determines whether slice 5 is an endpoint.
                PROD_ENDPTS5: enum(u1) {
                    /// No effect. Slice 5 is not an endpoint.
                    NO_EFFECT = 0x0,
                    /// endpoint. Slice 5 is the endpoint of a product term (minterm). Pin interrupt 5 in the NVIC is raised if the minterm evaluates as true.
                    ENDPOINT = 0x1,
                },
                /// Determines whether slice 6 is an endpoint.
                PROD_ENDPTS6: enum(u1) {
                    /// No effect. Slice 6 is not an endpoint.
                    NO_EFFECT = 0x0,
                    /// endpoint. Slice 6 is the endpoint of a product term (minterm). Pin interrupt 6 in the NVIC is raised if the minterm evaluates as true.
                    ENDPOINT = 0x1,
                },
                reserved8: u1,
                /// Specifies the match contribution condition for bit slice 0.
                CFG0: enum(u3) {
                    /// Constant HIGH. This bit slice always contributes to a product term match.
                    CONSTANT_HIGH = 0x0,
                    /// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_EDGE = 0x1,
                    /// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_FALLING_EDGE = 0x2,
                    /// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_FALLING_EDGE = 0x3,
                    /// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
                    HIGH_LEVEL = 0x4,
                    /// Low level. Match occurs when there is a low level on the specified input.
                    LOW_LEVEL = 0x5,
                    /// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
                    CONSTANT_ZERO = 0x6,
                    /// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
                    EVENT = 0x7,
                },
                /// Specifies the match contribution condition for bit slice 1.
                CFG1: enum(u3) {
                    /// Constant HIGH. This bit slice always contributes to a product term match.
                    CONSTANT_HIGH = 0x0,
                    /// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_EDGE = 0x1,
                    /// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_FALLING_EDGE = 0x2,
                    /// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_FALLING_EDGE = 0x3,
                    /// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
                    HIGH_LEVEL = 0x4,
                    /// Low level. Match occurs when there is a low level on the specified input.
                    LOW_LEVEL = 0x5,
                    /// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
                    CONSTANT_ZERO = 0x6,
                    /// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
                    EVENT = 0x7,
                },
                /// Specifies the match contribution condition for bit slice 2.
                CFG2: enum(u3) {
                    /// Constant HIGH. This bit slice always contributes to a product term match.
                    CONSTANT_HIGH = 0x0,
                    /// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_EDGE = 0x1,
                    /// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_FALLING_EDGE = 0x2,
                    /// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_FALLING_EDGE = 0x3,
                    /// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
                    HIGH_LEVEL = 0x4,
                    /// Low level. Match occurs when there is a low level on the specified input.
                    LOW_LEVEL = 0x5,
                    /// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
                    CONSTANT_ZERO = 0x6,
                    /// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
                    EVENT = 0x7,
                },
                /// Specifies the match contribution condition for bit slice 3.
                CFG3: enum(u3) {
                    /// Constant HIGH. This bit slice always contributes to a product term match.
                    CONSTANT_HIGH = 0x0,
                    /// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_EDGE = 0x1,
                    /// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_FALLING_EDGE = 0x2,
                    /// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_FALLING_EDGE = 0x3,
                    /// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
                    HIGH_LEVEL = 0x4,
                    /// Low level. Match occurs when there is a low level on the specified input.
                    LOW_LEVEL = 0x5,
                    /// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
                    CONSTANT_ZERO = 0x6,
                    /// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
                    EVENT = 0x7,
                },
                /// Specifies the match contribution condition for bit slice 4.
                CFG4: enum(u3) {
                    /// Constant HIGH. This bit slice always contributes to a product term match.
                    CONSTANT_HIGH = 0x0,
                    /// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_EDGE = 0x1,
                    /// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_FALLING_EDGE = 0x2,
                    /// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_FALLING_EDGE = 0x3,
                    /// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
                    HIGH_LEVEL = 0x4,
                    /// Low level. Match occurs when there is a low level on the specified input.
                    LOW_LEVEL = 0x5,
                    /// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
                    CONSTANT_ZERO = 0x6,
                    /// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
                    EVENT = 0x7,
                },
                /// Specifies the match contribution condition for bit slice 5.
                CFG5: enum(u3) {
                    /// Constant HIGH. This bit slice always contributes to a product term match.
                    CONSTANT_HIGH = 0x0,
                    /// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_EDGE = 0x1,
                    /// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_FALLING_EDGE = 0x2,
                    /// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_FALLING_EDGE = 0x3,
                    /// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
                    HIGH_LEVEL = 0x4,
                    /// Low level. Match occurs when there is a low level on the specified input.
                    LOW_LEVEL = 0x5,
                    /// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
                    CONSTANT_ZERO = 0x6,
                    /// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
                    EVENT = 0x7,
                },
                /// Specifies the match contribution condition for bit slice 6.
                CFG6: enum(u3) {
                    /// Constant HIGH. This bit slice always contributes to a product term match.
                    CONSTANT_HIGH = 0x0,
                    /// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_EDGE = 0x1,
                    /// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_FALLING_EDGE = 0x2,
                    /// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_FALLING_EDGE = 0x3,
                    /// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
                    HIGH_LEVEL = 0x4,
                    /// Low level. Match occurs when there is a low level on the specified input.
                    LOW_LEVEL = 0x5,
                    /// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
                    CONSTANT_ZERO = 0x6,
                    /// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
                    EVENT = 0x7,
                },
                /// Specifies the match contribution condition for bit slice 7.
                CFG7: enum(u3) {
                    /// Constant HIGH. This bit slice always contributes to a product term match.
                    CONSTANT_HIGH = 0x0,
                    /// Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_EDGE = 0x1,
                    /// Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_FALLING_EDGE = 0x2,
                    /// Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to.
                    STICKY_RISING_FALLING_EDGE = 0x3,
                    /// High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.
                    HIGH_LEVEL = 0x4,
                    /// Low level. Match occurs when there is a low level on the specified input.
                    LOW_LEVEL = 0x5,
                    /// Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices).
                    CONSTANT_ZERO = 0x6,
                    /// Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3) . This bit is cleared after one clock cycle.
                    EVENT = 0x7,
                },
            }),
        };

        /// LPC5460x Repetitive Interrupt Timer(RIT)
        pub const RIT = extern struct {
            /// Compare value LSB register
            COMPVAL: mmio.Mmio(packed struct(u32) {
                /// .
                RICOMP: u32,
            }),
            /// Mask LSB register
            MASK: mmio.Mmio(packed struct(u32) {
                /// Mask register.
                RIMASK: u32,
            }),
            /// Control register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Interrupt flag.
                RITINT: u1,
                /// Timer enable clear.
                RITENCLR: u1,
                /// Timer enable for debug.
                RITENBR: u1,
                /// Timer enable.
                RITEN: u1,
                padding: u28,
            }),
            /// Counter LSB register
            COUNTER: mmio.Mmio(packed struct(u32) {
                /// 32 LSBs of the up counter.
                RICOUNTER: u32,
            }),
            /// Compare value MSB register
            COMPVAL_H: mmio.Mmio(packed struct(u32) {
                /// Compare value MSB register.
                RICOMP: u16,
                padding: u16,
            }),
            /// Mask MSB register
            MASK_H: mmio.Mmio(packed struct(u32) {
                /// Mask register.
                RIMASK: u16,
                padding: u16,
            }),
            reserved28: [4]u8,
            /// Counter MSB register
            COUNTER_H: mmio.Mmio(packed struct(u32) {
                /// 16 LSBs of the up counter.
                RICOUNTER: u16,
                padding: u16,
            }),
        };

        /// LPC5411x Real-Time Clock (RTC)
        pub const RTC = extern struct {
            /// RTC control register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Software reset control
                SWRESET: enum(u1) {
                    /// Not in reset. The RTC is not held in reset. This bit must be cleared prior to configuring or initiating any operation of the RTC.
                    NOT_IN_RESET = 0x0,
                    /// In reset. The RTC is held in reset. All register bits within the RTC will be forced to their reset value except the OFD bit. This bit must be cleared before writing to any register in the RTC - including writes to set any of the other bits within this register. Do not attempt to write to any bits of this register at the same time that the reset bit is being cleared.
                    IN_RESET = 0x1,
                },
                reserved2: u1,
                /// RTC 1 Hz timer alarm flag status.
                ALARM1HZ: enum(u1) {
                    /// No match. No match has occurred on the 1 Hz RTC timer. Writing a 0 has no effect.
                    NO_MATCH = 0x0,
                    /// Match. A match condition has occurred on the 1 Hz RTC timer. This flag generates an RTC alarm interrupt request RTC_ALARM which can also wake up the part from any low power mode. Writing a 1 clears this bit.
                    MATCH = 0x1,
                },
                /// RTC 1 kHz timer wake-up flag status.
                WAKE1KHZ: enum(u1) {
                    /// Run. The RTC 1 kHz timer is running. Writing a 0 has no effect.
                    RUN = 0x0,
                    /// Time-out. The 1 kHz high-resolution/wake-up timer has timed out. This flag generates an RTC wake-up interrupt request RTC-WAKE which can also wake up the part from any low power mode. Writing a 1 clears this bit.
                    TIMEOUT = 0x1,
                },
                /// RTC 1 Hz timer alarm enable for Deep power-down.
                ALARMDPD_EN: enum(u1) {
                    /// Disable. A match on the 1 Hz RTC timer will not bring the part out of Deep power-down mode.
                    DISABLE = 0x0,
                    /// Enable. A match on the 1 Hz RTC timer bring the part out of Deep power-down mode.
                    ENABLE = 0x1,
                },
                /// RTC 1 kHz timer wake-up enable for Deep power-down.
                WAKEDPD_EN: enum(u1) {
                    /// Disable. A match on the 1 kHz RTC timer will not bring the part out of Deep power-down mode.
                    DISABLE = 0x0,
                    /// Enable. A match on the 1 kHz RTC timer bring the part out of Deep power-down mode.
                    ENABLE = 0x1,
                },
                /// RTC 1 kHz clock enable. This bit can be set to 0 to conserve power if the 1 kHz timer is not used. This bit has no effect when the RTC is disabled (bit 7 of this register is 0).
                RTC1KHZ_EN: enum(u1) {
                    /// Disable. A match on the 1 kHz RTC timer will not bring the part out of Deep power-down mode.
                    DISABLE = 0x0,
                    /// Enable. The 1 kHz RTC timer is enabled.
                    ENABLE = 0x1,
                },
                /// RTC enable.
                RTC_EN: enum(u1) {
                    /// Disable. The RTC 1 Hz and 1 kHz clocks are shut down and the RTC operation is disabled. This bit should be 0 when writing to load a value in the RTC counter register.
                    DISABLE = 0x0,
                    /// Enable. The 1 Hz RTC clock is running and RTC operation is enabled. This bit must be set to initiate operation of the RTC. The first clock to the RTC counter occurs 1 s after this bit is set. To also enable the high-resolution, 1 kHz clock, set bit 6 in this register.
                    ENABLE = 0x1,
                },
                /// RTC oscillator power-down control.
                RTC_OSC_PD: enum(u1) {
                    /// See RTC_OSC_BYPASS
                    POWER_UP = 0x0,
                    /// RTC oscillator is powered-down.
                    POWERED_DOWN = 0x1,
                },
                padding: u23,
            }),
            /// RTC match register
            MATCH: mmio.Mmio(packed struct(u32) {
                /// Contains the match value against which the 1 Hz RTC timer will be compared to set the alarm flag RTC_ALARM and generate an alarm interrupt/wake-up if enabled.
                MATVAL: u32,
            }),
            /// RTC counter register
            COUNT: mmio.Mmio(packed struct(u32) {
                /// A read reflects the current value of the main, 1 Hz RTC timer. A write loads a new initial value into the timer. The RTC counter will count up continuously at a 1 Hz rate once the RTC Software Reset is removed (by clearing bit 0 of the CTRL register). Only write to this register when the RTC_EN bit in the RTC CTRL Register is 0. The counter increments one second after the RTC_EN bit is set.
                VAL: u32,
            }),
            /// High-resolution/wake-up timer control register
            WAKE: mmio.Mmio(packed struct(u32) {
                /// A read reflects the current value of the high-resolution/wake-up timer. A write pre-loads a start count value into the wake-up timer and initializes a count-down sequence. Do not write to this register while counting is in progress.
                VAL: u16,
                padding: u16,
            }),
            reserved64: [48]u8,
            /// General Purpose register
            GPREG: [8]mmio.Mmio(packed struct(u32) {
                /// Data retained during Deep power-down mode or loss of main power as long as VBAT is supplied.
                GPDATA: u32,
            }),
        };

        /// SCTimer/PWM (SCT)
        pub const SCT0 = extern struct {
            /// SCT configuration register
            CONFIG: mmio.Mmio(packed struct(u32) {
                /// SCT operation
                UNIFY: enum(u1) {
                    /// The SCT operates as two 16-bit counters named COUNTER_L and COUNTER_H.
                    DUAL_COUNTER = 0x0,
                    /// The SCT operates as a unified 32-bit counter.
                    UNIFIED_COUNTER = 0x1,
                },
                /// SCT clock mode
                CLKMODE: enum(u2) {
                    /// System Clock Mode. The system clock clocks the entire SCT module including the counter(s) and counter prescalers.
                    SYSTEM_CLOCK_MODE = 0x0,
                    /// Sampled System Clock Mode. The system clock clocks the SCT module, but the counter and prescalers are only enabled to count when the designated edge is detected on the input selected by the CKSEL field. The minimum pulse width on the selected clock-gate input is 1 bus clock period. This mode is the high-performance, sampled-clock mode.
                    SAMPLED_SYSTEM_CLOCK_MODE = 0x1,
                    /// SCT Input Clock Mode. The input/edge selected by the CKSEL field clocks the SCT module, including the counters and prescalers, after first being synchronized to the system clock. The minimum pulse width on the clock input is 1 bus clock period. This mode is the low-power, sampled-clock mode.
                    SCT_INPUT_CLOCK_MODE = 0x2,
                    /// Asynchronous Mode. The entire SCT module is clocked directly by the input/edge selected by the CKSEL field. In this mode, the SCT outputs are switched synchronously to the SCT input clock - not the system clock. The input clock rate must be at least half the system clock rate and can be the same or faster than the system clock.
                    ASYNCHRONOUS_MODE = 0x3,
                },
                /// SCT clock select. The specific functionality of the designated input/edge is dependent on the CLKMODE bit selection in this register.
                CKSEL: enum(u4) {
                    /// Rising edges on input 0.
                    INPUT_0_RISING_EDGES = 0x0,
                    /// Falling edges on input 0.
                    INPUT_0_FALLING_EDGE = 0x1,
                    /// Rising edges on input 1.
                    INPUT_1_RISING_EDGES = 0x2,
                    /// Falling edges on input 1.
                    INPUT_1_FALLING_EDGE = 0x3,
                    /// Rising edges on input 2.
                    INPUT_2_RISING_EDGES = 0x4,
                    /// Falling edges on input 2.
                    INPUT_2_FALLING_EDGE = 0x5,
                    /// Rising edges on input 3.
                    INPUT_3_RISING_EDGES = 0x6,
                    /// Falling edges on input 3.
                    INPUT_3_FALLING_EDGE = 0x7,
                    /// Rising edges on input 4.
                    INPUT_4_RISING_EDGES = 0x8,
                    /// Falling edges on input 4.
                    INPUT_4_FALLING_EDGE = 0x9,
                    /// Rising edges on input 5.
                    INPUT_5_RISING_EDGES = 0xa,
                    /// Falling edges on input 5.
                    INPUT_5_FALLING_EDGE = 0xb,
                    /// Rising edges on input 6.
                    INPUT_6_RISING_EDGES = 0xc,
                    /// Falling edges on input 6.
                    INPUT_6_FALLING_EDGE = 0xd,
                    /// Rising edges on input 7.
                    INPUT_7_RISING_EDGES = 0xe,
                    /// Falling edges on input 7.
                    INPUT_7_FALLING_EDGE = 0xf,
                },
                /// A 1 in this bit prevents the lower match registers from being reloaded from their respective reload registers. Setting this bit eliminates the need to write to the reload registers MATCHREL if the match values are fixed. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set.
                NORELOAD_L: u1,
                /// A 1 in this bit prevents the higher match registers from being reloaded from their respective reload registers. Setting this bit eliminates the need to write to the reload registers MATCHREL if the match values are fixed. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set.
                NORELOAD_H: u1,
                /// Synchronization for input N (bit 9 = input 0, bit 10 = input 1,, bit 12 = input 3); all other bits are reserved. A 1 in one of these bits subjects the corresponding input to synchronization to the SCT clock, before it is used to create an event. If an input is known to already be synchronous to the SCT clock, this bit may be set to 0 for faster input response. (Note: The SCT clock is the system clock for CKMODEs 0-2. It is the selected, asynchronous SCT input clock for CKMODE3). Note that the INSYNC field only affects inputs used for event generation. It does not apply to the clock input specified in the CKSEL field.
                INSYNC: u4,
                reserved17: u4,
                /// A one in this bit causes a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in unidirectional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set.
                AUTOLIMIT_L: u1,
                /// A one in this bit will cause a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in unidirectional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set.
                AUTOLIMIT_H: u1,
                padding: u13,
            }),
            /// SCT control register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// This bit is 1 when the L or unified counter is counting down. Hardware sets this bit when the counter is counting up, counter limit occurs, and BIDIR = 1.Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0.
                DOWN_L: u1,
                /// When this bit is 1 and HALT is 0, the L or unified counter does not run, but I/O events related to the counter can occur. If a designated start event occurs, this bit is cleared and counting resumes.
                STOP_L: u1,
                /// When this bit is 1, the L or unified counter does not run and no events can occur. A reset sets this bit. When the HALT_L bit is one, the STOP_L bit is cleared. It is possible to remove the halt condition while keeping the SCT in the stop condition (not running) with a single write to this register to simultaneously clear the HALT bit and set the STOP bit. Once set, only software can clear this bit to restore counter operation. This bit is set on reset.
                HALT_L: u1,
                /// Writing a 1 to this bit clears the L or unified counter. This bit always reads as 0.
                CLRCTR_L: u1,
                /// L or unified counter direction select
                BIDIR_L: enum(u1) {
                    /// Up. The counter counts up to a limit condition, then is cleared to zero.
                    UP = 0x0,
                    /// Up-down. The counter counts up to a limit, then counts down to a limit condition or to 0.
                    UP_DOWN = 0x1,
                },
                /// Specifies the factor by which the SCT clock is prescaled to produce the L or unified counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRE_L+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value.
                PRE_L: u8,
                reserved16: u3,
                /// This bit is 1 when the H counter is counting down. Hardware sets this bit when the counter is counting, a counter limit condition occurs, and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0.
                DOWN_H: u1,
                /// When this bit is 1 and HALT is 0, the H counter does not, run but I/O events related to the counter can occur. If such an event matches the mask in the Start register, this bit is cleared and counting resumes.
                STOP_H: u1,
                /// When this bit is 1, the H counter does not run and no events can occur. A reset sets this bit. When the HALT_H bit is one, the STOP_H bit is cleared. It is possible to remove the halt condition while keeping the SCT in the stop condition (not running) with a single write to this register to simultaneously clear the HALT bit and set the STOP bit. Once set, this bit can only be cleared by software to restore counter operation. This bit is set on reset.
                HALT_H: u1,
                /// Writing a 1 to this bit clears the H counter. This bit always reads as 0.
                CLRCTR_H: u1,
                /// Direction select
                BIDIR_H: enum(u1) {
                    /// The H counter counts up to its limit condition, then is cleared to zero.
                    UP = 0x0,
                    /// The H counter counts up to its limit, then counts down to a limit condition or to 0.
                    UP_DOWN = 0x1,
                },
                /// Specifies the factor by which the SCT clock is prescaled to produce the H counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRELH+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value.
                PRE_H: u8,
                padding: u3,
            }),
            /// SCT limit event select register
            LIMIT: mmio.Mmio(packed struct(u32) {
                /// If bit n is one, event n is used as a counter limit for the L or unified counter (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
                LIMMSK_L: u16,
                /// If bit n is one, event n is used as a counter limit for the H counter (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of events in this SCT.
                LIMMSK_H: u16,
            }),
            /// SCT halt event select register
            HALT: mmio.Mmio(packed struct(u32) {
                /// If bit n is one, event n sets the HALT_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
                HALTMSK_L: u16,
                /// If bit n is one, event n sets the HALT_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of events in this SCT.
                HALTMSK_H: u16,
            }),
            /// SCT stop event select register
            STOP: mmio.Mmio(packed struct(u32) {
                /// If bit n is one, event n sets the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
                STOPMSK_L: u16,
                /// If bit n is one, event n sets the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of events in this SCT.
                STOPMSK_H: u16,
            }),
            /// SCT start event select register
            START: mmio.Mmio(packed struct(u32) {
                /// If bit n is one, event n clears the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
                STARTMSK_L: u16,
                /// If bit n is one, event n clears the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of events in this SCT.
                STARTMSK_H: u16,
            }),
            reserved64: [40]u8,
            /// SCT counter register
            COUNT: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read or write the 16-bit L counter value. When UNIFY = 1, read or write the lower 16 bits of the 32-bit unified counter.
                CTR_L: u16,
                /// When UNIFY = 0, read or write the 16-bit H counter value. When UNIFY = 1, read or write the upper 16 bits of the 32-bit unified counter.
                CTR_H: u16,
            }),
            /// SCT state register
            STATE: mmio.Mmio(packed struct(u32) {
                /// State variable.
                STATE_L: u5,
                reserved16: u11,
                /// State variable.
                STATE_H: u5,
                padding: u11,
            }),
            /// SCT input register
            INPUT: mmio.Mmio(packed struct(u32) {
                /// Input 0 state. Input 0 state on the last SCT clock edge.
                AIN0: u1,
                /// Input 1 state. Input 1 state on the last SCT clock edge.
                AIN1: u1,
                /// Input 2 state. Input 2 state on the last SCT clock edge.
                AIN2: u1,
                /// Input 3 state. Input 3 state on the last SCT clock edge.
                AIN3: u1,
                /// Input 4 state. Input 4 state on the last SCT clock edge.
                AIN4: u1,
                /// Input 5 state. Input 5 state on the last SCT clock edge.
                AIN5: u1,
                /// Input 6 state. Input 6 state on the last SCT clock edge.
                AIN6: u1,
                /// Input 7 state. Input 7 state on the last SCT clock edge.
                AIN7: u1,
                /// Input 8 state. Input 8 state on the last SCT clock edge.
                AIN8: u1,
                /// Input 9 state. Input 9 state on the last SCT clock edge.
                AIN9: u1,
                /// Input 10 state. Input 10 state on the last SCT clock edge.
                AIN10: u1,
                /// Input 11 state. Input 11 state on the last SCT clock edge.
                AIN11: u1,
                /// Input 12 state. Input 12 state on the last SCT clock edge.
                AIN12: u1,
                /// Input 13 state. Input 13 state on the last SCT clock edge.
                AIN13: u1,
                /// Input 14 state. Input 14 state on the last SCT clock edge.
                AIN14: u1,
                /// Input 15 state. Input 15 state on the last SCT clock edge.
                AIN15: u1,
                /// Input 0 state. Input 0 state following the synchronization specified by INSYNC.
                SIN0: u1,
                /// Input 1 state. Input 1 state following the synchronization specified by INSYNC.
                SIN1: u1,
                /// Input 2 state. Input 2 state following the synchronization specified by INSYNC.
                SIN2: u1,
                /// Input 3 state. Input 3 state following the synchronization specified by INSYNC.
                SIN3: u1,
                /// Input 4 state. Input 4 state following the synchronization specified by INSYNC.
                SIN4: u1,
                /// Input 5 state. Input 5 state following the synchronization specified by INSYNC.
                SIN5: u1,
                /// Input 6 state. Input 6 state following the synchronization specified by INSYNC.
                SIN6: u1,
                /// Input 7 state. Input 7 state following the synchronization specified by INSYNC.
                SIN7: u1,
                /// Input 8 state. Input 8 state following the synchronization specified by INSYNC.
                SIN8: u1,
                /// Input 9 state. Input 9 state following the synchronization specified by INSYNC.
                SIN9: u1,
                /// Input 10 state. Input 10 state following the synchronization specified by INSYNC.
                SIN10: u1,
                /// Input 11 state. Input 11 state following the synchronization specified by INSYNC.
                SIN11: u1,
                /// Input 12 state. Input 12 state following the synchronization specified by INSYNC.
                SIN12: u1,
                /// Input 13 state. Input 13 state following the synchronization specified by INSYNC.
                SIN13: u1,
                /// Input 14 state. Input 14 state following the synchronization specified by INSYNC.
                SIN14: u1,
                /// Input 15 state. Input 15 state following the synchronization specified by INSYNC.
                SIN15: u1,
            }),
            /// SCT match/capture mode register
            REGMODE: mmio.Mmio(packed struct(u32) {
                /// Each bit controls one match/capture register (register 0 = bit 0, register 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT. 0 = register operates as match register. 1 = register operates as capture register.
                REGMOD_L: u16,
                /// Each bit controls one match/capture register (register 0 = bit 16, register 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT. 0 = register operates as match registers. 1 = register operates as capture registers.
                REGMOD_H: u16,
            }),
            /// SCT output register
            OUTPUT: mmio.Mmio(packed struct(u32) {
                /// Writing a 1 to bit n forces the corresponding output HIGH. Writing a 0 forces the corresponding output LOW (output 0 = bit 0, output 1 = bit 1, etc.). The number of bits = number of outputs in this SCT.
                OUT: u16,
                padding: u16,
            }),
            /// SCT output counter direction control register
            OUTPUTDIRCTRL: mmio.Mmio(packed struct(u32) {
                /// Set/clear operation on output 0. Value 0x3 is reserved. Do not program this value.
                SETCLR0: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 1. Value 0x3 is reserved. Do not program this value.
                SETCLR1: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 2. Value 0x3 is reserved. Do not program this value.
                SETCLR2: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 3. Value 0x3 is reserved. Do not program this value.
                SETCLR3: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 4. Value 0x3 is reserved. Do not program this value.
                SETCLR4: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 5. Value 0x3 is reserved. Do not program this value.
                SETCLR5: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 6. Value 0x3 is reserved. Do not program this value.
                SETCLR6: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 7. Value 0x3 is reserved. Do not program this value.
                SETCLR7: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 8. Value 0x3 is reserved. Do not program this value.
                SETCLR8: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 9. Value 0x3 is reserved. Do not program this value.
                SETCLR9: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 10. Value 0x3 is reserved. Do not program this value.
                SETCLR10: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 11. Value 0x3 is reserved. Do not program this value.
                SETCLR11: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 12. Value 0x3 is reserved. Do not program this value.
                SETCLR12: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 13. Value 0x3 is reserved. Do not program this value.
                SETCLR13: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 14. Value 0x3 is reserved. Do not program this value.
                SETCLR14: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
                /// Set/clear operation on output 15. Value 0x3 is reserved. Do not program this value.
                SETCLR15: enum(u2) {
                    /// Set and clear do not depend on the direction of any counter.
                    INDEPENDENT = 0x0,
                    /// Set and clear are reversed when counter L or the unified counter is counting down.
                    L_REVERSED = 0x1,
                    /// Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.
                    H_REVERSED = 0x2,
                    _,
                },
            }),
            /// SCT conflict resolution register
            RES: mmio.Mmio(packed struct(u32) {
                /// Effect of simultaneous set and clear on output 0.
                O0RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR0 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR0 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 1.
                O1RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR1 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR1 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 2.
                O2RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR2 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output n (or set based on the SETCLR2 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 3.
                O3RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR3 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR3 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 4.
                O4RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR4 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR4 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 5.
                O5RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR5 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR5 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 6.
                O6RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR6 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR6 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 7.
                O7RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR7 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output n (or set based on the SETCLR7 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 8.
                O8RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR8 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR8 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 9.
                O9RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR9 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR9 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 10.
                O10RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR10 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR10 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 11.
                O11RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR11 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR11 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 12.
                O12RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR12 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR12 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 13.
                O13RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR13 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR13 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 14.
                O14RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR14 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR14 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
                /// Effect of simultaneous set and clear on output 15.
                O15RES: enum(u2) {
                    /// No change.
                    NO_CHANGE = 0x0,
                    /// Set output (or clear based on the SETCLR15 field in the OUTPUTDIRCTRL register).
                    SET = 0x1,
                    /// Clear output (or set based on the SETCLR15 field).
                    CLEAR = 0x2,
                    /// Toggle output.
                    TOGGLE_OUTPUT = 0x3,
                },
            }),
            /// SCT DMA request 0 register
            DMAREQ0: mmio.Mmio(packed struct(u32) {
                /// If bit n is one, event n triggers DMA request 0 (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
                DEV_0: u16,
                reserved30: u14,
                /// A 1 in this bit triggers DMA request 0 when it loads the MATCH_L/Unified registers from the RELOAD_L/Unified registers.
                DRL0: u1,
                /// This read-only bit indicates the state of DMA Request 0. Note that if the related DMA channel is enabled and properly set up, it is unlikely that software will see this flag, it will be cleared rapidly by the DMA service. The flag remaining set could point to an issue with DMA setup.
                DRQ0: u1,
            }),
            /// SCT DMA request 1 register
            DMAREQ1: mmio.Mmio(packed struct(u32) {
                /// If bit n is one, event n triggers DMA request 1 (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
                DEV_1: u16,
                reserved30: u14,
                /// A 1 in this bit triggers DMA request 1 when it loads the Match L/Unified registers from the Reload L/Unified registers.
                DRL1: u1,
                /// This read-only bit indicates the state of DMA Request 1. Note that if the related DMA channel is enabled and properly set up, it is unlikely that software will see this flag, it will be cleared rapidly by the DMA service. The flag remaining set could point to an issue with DMA setup.
                DRQ1: u1,
            }),
            reserved240: [140]u8,
            /// SCT event interrupt enable register
            EVEN: mmio.Mmio(packed struct(u32) {
                /// The SCT requests an interrupt when bit n of this register and the event flag register are both one (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
                IEN: u16,
                padding: u16,
            }),
            /// SCT event flag register
            EVFLAG: mmio.Mmio(packed struct(u32) {
                /// Bit n is one if event n has occurred since reset or a 1 was last written to this bit (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of events in this SCT.
                FLAG: u16,
                padding: u16,
            }),
            /// SCT conflict interrupt enable register
            CONEN: mmio.Mmio(packed struct(u32) {
                /// The SCT requests an interrupt when bit n of this register and the SCT conflict flag register are both one (output 0 = bit 0, output 1 = bit 1, etc.). The number of bits = number of outputs in this SCT.
                NCEN: u16,
                padding: u16,
            }),
            /// SCT conflict flag register
            CONFLAG: mmio.Mmio(packed struct(u32) {
                /// Bit n is one if a no-change conflict event occurred on output n since reset or a 1 was last written to this bit (output 0 = bit 0, output 1 = bit 1, etc.). The number of bits = number of outputs in this SCT.
                NCFLAG: u16,
                reserved30: u14,
                /// The most recent bus error from this SCT involved writing CTR L/Unified, STATE L/Unified, MATCH L/Unified, or the Output register when the L/U counter was not halted. A word write to certain L and H registers can be half successful and half unsuccessful.
                BUSERRL: u1,
                /// The most recent bus error from this SCT involved writing CTR H, STATE H, MATCH H, or the Output register when the H counter was not halted.
                BUSERRH: u1,
            }),
            /// SCT capture register of capture channel
            CAP0: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            /// SCT capture register of capture channel
            CAP1: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            /// SCT capture register of capture channel
            CAP2: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            /// SCT capture register of capture channel
            CAP3: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            /// SCT capture register of capture channel
            CAP4: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            /// SCT capture register of capture channel
            CAP5: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            /// SCT capture register of capture channel
            CAP6: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            /// SCT capture register of capture channel
            CAP7: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            /// SCT capture register of capture channel
            CAP8: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            /// SCT capture register of capture channel
            CAP9: mmio.Mmio(packed struct(u32) {
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.
                CAPn_L: u16,
                /// When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.
                CAPn_H: u16,
            }),
            reserved512: [216]u8,
            /// SCT capture control register
            CAPCTRL0: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
            /// SCT capture control register
            CAPCTRL1: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
            /// SCT capture control register
            CAPCTRL2: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
            /// SCT capture control register
            CAPCTRL3: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
            /// SCT capture control register
            CAPCTRL4: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
            /// SCT capture control register
            CAPCTRL5: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
            /// SCT capture control register
            CAPCTRL6: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
            /// SCT capture control register
            CAPCTRL7: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
            /// SCT capture control register
            CAPCTRL8: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
            /// SCT capture control register
            CAPCTRL9: mmio.Mmio(packed struct(u32) {
                /// If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_L: u16,
                /// If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17, etc.). The number of bits = number of match/captures in this SCT.
                CAPCONn_H: u16,
            }),
        };

        /// SDMMC
        pub const SDIF = extern struct {
            /// Control register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Controller reset.
                CONTROLLER_RESET: u1,
                /// Fifo reset.
                FIFO_RESET: u1,
                /// DMA reset.
                DMA_RESET: u1,
                reserved4: u1,
                /// Global interrupt enable/disable bit.
                INT_ENABLE: u1,
                reserved6: u1,
                /// Read/wait.
                READ_WAIT: u1,
                /// Send irq response.
                SEND_IRQ_RESPONSE: u1,
                /// Abort read data.
                ABORT_READ_DATA: u1,
                /// Send ccsd.
                SEND_CCSD: u1,
                /// Send auto stop ccsd.
                SEND_AUTO_STOP_CCSD: u1,
                /// CEATA device interrupt status.
                CEATA_DEVICE_INTERRUPT_STATUS: u1,
                reserved16: u4,
                /// Controls the state of the SD_VOLT0 pin.
                CARD_VOLTAGE_A0: u1,
                /// Controls the state of the SD_VOLT1 pin.
                CARD_VOLTAGE_A1: u1,
                /// Controls the state of the SD_VOLT2 pin.
                CARD_VOLTAGE_A2: u1,
                reserved25: u6,
                /// SD/MMC DMA use.
                USE_INTERNAL_DMAC: u1,
                padding: u6,
            }),
            /// Power Enable register
            PWREN: mmio.Mmio(packed struct(u32) {
                /// Power on/off switch for card; once power is turned on, software should wait for regulator/switch ramp-up time before trying to initialize card.
                POWER_ENABLE: u1,
                padding: u31,
            }),
            /// Clock Divider register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider-0 value.
                CLK_DIVIDER0: u8,
                padding: u24,
            }),
            reserved16: [4]u8,
            /// Clock Enable register
            CLKENA: mmio.Mmio(packed struct(u32) {
                /// Clock-enable control for SD card clock.
                CCLK_ENABLE: u1,
                reserved16: u15,
                /// Low-power control for SD card clock.
                CCLK_LOW_POWER: u1,
                padding: u15,
            }),
            /// Time-out register
            TMOUT: mmio.Mmio(packed struct(u32) {
                /// Response time-out value.
                RESPONSE_TIMEOUT: u8,
                /// Value for card Data Read time-out; same value also used for Data Starvation by Host time-out.
                DATA_TIMEOUT: u24,
            }),
            /// Card Type register
            CTYPE: mmio.Mmio(packed struct(u32) {
                /// Indicates if card is 1-bit or 4-bit: 0 - 1-bit mode 1 - 4-bit mode 1 and 4-bit modes only work when 8-bit mode in CARD_WIDTH1 is not enabled (bit 16 in this register is set to 0).
                CARD_WIDTH0: u1,
                reserved16: u15,
                /// Indicates if card is 8-bit: 0 - Non 8-bit mode 1 - 8-bit mode.
                CARD_WIDTH1: u1,
                padding: u15,
            }),
            /// Block Size register
            BLKSIZ: mmio.Mmio(packed struct(u32) {
                /// Block size.
                BLOCK_SIZE: u16,
                padding: u16,
            }),
            /// Byte Count register
            BYTCNT: mmio.Mmio(packed struct(u32) {
                /// Number of bytes to be transferred; should be integer multiple of Block Size for block transfers.
                BYTE_COUNT: u32,
            }),
            /// Interrupt Mask register
            INTMASK: mmio.Mmio(packed struct(u32) {
                /// Card detect.
                CDET: u1,
                /// Response error.
                RE: u1,
                /// Command done.
                CDONE: u1,
                /// Data transfer over.
                DTO: u1,
                /// Transmit FIFO data request.
                TXDR: u1,
                /// Receive FIFO data request.
                RXDR: u1,
                /// Response CRC error.
                RCRC: u1,
                /// Data CRC error.
                DCRC: u1,
                /// Response time-out.
                RTO: u1,
                /// Data read time-out.
                DRTO: u1,
                /// Data starvation-by-host time-out (HTO).
                HTO: u1,
                /// FIFO underrun/overrun error.
                FRUN: u1,
                /// Hardware locked write error.
                HLE: u1,
                /// Start-bit error.
                SBE: u1,
                /// Auto command done.
                ACD: u1,
                /// End-bit error (read)/Write no CRC.
                EBE: u1,
                /// Mask SDIO interrupt.
                SDIO_INT_MASK: u1,
                padding: u15,
            }),
            /// Command Argument register
            CMDARG: mmio.Mmio(packed struct(u32) {
                /// Value indicates command argument to be passed to card.
                CMD_ARG: u32,
            }),
            /// Command register
            CMD: mmio.Mmio(packed struct(u32) {
                /// Command index.
                CMD_INDEX: u6,
                /// Response expect.
                RESPONSE_EXPECT: u1,
                /// Response length.
                RESPONSE_LENGTH: u1,
                /// Check response CRC.
                CHECK_RESPONSE_CRC: u1,
                /// Data expected.
                DATA_EXPECTED: u1,
                /// read/write.
                READ_WRITE: u1,
                /// Transfer mode.
                TRANSFER_MODE: u1,
                /// Send auto stop.
                SEND_AUTO_STOP: u1,
                /// Wait prvdata complete.
                WAIT_PRVDATA_COMPLETE: u1,
                /// Stop abort command.
                STOP_ABORT_CMD: u1,
                /// Send initialization.
                SEND_INITIALIZATION: u1,
                reserved21: u5,
                /// Update clock registers only.
                UPDATE_CLOCK_REGISTERS_ONLY: u1,
                /// Read ceata device.
                READ_CEATA_DEVICE: u1,
                /// CCS expected.
                CCS_EXPECTED: u1,
                /// Enable Boot - this bit should be set only for mandatory boot mode.
                ENABLE_BOOT: u1,
                /// Expect Boot Acknowledge.
                EXPECT_BOOT_ACK: u1,
                /// Disable Boot.
                DISABLE_BOOT: u1,
                /// Boot Mode.
                BOOT_MODE: u1,
                /// Voltage switch bit.
                VOLT_SWITCH: u1,
                /// Use Hold Register.
                USE_HOLD_REG: u1,
                reserved31: u1,
                /// Start command.
                START_CMD: u1,
            }),
            /// Response register
            RESP: [4]mmio.Mmio(packed struct(u32) {
                /// Bits of response.
                RESPONSE: u32,
            }),
            /// Masked Interrupt Status register
            MINTSTS: mmio.Mmio(packed struct(u32) {
                /// Card detect.
                CDET: u1,
                /// Response error.
                RE: u1,
                /// Command done.
                CDONE: u1,
                /// Data transfer over.
                DTO: u1,
                /// Transmit FIFO data request.
                TXDR: u1,
                /// Receive FIFO data request.
                RXDR: u1,
                /// Response CRC error.
                RCRC: u1,
                /// Data CRC error.
                DCRC: u1,
                /// Response time-out.
                RTO: u1,
                /// Data read time-out.
                DRTO: u1,
                /// Data starvation-by-host time-out (HTO).
                HTO: u1,
                /// FIFO underrun/overrun error.
                FRUN: u1,
                /// Hardware locked write error.
                HLE: u1,
                /// Start-bit error.
                SBE: u1,
                /// Auto command done.
                ACD: u1,
                /// End-bit error (read)/write no CRC.
                EBE: u1,
                /// Interrupt from SDIO card.
                SDIO_INTERRUPT: u1,
                padding: u15,
            }),
            /// Raw Interrupt Status register
            RINTSTS: mmio.Mmio(packed struct(u32) {
                /// Card detect.
                CDET: u1,
                /// Response error.
                RE: u1,
                /// Command done.
                CDONE: u1,
                /// Data transfer over.
                DTO: u1,
                /// Transmit FIFO data request.
                TXDR: u1,
                /// Receive FIFO data request.
                RXDR: u1,
                /// Response CRC error.
                RCRC: u1,
                /// Data CRC error.
                DCRC: u1,
                /// Response time-out (RTO)/Boot Ack Received (BAR).
                RTO_BAR: u1,
                /// Data read time-out (DRTO)/Boot Data Start (BDS).
                DRTO_BDS: u1,
                /// Data starvation-by-host time-out (HTO).
                HTO: u1,
                /// FIFO underrun/overrun error.
                FRUN: u1,
                /// Hardware locked write error.
                HLE: u1,
                /// Start-bit error.
                SBE: u1,
                /// Auto command done.
                ACD: u1,
                /// End-bit error (read)/write no CRC.
                EBE: u1,
                /// Interrupt from SDIO card.
                SDIO_INTERRUPT: u1,
                padding: u15,
            }),
            /// Status register
            STATUS: mmio.Mmio(packed struct(u32) {
                /// FIFO reached Receive watermark level; not qualified with data transfer.
                FIFO_RX_WATERMARK: u1,
                /// FIFO reached Transmit watermark level; not qualified with data transfer.
                FIFO_TX_WATERMARK: u1,
                /// FIFO is empty status.
                FIFO_EMPTY: u1,
                /// FIFO is full status.
                FIFO_FULL: u1,
                /// Command FSM states: 0 - Idle 1 - Send init sequence 2 - Tx cmd start bit 3 - Tx cmd tx bit 4 - Tx cmd index + arg 5 - Tx cmd crc7 6 - Tx cmd end bit 7 - Rx resp start bit 8 - Rx resp IRQ response 9 - Rx resp tx bit 10 - Rx resp cmd idx 11 - Rx resp data 12 - Rx resp crc7 13 - Rx resp end bit 14 - Cmd path wait NCC 15 - Wait; CMD-to-response turnaround NOTE: The command FSM state is represented using 19 bits.
                CMDFSMSTATES: u4,
                /// Raw selected card_data[3]; checks whether card is present 0 - card not present 1 - card present.
                DATA_3_STATUS: u1,
                /// Inverted version of raw selected card_data[0] 0 - card data not busy 1 - card data busy.
                DATA_BUSY: u1,
                /// Data transmit or receive state-machine is busy.
                DATA_STATE_MC_BUSY: u1,
                /// Index of previous response, including any auto-stop sent by core.
                RESPONSE_INDEX: u6,
                /// FIFO count - Number of filled locations in FIFO.
                FIFO_COUNT: u13,
                /// DMA acknowledge signal state.
                DMA_ACK: u1,
                /// DMA request signal state.
                DMA_REQ: u1,
            }),
            /// FIFO Threshold Watermark register
            FIFOTH: mmio.Mmio(packed struct(u32) {
                /// FIFO threshold watermark level when transmitting data to card.
                TX_WMARK: u12,
                reserved16: u4,
                /// FIFO threshold watermark level when receiving data to card.
                RX_WMARK: u12,
                /// Burst size of multiple transaction; should be programmed same as DW-DMA controller multiple-transaction-size SRC/DEST_MSIZE.
                DMA_MTS: u3,
                padding: u1,
            }),
            /// Card Detect register
            CDETECT: mmio.Mmio(packed struct(u32) {
                /// Card detect.
                CARD_DETECT: u1,
                padding: u31,
            }),
            /// Write Protect register
            WRTPRT: mmio.Mmio(packed struct(u32) {
                /// Write protect.
                WRITE_PROTECT: u1,
                padding: u31,
            }),
            reserved92: [4]u8,
            /// Transferred CIU Card Byte Count register
            TCBCNT: mmio.Mmio(packed struct(u32) {
                /// Number of bytes transferred by CIU unit to card.
                TRANS_CARD_BYTE_COUNT: u32,
            }),
            /// Transferred Host to BIU-FIFO Byte Count register
            TBBCNT: mmio.Mmio(packed struct(u32) {
                /// Number of bytes transferred between Host/DMA memory and BIU FIFO.
                TRANS_FIFO_BYTE_COUNT: u32,
            }),
            /// Debounce Count register
            DEBNCE: mmio.Mmio(packed struct(u32) {
                /// Number of host clocks (SD_CLK) used by debounce filter logic for card detect; typical debounce time is 5-25 ms.
                DEBOUNCE_COUNT: u24,
                padding: u8,
            }),
            reserved120: [16]u8,
            /// Hardware Reset
            RST_N: mmio.Mmio(packed struct(u32) {
                /// Hardware reset.
                CARD_RESET: u1,
                padding: u31,
            }),
            reserved128: [4]u8,
            /// Bus Mode register
            BMOD: mmio.Mmio(packed struct(u32) {
                /// Software Reset.
                SWR: u1,
                /// Fixed Burst.
                FB: u1,
                /// Descriptor Skip Length.
                DSL: u5,
                /// SD/MMC DMA Enable.
                DE: u1,
                /// Programmable Burst Length.
                PBL: u3,
                padding: u21,
            }),
            /// Poll Demand register
            PLDMND: mmio.Mmio(packed struct(u32) {
                /// Poll Demand.
                PD: u32,
            }),
            /// Descriptor List Base Address register
            DBADDR: mmio.Mmio(packed struct(u32) {
                /// Start of Descriptor List.
                SDL: u32,
            }),
            /// Internal DMAC Status register
            IDSTS: mmio.Mmio(packed struct(u32) {
                /// Transmit Interrupt.
                TI: u1,
                /// Receive Interrupt.
                RI: u1,
                /// Fatal Bus Error Interrupt.
                FBE: u1,
                reserved4: u1,
                /// Descriptor Unavailable Interrupt.
                DU: u1,
                /// Card Error Summary.
                CES: u1,
                reserved8: u2,
                /// Normal Interrupt Summary.
                NIS: u1,
                /// Abnormal Interrupt Summary.
                AIS: u1,
                /// Error Bits.
                EB: u3,
                /// DMAC state machine present state.
                FSM: u4,
                padding: u15,
            }),
            /// Internal DMAC Interrupt Enable register
            IDINTEN: mmio.Mmio(packed struct(u32) {
                /// Transmit Interrupt Enable.
                TI: u1,
                /// Receive Interrupt Enable.
                RI: u1,
                /// Fatal Bus Error Enable.
                FBE: u1,
                reserved4: u1,
                /// Descriptor Unavailable Interrupt.
                DU: u1,
                /// Card Error summary Interrupt Enable.
                CES: u1,
                reserved8: u2,
                /// Normal Interrupt Summary Enable.
                NIS: u1,
                /// Abnormal Interrupt Summary Enable.
                AIS: u1,
                padding: u22,
            }),
            /// Current Host Descriptor Address register
            DSCADDR: mmio.Mmio(packed struct(u32) {
                /// Host Descriptor Address Pointer.
                HDA: u32,
            }),
            /// Current Buffer Descriptor Address register
            BUFADDR: mmio.Mmio(packed struct(u32) {
                /// Host Buffer Address Pointer.
                HBA: u32,
            }),
            reserved256: [100]u8,
            /// Card Threshold Control
            CARDTHRCTL: mmio.Mmio(packed struct(u32) {
                /// Card Read Threshold Enable.
                CARDRDTHREN: u1,
                /// Busy Clear Interrupt Enable.
                BSYCLRINTEN: u1,
                reserved16: u14,
                /// Card Threshold size.
                CARDTHRESHOLD: u8,
                padding: u8,
            }),
            /// Power control
            BACKENDPWR: mmio.Mmio(packed struct(u32) {
                /// Back-end Power control for card application.
                BACKENDPWR: u1,
                padding: u31,
            }),
            reserved512: [248]u8,
            /// SDIF FIFO
            FIFO: [64]mmio.Mmio(packed struct(u32) {
                /// SDIF FIFO.
                DATA: u32,
            }),
        };

        /// SHA
        pub const SHA0 = extern struct {
            /// Control register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// This field is used to select the operational mode of SHA block.
                MODE: u2,
                reserved4: u2,
                /// When this bit is set, a new hash operation is started.
                NEW: u1,
                reserved8: u3,
                /// When this bit is set, the DMA is used to fill INDATA.
                DMA: u1,
                padding: u23,
            }),
            /// Status register
            STATUS: mmio.Mmio(packed struct(u32) {
                /// This field indicates if the block is waiting for more data to process.
                WAITING: u1,
                /// This field indicates if a DIGEST is ready and waiting and there is no active next block that has already started.
                DIGEST: u1,
                /// This field indicates if an error has occurred.
                ERROR: u1,
                padding: u29,
            }),
            /// Interrupt Enable register
            INTENSET: mmio.Mmio(packed struct(u32) {
                /// This field indicates if interrupt should be enabled when waiting for input data.
                WAITING: u1,
                /// This field indicates if interrupt is generated when Digest is ready (completed a Hash or completed a full sequence).
                DIGEST: u1,
                /// This field indicates if interrupt is generated on an ERROR (as defined in STAT register).
                ERROR: u1,
                padding: u29,
            }),
            /// Interrupt Clear register
            INTENCLR: mmio.Mmio(packed struct(u32) {
                /// Writing a 1 clears the interrupt enabled by the INTENSET register.
                WAITING: u1,
                /// Writing a 1 clears the interrupt enabled by the INTENSET register.
                DIGEST: u1,
                /// Writing a 1 clears the interrupt enabled by the INTENSET register.
                ERROR: u1,
                padding: u29,
            }),
            /// Memory Control register
            MEMCTRL: mmio.Mmio(packed struct(u32) {
                /// This field is used to enable SHA block as AHB bus master.
                MASTER: u1,
                reserved16: u15,
                /// This field indicates the number of 512-bit blocks to copy starting at MEMADDR.
                COUNT: u11,
                padding: u5,
            }),
            /// Memory Address register
            MEMADDR: mmio.Mmio(packed struct(u32) {
                /// This field indicates the base address in Internal Flash, SRAM0, SRAMX, or SPIFI to start copying from.
                BASEADDR: u32,
            }),
            reserved32: [8]u8,
            /// Input Data register
            INDATA: mmio.Mmio(packed struct(u32) {
                /// In this field the next word is written in little-endian format.
                DATA: u32,
            }),
            /// Alias register
            ALIAS: [7]mmio.Mmio(packed struct(u32) {
                /// In this field the next word is written in little-endian format.
                DATA: u32,
            }),
            /// Digest register
            DIGEST: [8]mmio.Mmio(packed struct(u32) {
                /// This field contains one word of the Digest.
                DIGEST: u32,
            }),
        };

        /// LPC5460x Smart Card Interface
        pub const SMARTCARD0 = extern struct {
            /// Divisor Latch LSB
            DLL: mmio.Mmio(packed struct(u32) {
                /// The SCIn Divisor Latch LSB Register, along with the SCInDLM register, determines the baud rate of the SCIn.
                DLLSB: u8,
                padding: u24,
            }),
            /// Divisor Latch MSB
            DLM: mmio.Mmio(packed struct(u32) {
                /// The SCIn Divisor Latch MSB Register, along with the DLL register, determines the baud rate of the SCIn.
                DLMSB: u8,
                padding: u24,
            }),
            /// FIFO Control Register
            FCR: mmio.Mmio(packed struct(u32) {
                /// FIFO Enable.
                FIFOEN: u1,
                /// RX FIFO Reset.
                RXFIFORES: u1,
                /// TX FIFO Reset.
                TXFIFORES: u1,
                /// DMA Mode Select.
                DMAMODE: u1,
                reserved6: u2,
                /// RX Trigger Level.
                RXTRIGLVL: u2,
                padding: u24,
            }),
            /// Line Control Register
            LCR: mmio.Mmio(packed struct(u32) {
                /// Word Length Select.
                WLS: u2,
                /// Stop Bit Select.
                SBS: u1,
                /// Parity Enable.
                PE: u1,
                /// Parity Select.
                PS: u2,
                reserved7: u1,
                /// Divisor Latch Access Bit.
                DLAB: u1,
                padding: u24,
            }),
            reserved20: [4]u8,
            /// Line Status Register
            LSR: mmio.Mmio(packed struct(u32) {
                /// Receiver Data Ready.
                RDR: u1,
                /// Overrun Error.
                OE: u1,
                /// Parity Error.
                PE: u1,
                /// Framing Error.
                FE: u1,
                reserved5: u1,
                /// Transmitter Holding Register Empty.
                THRE: u1,
                /// Transmitter Empty.
                TEMT: u1,
                /// Error in RX FIFO.
                RXFE: u1,
                padding: u24,
            }),
            reserved28: [4]u8,
            /// Scratch Pad Register
            SCR: mmio.Mmio(packed struct(u32) {
                /// A readable, writable byte.
                PAD: u8,
                padding: u24,
            }),
            reserved44: [12]u8,
            /// Oversampling register
            OSR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// Fractional part of the oversampling ratio, in units of 1/8th of an input clock period.
                OSFRAC: u3,
                /// Integer part of the oversampling ratio, minus 1.
                OSINT: u4,
                /// These bits act as a more-significant extension of the OSint field, allowing an oversampling ratio up to 2048 as required by ISO7816-3.
                FDINT: u7,
                padding: u17,
            }),
            reserved72: [24]u8,
            /// Smart Card Interface control register
            SCICTRL: mmio.Mmio(packed struct(u32) {
                /// Smart Card Interface Enable.
                SCIEN: u1,
                /// NACK response disable.
                NACKDIS: u1,
                /// Protocol selection as defined in the ISO7816-3 standard.
                PROTSEL: u1,
                reserved5: u2,
                /// Maximum number of retransmissions in case of a negative acknowledge (protocol T=0).
                TXRETRY: u3,
                /// Extra guard time.
                GUARDTIME: u8,
                padding: u16,
            }),
        };

        /// LPC5411x Serial Peripheral Interfaces (SPI)
        pub const SPI0 = extern struct {
            reserved1024: [1024]u8,
            /// SPI Configuration register
            CFG: mmio.Mmio(packed struct(u32) {
                /// SPI enable.
                ENABLE: enum(u1) {
                    /// Disabled. The SPI is disabled and the internal state machine and counters are reset.
                    DISABLED = 0x0,
                    /// Enabled. The SPI is enabled for operation.
                    ENABLED = 0x1,
                },
                reserved2: u1,
                /// Master mode select.
                MASTER: enum(u1) {
                    /// Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output.
                    SLAVE_MODE = 0x0,
                    /// Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input.
                    MASTER_MODE = 0x1,
                },
                /// LSB First mode enable.
                LSBF: enum(u1) {
                    /// Standard. Data is transmitted and received in standard MSB first order.
                    STANDARD = 0x0,
                    /// Reverse. Data is transmitted and received in reverse order (LSB first).
                    REVERSE = 0x1,
                },
                /// Clock Phase select.
                CPHA: enum(u1) {
                    /// Change. The SPI captures serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is changed on the following edge.
                    CHANGE = 0x0,
                    /// Capture. The SPI changes serial data on the first clock transition of the transfer (when the clock changes away from the rest state). Data is captured on the following edge.
                    CAPTURE = 0x1,
                },
                /// Clock Polarity select.
                CPOL: enum(u1) {
                    /// Low. The rest state of the clock (between transfers) is low.
                    LOW = 0x0,
                    /// High. The rest state of the clock (between transfers) is high.
                    HIGH = 0x1,
                },
                reserved7: u1,
                /// Loopback mode enable. Loopback mode applies only to Master mode, and connects transmit and receive data connected together to allow simple software testing.
                LOOP: enum(u1) {
                    /// Disabled.
                    DISABLED = 0x0,
                    /// Enabled.
                    ENABLED = 0x1,
                },
                /// SSEL0 Polarity select.
                SPOL0: enum(u1) {
                    /// Low. The SSEL0 pin is active low.
                    LOW = 0x0,
                    /// High. The SSEL0 pin is active high.
                    HIGH = 0x1,
                },
                /// SSEL1 Polarity select.
                SPOL1: enum(u1) {
                    /// Low. The SSEL1 pin is active low.
                    LOW = 0x0,
                    /// High. The SSEL1 pin is active high.
                    HIGH = 0x1,
                },
                /// SSEL2 Polarity select.
                SPOL2: enum(u1) {
                    /// Low. The SSEL2 pin is active low.
                    LOW = 0x0,
                    /// High. The SSEL2 pin is active high.
                    HIGH = 0x1,
                },
                /// SSEL3 Polarity select.
                SPOL3: enum(u1) {
                    /// Low. The SSEL3 pin is active low.
                    LOW = 0x0,
                    /// High. The SSEL3 pin is active high.
                    HIGH = 0x1,
                },
                padding: u20,
            }),
            /// SPI Delay register
            DLY: mmio.Mmio(packed struct(u32) {
                /// Controls the amount of time between SSEL assertion and the beginning of a data transfer. There is always one SPI clock time between SSEL assertion and the first clock edge. This is not considered part of the pre-delay. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. 0xF = 15 SPI clock times are inserted.
                PRE_DELAY: u4,
                /// Controls the amount of time between the end of a data transfer and SSEL deassertion. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. 0xF = 15 SPI clock times are inserted.
                POST_DELAY: u4,
                /// If the EOF flag is set, controls the minimum amount of time between the current frame and the next frame (or SSEL deassertion if EOT). 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. 0xF = 15 SPI clock times are inserted.
                FRAME_DELAY: u4,
                /// Controls the minimum amount of time that the SSEL is deasserted between transfers. 0x0 = The minimum time that SSEL is deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum time that SSEL is deasserted is 3 SPI clock times. 0xF = The minimum time that SSEL is deasserted is 16 SPI clock times.
                TRANSFER_DELAY: u4,
                padding: u16,
            }),
            /// SPI Status. Some status flags can be cleared by writing a 1 to that bit position.
            STAT: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// Slave Select Assert. This flag is set whenever any slave select transitions from deasserted to asserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become busy, and allows waking up the device from reduced power modes when a slave mode access begins. This flag is cleared by software.
                SSA: u1,
                /// Slave Select Deassert. This flag is set whenever any asserted slave selects transition to deasserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become idle. This flag is cleared by software.
                SSD: u1,
                /// Stalled status flag. This indicates whether the SPI is currently in a stall condition.
                STALLED: u1,
                /// End Transfer control bit. Software can set this bit to force an end to the current transfer when the transmitter finishes any activity already in progress, as if the EOT flag had been set prior to the last transmission. This capability is included to support cases where it is not known when transmit data is written that it will be the end of a transfer. The bit is cleared when the transmitter becomes idle as the transfer comes to an end. Forcing an end of transfer in this manner causes any specified FRAME_DELAY and TRANSFER_DELAY to be inserted.
                ENDTRANSFER: u1,
                /// Master idle status flag. This bit is 1 whenever the SPI master function is fully idle. This means that the transmit holding register is empty and the transmitter is not in the process of sending data.
                MSTIDLE: u1,
                padding: u23,
            }),
            /// SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.
            INTENSET: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// Slave select assert interrupt enable. Determines whether an interrupt occurs when the Slave Select is asserted.
                SSAEN: enum(u1) {
                    /// Disabled. No interrupt will be generated when any Slave Select transitions from deasserted to asserted.
                    DISABLED = 0x0,
                    /// Enabled. An interrupt will be generated when any Slave Select transitions from deasserted to asserted.
                    ENABLED = 0x1,
                },
                /// Slave select deassert interrupt enable. Determines whether an interrupt occurs when the Slave Select is deasserted.
                SSDEN: enum(u1) {
                    /// Disabled. No interrupt will be generated when all asserted Slave Selects transition to deasserted.
                    DISABLED = 0x0,
                    /// Enabled. An interrupt will be generated when all asserted Slave Selects transition to deasserted.
                    ENABLED = 0x1,
                },
                reserved8: u2,
                /// Master idle interrupt enable.
                MSTIDLEEN: enum(u1) {
                    /// No interrupt will be generated when the SPI master function is idle.
                    DISABLED = 0x0,
                    /// An interrupt will be generated when the SPI master function is fully idle.
                    ENABLED = 0x1,
                },
                padding: u23,
            }),
            /// SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared.
            INTENCLR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                SSAEN: u1,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                SSDEN: u1,
                reserved8: u2,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                MSTIDLE: u1,
                padding: u23,
            }),
            reserved1060: [16]u8,
            /// SPI clock Divider
            DIV: mmio.Mmio(packed struct(u32) {
                /// Rate divider value. Specifies how the Flexcomm clock (FCLK) is divided to produce the SPI clock rate in master mode. DIVVAL is -1 encoded such that the value 0 results in FCLK/1, the value 1 results in FCLK/2, up to the maximum possible divide value of 0xFFFF, which results in FCLK/65536.
                DIVVAL: u16,
                padding: u16,
            }),
            /// SPI Interrupt Status
            INTSTAT: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// Slave Select Assert.
                SSA: u1,
                /// Slave Select Deassert.
                SSD: u1,
                reserved8: u2,
                /// Master Idle status flag.
                MSTIDLE: u1,
                padding: u23,
            }),
            reserved3584: [2516]u8,
            /// FIFO configuration and enable register.
            FIFOCFG: mmio.Mmio(packed struct(u32) {
                /// Enable the transmit FIFO.
                ENABLETX: enum(u1) {
                    /// The transmit FIFO is not enabled.
                    DISABLED = 0x0,
                    /// The transmit FIFO is enabled.
                    ENABLED = 0x1,
                },
                /// Enable the receive FIFO.
                ENABLERX: enum(u1) {
                    /// The receive FIFO is not enabled.
                    DISABLED = 0x0,
                    /// The receive FIFO is enabled.
                    ENABLED = 0x1,
                },
                reserved4: u2,
                /// FIFO size configuration. This is a read-only field. 0x0 = FIFO is configured as 16 entries of 8 bits. 0x1, 0x2, 0x3 = not applicable to USART.
                SIZE: u2,
                reserved12: u6,
                /// DMA configuration for transmit.
                DMATX: enum(u1) {
                    /// DMA is not used for the transmit function.
                    DISABLED = 0x0,
                    /// Trigger DMA for the transmit function if the FIFO is not full. Generally, data interrupts would be disabled if DMA is enabled.
                    ENABLED = 0x1,
                },
                /// DMA configuration for receive.
                DMARX: enum(u1) {
                    /// DMA is not used for the receive function.
                    DISABLED = 0x0,
                    /// Trigger DMA for the receive function if the FIFO is not empty. Generally, data interrupts would be disabled if DMA is enabled.
                    ENABLED = 0x1,
                },
                /// Wake-up for transmit FIFO level. This allows the device to be woken from reduced power modes (up to power-down, as long as the peripheral function works in that power mode) without enabling the TXLVL interrupt. Only DMA wakes up, processes data, and goes back to sleep. The CPU will remain stopped until woken by another cause, such as DMA completion. See Hardware Wake-up control register.
                WAKETX: enum(u1) {
                    /// Only enabled interrupts will wake up the device form reduced power modes.
                    DISABLED = 0x0,
                    /// A device wake-up for DMA will occur if the transmit FIFO level reaches the value specified by TXLVL in FIFOTRIG, even when the TXLVL interrupt is not enabled.
                    ENABLED = 0x1,
                },
                /// Wake-up for receive FIFO level. This allows the device to be woken from reduced power modes (up to power-down, as long as the peripheral function works in that power mode) without enabling the TXLVL interrupt. Only DMA wakes up, processes data, and goes back to sleep. The CPU will remain stopped until woken by another cause, such as DMA completion. See Hardware Wake-up control register.
                WAKERX: enum(u1) {
                    /// Only enabled interrupts will wake up the device form reduced power modes.
                    DISABLED = 0x0,
                    /// A device wake-up for DMA will occur if the receive FIFO level reaches the value specified by RXLVL in FIFOTRIG, even when the RXLVL interrupt is not enabled.
                    ENABLED = 0x1,
                },
                /// Empty command for the transmit FIFO. When a 1 is written to this bit, the TX FIFO is emptied.
                EMPTYTX: u1,
                /// Empty command for the receive FIFO. When a 1 is written to this bit, the RX FIFO is emptied.
                EMPTYRX: u1,
                /// Pop FIFO for debug reads.
                POPDBG: enum(u1) {
                    /// Debug reads of the FIFO do not pop the FIFO.
                    DO_NOT_POP = 0x0,
                    /// A debug read will cause the FIFO to pop.
                    POP = 0x1,
                },
                padding: u13,
            }),
            /// FIFO status register.
            FIFOSTAT: mmio.Mmio(packed struct(u32) {
                /// TX FIFO error. Will be set if a transmit FIFO error occurs. This could be an overflow caused by pushing data into a full FIFO, or by an underflow if the FIFO is empty when data is needed. Cleared by writing a 1 to this bit.
                TXERR: u1,
                /// RX FIFO error. Will be set if a receive FIFO overflow occurs, caused by software or DMA not emptying the FIFO fast enough. Cleared by writing a 1 to this bit.
                RXERR: u1,
                reserved3: u1,
                /// Peripheral interrupt. When 1, this indicates that the peripheral function has asserted an interrupt. The details can be found by reading the peripheral's STAT register.
                PERINT: u1,
                /// Transmit FIFO empty. When 1, the transmit FIFO is empty. The peripheral may still be processing the last piece of data.
                TXEMPTY: u1,
                /// Transmit FIFO not full. When 1, the transmit FIFO is not full, so more data can be written. When 0, the transmit FIFO is full and another write would cause it to overflow.
                TXNOTFULL: u1,
                /// Receive FIFO not empty. When 1, the receive FIFO is not empty, so data can be read. When 0, the receive FIFO is empty.
                RXNOTEMPTY: u1,
                /// Receive FIFO full. When 1, the receive FIFO is full. Data needs to be read out to prevent the peripheral from causing an overflow.
                RXFULL: u1,
                /// Transmit FIFO current level. A 0 means the TX FIFO is currently empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other values tell how much data is actually in the TX FIFO at the point where the read occurs. If the TX FIFO is full, the TXEMPTY and TXNOTFULL flags will be 0.
                TXLVL: u5,
                reserved16: u3,
                /// Receive FIFO current level. A 0 means the RX FIFO is currently empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other values tell how much data is actually in the RX FIFO at the point where the read occurs. If the RX FIFO is full, the RXFULL and RXNOTEMPTY flags will be 1.
                RXLVL: u5,
                padding: u11,
            }),
            /// FIFO trigger settings for interrupt and DMA request.
            FIFOTRIG: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMATX in FIFOCFG is set.
                TXLVLENA: enum(u1) {
                    /// Transmit FIFO level does not generate a FIFO level trigger.
                    DISABLED = 0x0,
                    /// An trigger will be generated if the transmit FIFO level reaches the value specified by the TXLVL field in this register.
                    ENABLED = 0x1,
                },
                /// Receive FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMARX in FIFOCFG is set.
                RXLVLENA: enum(u1) {
                    /// Receive FIFO level does not generate a FIFO level trigger.
                    DISABLED = 0x0,
                    /// An trigger will be generated if the receive FIFO level reaches the value specified by the RXLVL field in this register.
                    ENABLED = 0x1,
                },
                reserved8: u6,
                /// Transmit FIFO level trigger point. This field is used only when TXLVLENA = 1. If enabled to do so, the FIFO level can wake up the device just enough to perform DMA, then return to the reduced power mode. See Hardware Wake-up control register. 0 = trigger when the TX FIFO becomes empty. 1 = trigger when the TX FIFO level decreases to one entry. 15 = trigger when the TX FIFO level decreases to 15 entries (is no longer full).
                TXLVL: u4,
                reserved16: u4,
                /// Receive FIFO level trigger point. The RX FIFO level is checked when a new piece of data is received. This field is used only when RXLVLENA = 1. If enabled to do so, the FIFO level can wake up the device just enough to perform DMA, then return to the reduced power mode. See Hardware Wake-up control register. 0 = trigger when the RX FIFO has received one entry (is no longer empty). 1 = trigger when the RX FIFO has received two entries. 15 = trigger when the RX FIFO has received 16 entries (has become full).
                RXLVL: u4,
                padding: u12,
            }),
            reserved3600: [4]u8,
            /// FIFO interrupt enable set (enable) and read register.
            FIFOINTENSET: mmio.Mmio(packed struct(u32) {
                /// Determines whether an interrupt occurs when a transmit error occurs, based on the TXERR flag in the FIFOSTAT register.
                TXERR: enum(u1) {
                    /// No interrupt will be generated for a transmit error.
                    DISABLED = 0x0,
                    /// An interrupt will be generated when a transmit error occurs.
                    ENABLED = 0x1,
                },
                /// Determines whether an interrupt occurs when a receive error occurs, based on the RXERR flag in the FIFOSTAT register.
                RXERR: enum(u1) {
                    /// No interrupt will be generated for a receive error.
                    DISABLED = 0x0,
                    /// An interrupt will be generated when a receive error occurs.
                    ENABLED = 0x1,
                },
                /// Determines whether an interrupt occurs when a the transmit FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.
                TXLVL: enum(u1) {
                    /// No interrupt will be generated based on the TX FIFO level.
                    DISABLED = 0x0,
                    /// If TXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the TX FIFO level decreases to the level specified by TXLVL in the FIFOTRIG register.
                    ENABLED = 0x1,
                },
                /// Determines whether an interrupt occurs when a the receive FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.
                RXLVL: enum(u1) {
                    /// No interrupt will be generated based on the RX FIFO level.
                    DISABLED = 0x0,
                    /// If RXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the when the RX FIFO level increases to the level specified by RXLVL in the FIFOTRIG register.
                    ENABLED = 0x1,
                },
                padding: u28,
            }),
            /// FIFO interrupt enable clear (disable) and read register.
            FIFOINTENCLR: mmio.Mmio(packed struct(u32) {
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                TXERR: u1,
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                RXERR: u1,
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                TXLVL: u1,
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                RXLVL: u1,
                padding: u28,
            }),
            /// FIFO interrupt status register.
            FIFOINTSTAT: mmio.Mmio(packed struct(u32) {
                /// TX FIFO error.
                TXERR: u1,
                /// RX FIFO error.
                RXERR: u1,
                /// Transmit FIFO level interrupt.
                TXLVL: u1,
                /// Receive FIFO level interrupt.
                RXLVL: u1,
                /// Peripheral interrupt.
                PERINT: u1,
                padding: u27,
            }),
            reserved3616: [4]u8,
            /// FIFO write data.
            FIFOWR: mmio.Mmio(packed struct(u32) {
                /// Transmit data to the FIFO.
                TXDATA: u16,
                /// Transmit slave select. This field asserts SSEL0 in master mode. The output on the pin is active LOW by default.
                TXSSEL0_N: enum(u1) {
                    /// SSEL0 asserted.
                    ASSERTED = 0x0,
                    /// SSEL0 not asserted.
                    NOT_ASSERTED = 0x1,
                },
                /// Transmit slave select. This field asserts SSEL1 in master mode. The output on the pin is active LOW by default.
                TXSSEL1_N: enum(u1) {
                    /// SSEL1 asserted.
                    ASSERTED = 0x0,
                    /// SSEL1 not asserted.
                    NOT_ASSERTED = 0x1,
                },
                /// Transmit slave select. This field asserts SSEL2 in master mode. The output on the pin is active LOW by default.
                TXSSEL2_N: enum(u1) {
                    /// SSEL2 asserted.
                    ASSERTED = 0x0,
                    /// SSEL2 not asserted.
                    NOT_ASSERTED = 0x1,
                },
                /// Transmit slave select. This field asserts SSEL3 in master mode. The output on the pin is active LOW by default.
                TXSSEL3_N: enum(u1) {
                    /// SSEL3 asserted.
                    ASSERTED = 0x0,
                    /// SSEL3 not asserted.
                    NOT_ASSERTED = 0x1,
                },
                /// End of transfer. The asserted SSEL will be deasserted at the end of a transfer and remain so far at least the time specified by the Transfer_delay value in the DLY register.
                EOT: enum(u1) {
                    /// SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data.
                    NOT_DEASSERTED = 0x0,
                    /// SSEL deasserted. This piece of data is treated as the end of a transfer. SSEL will be deasserted at the end of this piece of data.
                    DEASSERTED = 0x1,
                },
                /// End of frame. Between frames, a delay may be inserted, as defined by the Frame_delay value in the DLY register. The end of a frame may not be particularly meaningful if the Frame_delay value = 0. This control can be used as part of the support for frame lengths greater than 16 bits.
                EOF: enum(u1) {
                    /// Data not EOF. This piece of data transmitted is not treated as the end of a frame.
                    NOT_EOF = 0x0,
                    /// Data EOF. This piece of data is treated as the end of a frame, causing the Frame_delay time to be inserted before subsequent data is transmitted.
                    EOF = 0x1,
                },
                /// Receive Ignore. This allows data to be transmitted using the SPI without the need to read unneeded data from the receiver. Setting this bit simplifies the transmit process and can be used with the DMA.
                RXIGNORE: enum(u1) {
                    /// Read received data. Received data must be read in order to allow transmission to progress. SPI transmit will halt when the receive data FIFO is full. In slave mode, an overrun error will occur if received data is not read before new data is received.
                    READ = 0x0,
                    /// Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated.
                    IGNORE = 0x1,
                },
                reserved24: u1,
                /// Data Length. Specifies the data length from 4 to 16 bits. Note that transfer lengths greater than 16 bits are supported by implementing multiple sequential transmits. 0x0-2 = Reserved. 0x3 = Data transfer is 4 bits in length. 0x4 = Data transfer is 5 bits in length. 0xF = Data transfer is 16 bits in length.
                LEN: u4,
                padding: u4,
            }),
            reserved3632: [12]u8,
            /// FIFO read data.
            FIFORD: mmio.Mmio(packed struct(u32) {
                /// Received data from the FIFO.
                RXDATA: u16,
                /// Slave Select for receive. This field allows the state of the SSEL0 pin to be saved along with received data. The value will reflect the SSEL0 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.
                RXSSEL0_N: u1,
                /// Slave Select for receive. This field allows the state of the SSEL1 pin to be saved along with received data. The value will reflect the SSEL1 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.
                RXSSEL1_N: u1,
                /// Slave Select for receive. This field allows the state of the SSEL2 pin to be saved along with received data. The value will reflect the SSEL2 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.
                RXSSEL2_N: u1,
                /// Slave Select for receive. This field allows the state of the SSEL3 pin to be saved along with received data. The value will reflect the SSEL3 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.
                RXSSEL3_N: u1,
                /// Start of Transfer flag. This flag will be 1 if this is the first data after the SSELs went from deasserted to asserted (i.e., any previous transfer has ended). This information can be used to identify the first piece of data in cases where the transfer length is greater than 16 bits.
                SOT: u1,
                padding: u11,
            }),
            reserved3648: [12]u8,
            /// FIFO data read with no FIFO pop.
            FIFORDNOPOP: mmio.Mmio(packed struct(u32) {
                /// Received data from the FIFO.
                RXDATA: u16,
                /// Slave Select for receive.
                RXSSEL0_N: u1,
                /// Slave Select for receive.
                RXSSEL1_N: u1,
                /// Slave Select for receive.
                RXSSEL2_N: u1,
                /// Slave Select for receive.
                RXSSEL3_N: u1,
                /// Start of transfer flag.
                SOT: u1,
                padding: u11,
            }),
            reserved4092: [440]u8,
            /// Peripheral identification register.
            ID: mmio.Mmio(packed struct(u32) {
                /// Aperture: encoded as (aperture size/4K) -1, so 0x00 means a 4K aperture.
                APERTURE: u8,
                /// Minor revision of module implementation.
                MINOR_REV: u4,
                /// Major revision of module implementation.
                MAJOR_REV: u4,
                /// Module identifier for the selected function.
                ID: u16,
            }),
        };

        /// LPC5411x SPI Flash Interface (SPIFI)
        pub const SPIFI0 = extern struct {
            /// SPIFI control register
            CTRL: mmio.Mmio(packed struct(u32) {
                /// This field contains the number of serial clock periods without the processor reading data in memory mode, which will cause the SPIFI hardware to terminate the command by driving the CS pin high and negating the CMD bit in the Status register. (This allows the flash memory to enter a lower-power state.) If the processor reads data from the flash region after a time-out, the command in the Memory Command Register is issued again.
                TIMEOUT: u16,
                /// This field controls the minimum CS high time, expressed as a number of serial clock periods minus one.
                CSHIGH: u4,
                reserved21: u1,
                /// This bit allows conditioning of memory mode prefetches based on the AHB HPROT (instruction/data) access information. A 1 in this register means that the SPIFI will not attempt a speculative prefetch when it encounters data accesses.
                D_PRFTCH_DIS: u1,
                /// If this bit is 1 when a command ends, the SPIFI will assert its interrupt request output. See INTRQ in the status register for further details.
                INTEN: u1,
                /// SPI Mode 3 select.
                MODE3: enum(u1) {
                    /// SCK LOW. The SPIFI drives SCK low after the rising edge at which the last bit of each command is captured, and keeps it low while CS is HIGH.
                    SCK_LOW = 0x0,
                    /// SCK HIGH. the SPIFI keeps SCK high after the rising edge for the last bit of each command and while CS is HIGH, and drives it low after it drives CS LOW. (Known serial flash devices can handle either mode, but some devices may require a particular mode for proper operation.) MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final falling edge on SCK on which to sample the last data bit of the frame.
                    SCK_HIGH = 0x1,
                },
                reserved27: u3,
                /// Cache prefetching enable. The SPIFI includes an internal cache. A 1 in this bit disables prefetching of cache lines.
                PRFTCH_DIS: enum(u1) {
                    /// Enable. Cache prefetching enabled.
                    ENABLE = 0x0,
                    /// Disable. Disables prefetching of cache lines.
                    DISABLE = 0x1,
                },
                /// Select dual protocol.
                DUAL: enum(u1) {
                    /// Quad protocol. This protocol uses IO3:0.
                    QUAD = 0x0,
                    /// Dual protocol. This protocol uses IO1:0.
                    DUAL = 0x1,
                },
                /// Select active clock edge for input data.
                RFCLK: enum(u1) {
                    /// Rising edge. Read data is sampled on rising edges on the clock, as in classic SPI operation.
                    RISING_EDGE = 0x0,
                    /// Falling edge. Read data is sampled on falling edges of the clock, allowing a full serial clock of of time in order to maximize the serial clock frequency. MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final falling edge on SCK on which to sample the last data bit of the frame.
                    FALLING_EDGE = 0x1,
                },
                /// Feedback clock select.
                FBCLK: enum(u1) {
                    /// Internal clock. The SPIFI samples read data using an internal clock.
                    INTERNAL_CLOCK = 0x0,
                    /// Feedback clock. Read data is sampled using a feedback clock from the SCK pin. This allows slightly more time for each received bit. MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final falling edge on SCK on which to sample the last data bit of the frame.
                    FEEDBACK_CLOCK = 0x1,
                },
                /// A 1 in this bit enables the DMA Request output from the SPIFI. Set this bit only when a DMA channel is used to transfer data in peripheral mode. Do not set this bit when a DMA channel is used for memory-to-memory transfers from the SPIFI memory area. DMAEN should only be used in Command mode.
                DMAEN: u1,
            }),
            /// SPIFI command register
            CMD: mmio.Mmio(packed struct(u32) {
                /// Except when the POLL bit in this register is 1, this field controls how many data bytes are in the command. 0 indicates that the command does not contain a data field.
                DATALEN: u14,
                /// This bit should be written as 1 only with an opcode that a) contains an input data field, and b) causes the serial flash device to return byte status repetitively (e.g., a Read Status command). When this bit is 1, the SPIFI hardware continues to read bytes until the test specified by the DATALEN field is met. The hardware tests the bit in each status byte selected by DATALEN bits 2:0, until a bit is found that is equal to DATALEN bit 3. When the test succeeds, the SPIFI captures the byte that meets this test so that it can be read from the Data Register, and terminates the command by raising CS. The end-of-command interrupt can be enabled to inform software when this occurs
                POLL: u1,
                /// If the DATALEN field is not zero, this bit controls the direction of the data:
                DOUT: enum(u1) {
                    /// Input from serial flash.
                    INPUT = 0x0,
                    /// Output to serial flash.
                    OUTPUT = 0x1,
                },
                /// This field controls how many intermediate bytes precede the data. (Each such byte may require 8 or 2 SCK cycles, depending on whether the intermediate field is in serial, 2-bit, or 4-bit format.) Intermediate bytes are output by the SPIFI, and include post-address control information, dummy and delay bytes. See the description of the Intermediate Data register for the contents of such bytes.
                INTLEN: u3,
                /// This field controls how the fields of the command are sent.
                FIELDFORM: enum(u2) {
                    /// All serial. All fields of the command are serial.
                    ALL_SERIAL = 0x0,
                    /// Quad/dual data. Data field is quad/dual, other fields are serial.
                    QUAD_DUAL_DATA = 0x1,
                    /// Serial opcode. Opcode field is serial. Other fields are quad/dual.
                    SERIAL_OPCODE = 0x2,
                    /// All quad/dual. All fields of the command are in quad/dual format.
                    ALL_QUAD_DUAL = 0x3,
                },
                /// This field controls the opcode and address fields.
                FRAMEFORM: enum(u3) {
                    /// Opcode. Opcode only, no address.
                    OPCODE = 0x1,
                    /// Opcode one byte. Opcode, least significant byte of address.
                    OPCODE_1_BYTE = 0x2,
                    /// Opcode two bytes. Opcode, two least significant bytes of address.
                    OPCODE_2_BYTES = 0x3,
                    /// Opcode three bytes. Opcode, three least significant bytes of address.
                    OPCODE_3_BYTES = 0x4,
                    /// Opcode four bytes. Opcode, 4 bytes of address.
                    OPCODE_4_BYTES = 0x5,
                    /// No opcode three bytes. No opcode, 3 least significant bytes of address.
                    NO_OPCODE_3_BYTES = 0x6,
                    /// No opcode four bytes. No opcode, 4 bytes of address.
                    NO_OPCODE_4_BYTES = 0x7,
                    _,
                },
                /// The opcode of the command (not used for some FRAMEFORM values).
                OPCODE: u8,
            }),
            /// SPIFI address register
            ADDR: mmio.Mmio(packed struct(u32) {
                /// Address.
                ADDRESS: u32,
            }),
            /// SPIFI intermediate data register
            IDATA: mmio.Mmio(packed struct(u32) {
                /// Value of intermediate bytes.
                IDATA: u32,
            }),
            /// SPIFI limit register
            CLIMIT: mmio.Mmio(packed struct(u32) {
                /// Zero-based upper limit of cacheable memory
                CLIMIT: u32,
            }),
            /// SPIFI data register
            DATA: mmio.Mmio(packed struct(u32) {
                /// Input or output data
                DATA: u32,
            }),
            /// SPIFI memory command register
            MCMD: mmio.Mmio(packed struct(u32) {
                reserved14: u14,
                /// This bit should be written as 0.
                POLL: u1,
                /// This bit should be written as 0.
                DOUT: u1,
                /// This field controls how many intermediate bytes precede the data. (Each such byte may require 8 or 2 SCK cycles, depending on whether the intermediate field is in serial, 2-bit, or 4-bit format.) Intermediate bytes are output by the SPIFI, and include post-address control information, dummy and delay bytes. See the description of the Intermediate Data register for the contents of such bytes.
                INTLEN: u3,
                /// This field controls how the fields of the command are sent.
                FIELDFORM: enum(u2) {
                    /// All serial. All fields of the command are serial.
                    ALL_SERIAL = 0x0,
                    /// Quad/dual data. Data field is quad/dual, other fields are serial.
                    QUAD_DUAL_DATA = 0x1,
                    /// Serial opcode. Opcode field is serial. Other fields are quad/dual.
                    SERIAL_OPCODE = 0x2,
                    /// All quad/dual. All fields of the command are in quad/dual format.
                    ALL_QUAD_DUAL = 0x3,
                },
                /// This field controls the opcode and address fields.
                FRAMEFORM: enum(u3) {
                    /// Opcode. Opcode only, no address.
                    OPCODE = 0x1,
                    /// Opcode one byte. Opcode, least-significant byte of address.
                    OPCODE_1_BYTE = 0x2,
                    /// Opcode two bytes. Opcode, 2 least-significant bytes of address.
                    OPCODE_2_BYTES = 0x3,
                    /// Opcode three bytes. Opcode, 3 least-significant bytes of address.
                    OPCODE_3_BYTES = 0x4,
                    /// Opcode four bytes. Opcode, 4 bytes of address.
                    OPCODE_4_BYTES = 0x5,
                    /// No opcode three bytes. No opcode, 3 least-significant bytes of address.
                    NO_OPCODE_3_BYTES = 0x6,
                    /// No opcode, 4 bytes of address.
                    NO_OPCODE_4_BYTES = 0x7,
                    _,
                },
                /// The opcode of the command (not used for some FRAMEFORM values).
                OPCODE: u8,
            }),
            /// SPIFI status register
            STAT: mmio.Mmio(packed struct(u32) {
                /// This bit is set when software successfully writes the Memory Command register, and is cleared by Reset or by writing a 1 to the RESET bit in this register.
                MCINIT: u1,
                /// This bit is 1 when the Command register is written. It is cleared by a hardware reset, a write to the RESET bit in this register, or the deassertion of CS which indicates that the command has completed communication with the SPI Flash.
                CMD: u1,
                reserved4: u2,
                /// Write a 1 to this bit to abort a current command or memory mode. This bit is cleared when the hardware is ready for a new command to be written to the Command register.
                RESET: u1,
                /// This bit reflects the SPIFI interrupt request. Write a 1 to this bit to clear it. This bit is set when a CMD was previously 1 and has been cleared due to the deassertion of CS.
                INTRQ: u1,
                padding: u26,
            }),
        };

        /// LPC5460x System configuration (SYSCON)
        pub const SYSCON = extern struct {
            reserved16: [16]u8,
            /// AHB multilayer matrix priority control
            AHBMATPRIO: mmio.Mmio(packed struct(u32) {
                /// I-Code bus priority.
                PRI_ICODE: u2,
                /// D-Code bus priority.
                PRI_DCODE: u2,
                /// System bus priority.
                PRI_SYS: u2,
                /// DMA controller priority.
                PRI_DMA: u4,
                /// Ethernet DMA priority.
                PRI_ETH: u2,
                /// LCD DMA priority.
                PRI_LCD: u2,
                /// USB0 DMA priority.
                PRI_USB0: u2,
                /// USB1 DMA priority.
                PRI_USB1: u2,
                /// SDIO priority.
                PRI_SDIO: u2,
                /// MCAN1 priority.
                PRI_MCAN1: u2,
                /// MCAN2 priority.
                PRI_MCAN2: u2,
                /// SHA priority.
                PRI_SHA: u2,
                padding: u6,
            }),
            reserved64: [44]u8,
            /// System tick counter calibration
            SYSTCKCAL: mmio.Mmio(packed struct(u32) {
                /// System tick timer calibration value.
                CAL: u24,
                /// Initial value for the Systick timer.
                SKEW: u1,
                /// Initial value for the Systick timer.
                NOREF: u1,
                padding: u6,
            }),
            reserved72: [4]u8,
            /// NMI Source Select
            NMISRC: mmio.Mmio(packed struct(u32) {
                /// The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) for the Cortex-M4, if enabled by NMIENM4.
                IRQM4: u6,
                reserved31: u25,
                /// Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by IRQM4.
                NMIENM4: u1,
            }),
            /// Asynchronous APB Control
            ASYNCAPBCTRL: mmio.Mmio(packed struct(u32) {
                /// Enables the asynchronous APB bridge and subsystem.
                ENABLE: enum(u1) {
                    /// Disabled. Asynchronous APB bridge is disabled.
                    DISABLED = 0x0,
                    /// Enabled. Asynchronous APB bridge is enabled.
                    ENABLED = 0x1,
                },
                padding: u31,
            }),
            reserved192: [112]u8,
            /// POR captured value of port n
            PIOPORCAP: [2]mmio.Mmio(packed struct(u32) {
                /// State of PIOn_31 through PIOn_0 at power-on reset
                PIOPORCAP: u32,
            }),
            reserved208: [8]u8,
            /// Reset captured value of port n
            PIORESCAP: [2]mmio.Mmio(packed struct(u32) {
                /// State of PIOn_31 through PIOn_0 for resets other than POR.
                PIORESCAP: u32,
            }),
            reserved256: [40]u8,
            /// Peripheral reset control n
            PRESETCTRL0: mmio.Mmio(packed struct(u32) {
                reserved7: u7,
                /// Flash controller reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FLASH_RST: u1,
                /// Flash accelerator reset control. Note that the FMC must not be reset while executing from flash, and must be reconfigured after reset. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FMC_RST: u1,
                /// EEPROM reset control.
                EEPROM_RST: u1,
                /// SPIFI reset control.
                SPIFI_RST: u1,
                /// Input mux reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                MUX_RST: u1,
                reserved13: u1,
                /// IOCON reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                IOCON_RST: u1,
                /// GPIO0 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                GPIO0_RST: u1,
                /// GPIO1 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                GPIO1_RST: u1,
                /// GPIO2 reset control.
                GPIO2_RST: u1,
                /// GPIO3 reset control.
                GPIO3_RST: u1,
                /// Pin interrupt (PINT) reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                PINT_RST: u1,
                /// Grouped interrupt (GINT) reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                GINT_RST: u1,
                /// DMA0 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                DMA0_RST: u1,
                /// CRC generator reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                CRC_RST: u1,
                /// Watchdog timer reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                WWDT_RST: u1,
                reserved27: u4,
                /// ADC0 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                ADC0_RST: u1,
                padding: u4,
            }),
            /// Peripheral reset control n
            PRESETCTRL1: mmio.Mmio(packed struct(u32) {
                /// Multi-rate timer (MRT) reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                MRT_RST: u1,
                reserved2: u1,
                /// State configurable timer 0 (SCT0) reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                SCT0_RST: u1,
                reserved7: u4,
                /// 0 = Clear reset to this function.
                MCAN0_RST: u1,
                /// 0 = Clear reset to this function.
                MCAN1_RST: u1,
                reserved10: u1,
                /// Micro-tick Timer reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                UTICK_RST: u1,
                /// Flexcomm 0 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FC0_RST: u1,
                /// Flexcomm 1 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FC1_RST: u1,
                /// Flexcomm 2 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FC2_RST: u1,
                /// Flexcomm 3 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FC3_RST: u1,
                /// Flexcomm 4 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FC4_RST: u1,
                /// Flexcomm 5 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FC5_RST: u1,
                /// Flexcomm 6 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FC6_RST: u1,
                /// Flexcomm 7 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                FC7_RST: u1,
                /// Digital microphone interface reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                DMIC_RST: u1,
                reserved22: u2,
                /// CTIMER2 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function
                CTIMER2_RST: u1,
                reserved25: u2,
                /// USB0 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                USB0D_RST: u1,
                /// CTIMER0 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                CTIMER0_RST: u1,
                /// CTIMER1 reset control. 0 = Clear reset to this function. 1 = Assert reset to this function.
                CTIMER1_RST: u1,
                padding: u4,
            }),
            /// Peripheral reset control n
            PRESETCTRL2: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// LCD reset control.
                LCD_RST: u1,
                /// SDIO reset control.
                SDIO_RST: u1,
                /// USB1 Host reset control.
                USB1H_RST: u1,
                /// USB1 Device reset control.
                USB1D_RST: u1,
                /// USB1 RAM reset control.
                USB1RAM_RST: u1,
                /// EMC reset control.
                EMC_RESET: u1,
                /// Ethernet reset control.
                ETH_RST: u1,
                /// GPIO4 reset control.
                GPIO4_RST: u1,
                /// GPIO5 reset control.
                GPIO5_RST: u1,
                /// AES reset control.
                AES_RST: u1,
                /// OTP reset control.
                OTP_RST: u1,
                /// RNG reset control.
                RNG_RST: u1,
                /// Flexcomm 8 reset control.
                FC8_RST: u1,
                /// Flexcomm 9 reset control.
                FC9_RST: u1,
                /// USB0 HOST master reset control.
                USB0HMR_RST: u1,
                /// USB0 HOST slave reset control.
                USB0HSL_RST: u1,
                /// SHA reset control.
                SHA_RST: u1,
                /// Smart card 0 reset control.
                SC0_RST: u1,
                /// Smart card 1 reset control.
                SC1_RST: u1,
                padding: u11,
            }),
            reserved288: [20]u8,
            /// Set bits in PRESETCTRLn
            PRESETCTRLSET: [3]mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register sets the corresponding bit or bits in the PRESETCTRLn register, if they are implemented. Bits that do not correspond to defined bits in PRESETCTRLn are reserved and only zeroes should be written to them.
                RST_SET: u32,
            }),
            reserved320: [20]u8,
            /// Clear bits in PRESETCTRLn
            PRESETCTRLCLR: [3]mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register clears the corresponding bit or bits in the PRESETCTRLn register, if they are implemented. Bits that do not correspond to defined bits in PRESETCTRLn are reserved and only zeroes should be written to them.
                RST_CLR: u32,
            }),
            reserved496: [164]u8,
            /// System reset status register
            SYSRSTSTAT: mmio.Mmio(packed struct(u32) {
                /// POR reset status
                POR: enum(u1) {
                    /// No POR detected
                    NO_POR_DETECTED = 0x0,
                    /// POR detected. Writing a one clears this reset.
                    POR_DETECTED = 0x1,
                },
                /// Status of the external RESET pin. External reset status
                EXTRST: enum(u1) {
                    /// No reset event detected.
                    NO_RESET_DETECTED = 0x0,
                    /// Reset detected. Writing a one clears this reset.
                    RESET_DETECTED = 0x1,
                },
                /// Status of the Watchdog reset
                WDT: enum(u1) {
                    /// No WDT reset detected
                    NO_WDT_RESET_DETECTED = 0x0,
                    /// WDT reset detected. Writing a one clears this reset.
                    WDT_RESET_DETECTED = 0x1,
                },
                /// Status of the Brown-out detect reset
                BOD: enum(u1) {
                    /// No BOD reset detected
                    NO_BOD_RESET_DETECTED = 0x0,
                    /// BOD reset detected. Writing a one clears this reset.
                    BOD_RESET_DETECTED = 0x1,
                },
                /// Status of the software system reset
                SYSRST: enum(u1) {
                    /// No System reset detected
                    NO_SYSTEM_RESET_DETECTED = 0x0,
                    /// System reset detected. Writing a one clears this reset.
                    SYSTEM_RESET_DETECTED = 0x1,
                },
                padding: u27,
            }),
            reserved512: [12]u8,
            /// AHB Clock control n
            AHBCLKCTRL0: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// Enables the clock for the Boot ROM. 0 = Disable; 1 = Enable.
                ROM: u1,
                reserved3: u1,
                /// Enables the clock for SRAM1. 0 = Disable; 1 = Enable.
                SRAM1: u1,
                /// Enables the clock for SRAM2. 0 = Disable; 1 = Enable.
                SRAM2: u1,
                /// Enables the clock for SRAM3.
                SRAM3: u1,
                reserved7: u1,
                /// Enables the clock for the flash controller. 0 = Disable; 1 = Enable. This clock is needed for flash programming, not for flash read.
                FLASH: u1,
                /// Enables the clock for the Flash accelerator. 0 = Disable; 1 = Enable. This clock is needed if the flash is being read.
                FMC: u1,
                /// Enables the clock for EEPROM.
                EEPROM: u1,
                /// Enables the clock for the SPIFI. 0 = Disable; 1 = Enable.
                SPIFI: u1,
                /// Enables the clock for the input muxes. 0 = Disable; 1 = Enable.
                INPUTMUX: u1,
                reserved13: u1,
                /// Enables the clock for the IOCON block. 0 = Disable; 1 = Enable.
                IOCON: u1,
                /// Enables the clock for the GPIO0 port registers. 0 = Disable; 1 = Enable.
                GPIO0: u1,
                /// Enables the clock for the GPIO1 port registers. 0 = Disable; 1 = Enable.
                GPIO1: u1,
                /// Enables the clock for the GPIO2 port registers.
                GPIO2: u1,
                /// Enables the clock for the GPIO3 port registers.
                GPIO3: u1,
                /// Enables the clock for the pin interrupt block.0 = Disable; 1 = Enable.
                PINT: u1,
                /// Enables the clock for the grouped pin interrupt block. 0 = Disable; 1 = Enable.
                GINT: u1,
                /// Enables the clock for the DMA controller. 0 = Disable; 1 = Enable.
                DMA: u1,
                /// Enables the clock for the CRC engine. 0 = Disable; 1 = Enable.
                CRC: u1,
                /// Enables the clock for the Watchdog Timer. 0 = Disable; 1 = Enable.
                WWDT: u1,
                /// Enables the bus clock for the RTC. 0 = Disable; 1 = Enable.
                RTC: u1,
                reserved27: u3,
                /// Enables the clock for the ADC0 register interface.
                ADC0: u1,
                padding: u4,
            }),
            /// AHB Clock control n
            AHBCLKCTRL1: mmio.Mmio(packed struct(u32) {
                /// Enables the clock for the Multi-Rate Timer.
                MRT: u1,
                /// Enables the clock for the Repetitive Interrupt Timer.
                RIT: u1,
                /// Enables the clock for SCT0.
                SCT0: u1,
                reserved7: u4,
                /// Enables the clock for MCAN0.
                MCAN0: u1,
                /// Enables the clock for MCAN1.
                MCAN1: u1,
                reserved10: u1,
                /// Enables the clock for the Micro-tick Timer. 0 = Disable; 1 = Enable.
                UTICK: u1,
                /// Enables the clock for Flexcomm 0. 0 = Disable; 1 = Enable.
                FLEXCOMM0: u1,
                /// Enables the clock for Flexcomm 1. 0 = Disable; 1 = Enable.
                FLEXCOMM1: u1,
                /// Enables the clock for Flexcomm 2. 0 = Disable; 1 = Enable.
                FLEXCOMM2: u1,
                /// Enables the clock for Flexcomm 3. 0 = Disable; 1 = Enable.
                FLEXCOMM3: u1,
                /// Enables the clock for Flexcomm 4. 0 = Disable; 1 = Enable.
                FLEXCOMM4: u1,
                /// Enables the clock for Flexcomm 5. 0 = Disable; 1 = Enable.
                FLEXCOMM5: u1,
                /// Enables the clock for Flexcomm 6. 0 = Disable; 1 = Enable.
                FLEXCOMM6: u1,
                /// Enables the clock for Flexcomm 7. 0 = Disable; 1 = Enable.
                FLEXCOMM7: u1,
                /// Enables the clock for the digital microphone interface. 0 = Disable; 1 = Enable.
                DMIC: u1,
                reserved22: u2,
                /// Enables the clock for CTIMER 2. 0 = Disable; 1 = Enable.
                CTIMER2: u1,
                reserved25: u2,
                /// Enables the clock for the USB0 device interface. 0 = Disable; 1 = Enable.
                USB0D: u1,
                /// Enables the clock for timer CTIMER0. 0 = Disable; 1 = Enable.
                CTIMER0: u1,
                /// Enables the clock for timer CTIMER1. 0 = Disable; 1 = Enable.
                CTIMER1: u1,
                padding: u4,
            }),
            /// AHB Clock control n
            AHBCLKCTRL2: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Enables the clock for the LCD interface.
                LCD: u1,
                /// Enables the clock for the SDIO interface.
                SDIO: u1,
                /// Enables the clock for the USB1 host interface.
                USB1H: u1,
                /// Enables the clock for the USB1 device interface.
                USB1D: u1,
                /// Enables the clock for the USB1 RAM interface.
                USB1RAM: u1,
                /// Enables the clock for the EMC interface.
                EMC: u1,
                /// Enables the clock for the ethernet interface.
                ETH: u1,
                /// Enables the clock for the GPIO4 interface.
                GPIO4: u1,
                /// Enables the clock for the GPIO5 interface.
                GPIO5: u1,
                /// Enables the clock for the AES interface.
                AES: u1,
                /// Enables the clock for the OTP interface.
                OTP: u1,
                /// Enables the clock for the RNG interface.
                RNG: u1,
                /// Enables the clock for the Flexcomm8 interface.
                FLEXCOMM8: u1,
                /// Enables the clock for the Flexcomm9 interface.
                FLEXCOMM9: u1,
                /// Enables the clock for the USB host master interface.
                USB0HMR: u1,
                /// Enables the clock for the USB host slave interface.
                USB0HSL: u1,
                /// Enables the clock for the SHA interface.
                SHA0: u1,
                /// Enables the clock for the Smart card0 interface.
                SC0: u1,
                /// Enables the clock for the Smart card1 interface.
                SC1: u1,
                padding: u11,
            }),
            reserved544: [20]u8,
            /// Set bits in AHBCLKCTRLn
            AHBCLKCTRLSET: [3]mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register sets the corresponding bit or bits in the AHBCLKCTRLn register, if they are implemented. Bits that do not correspond to defined bits in AHBCLKCTRLn are reserved and only zeroes should be written to them.
                CLK_SET: u32,
            }),
            reserved576: [20]u8,
            /// Clear bits in AHBCLKCTRLn
            AHBCLKCTRLCLR: [3]mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register clears the corresponding bit or bits in the AHBCLKCTRLn register, if they are implemented. Bits that do not correspond to defined bits in AHBCLKCTRLn are reserved and only zeroes should be written to them.
                CLK_CLR: u32,
            }),
            reserved640: [52]u8,
            /// Main clock source select A
            MAINCLKSELA: mmio.Mmio(packed struct(u32) {
                /// Clock source for main clock source selector A
                SEL: enum(u2) {
                    /// FRO 12 MHz (fro_12m)
                    FRO_12_MHZ = 0x0,
                    /// CLKIN (clk_in)
                    CLKIN = 0x1,
                    /// Watchdog oscillator (wdt_clk)
                    WATCHDOG_OSCILLATOR = 0x2,
                    /// FRO 96 or 48 MHz (fro_hf)
                    FRO_HF = 0x3,
                },
                padding: u30,
            }),
            /// Main clock source select B
            MAINCLKSELB: mmio.Mmio(packed struct(u32) {
                /// Clock source for main clock source selector B. Selects the clock source for the main clock.
                SEL: enum(u2) {
                    /// MAINCLKSELA. Use the clock source selected in MAINCLKSELA register.
                    MAINCLKSELA = 0x0,
                    /// System PLL output (pll_clk)
                    SYSTEM_PLL_OUTPUT = 0x2,
                    /// RTC oscillator 32 kHz output (32k_clk)
                    RTC_OSC_OUTPUT = 0x3,
                    _,
                },
                padding: u30,
            }),
            /// CLKOUT clock source select A
            CLKOUTSELA: mmio.Mmio(packed struct(u32) {
                /// CLKOUT clock source selection
                SEL: enum(u3) {
                    /// Main clock (main_clk)
                    MAIN_CLOCK = 0x0,
                    /// CLKIN (clk_in)
                    CLKIN = 0x1,
                    /// Watchdog oscillator (wdt_clk)
                    WATCHDOG_OSCILLATOR = 0x2,
                    /// FRO 96 or 48 MHz (fro_hf)
                    FRO_HF = 0x3,
                    /// PLL output (pll_clk)
                    SYSTEM_PLL_OUTPUT = 0x4,
                    /// USB PLL clock (usb_pll_clk)
                    USB_PLL_CLOCK = 0x5,
                    /// Audio PLL clock (audio_pll_clk)
                    AUDIO_PLL_OUTPUT = 0x6,
                    /// RTC oscillator 32 kHz output (32k_clk)
                    RTC_OSC_OUTPUT = 0x7,
                },
                padding: u29,
            }),
            reserved656: [4]u8,
            /// PLL clock source select
            SYSPLLCLKSEL: mmio.Mmio(packed struct(u32) {
                /// System PLL clock source selection.
                SEL: enum(u3) {
                    /// FRO 12 MHz (fro_12m)
                    FRO_12_MHZ = 0x0,
                    /// CLKIN (clk_in)
                    CLKIN = 0x1,
                    /// Watchdog oscillator (wdt_clk)
                    WATCHDOG_OSCILLATOR = 0x2,
                    /// RTC oscillator 32 kHz output (32k_clk)
                    RTC_OSC_OUTPUT = 0x3,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            reserved664: [4]u8,
            /// Audio PLL clock source select
            AUDPLLCLKSEL: mmio.Mmio(packed struct(u32) {
                /// Audio PLL clock source selection.
                SEL: enum(u3) {
                    /// FRO 12 MHz (fro_12m)
                    FRO_12_MHZ = 0x0,
                    /// CLKIN (clk_in)
                    CLKIN = 0x1,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            reserved672: [4]u8,
            /// SPIFI clock source select
            SPIFICLKSEL: mmio.Mmio(packed struct(u32) {
                /// System PLL clock source selection
                SEL: enum(u3) {
                    /// Main clock (main_clk)
                    MAIN_CLOCK = 0x0,
                    /// System PLL output (pll_clk)
                    SYSTEM_PLL_OUTPUT = 0x1,
                    /// USB PLL clock (usb_pll_clk)
                    USB_PLL_OUTPUT = 0x2,
                    /// FRO 96 or 48 MHz (fro_hf)
                    FRO_HF = 0x3,
                    /// Audio PLL clock (audio_pll_clk)
                    AUDIO_PLL_OUTPUT = 0x4,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            /// ADC clock source select
            ADCCLKSEL: mmio.Mmio(packed struct(u32) {
                /// ADC clock source selection
                SEL: enum(u3) {
                    /// FRO 96 or 48 MHz (fro_hf)
                    FRO_HF = 0x0,
                    /// System PLL output (pll_clk)
                    SYSTEM_PLL_OUTPUT = 0x1,
                    /// USB PLL clock (usb_pll_clk)
                    USB_PLL_CLOCK = 0x2,
                    /// Audio PLL clock (audio_pll_clk)
                    AUDIO_PLL_CLOCK = 0x3,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            /// USB0 clock source select
            USB0CLKSEL: mmio.Mmio(packed struct(u32) {
                /// USB0 device clock source selection.
                SEL: enum(u3) {
                    /// FRO 96 or 48 MHz (fro_hf)
                    FRO_HF = 0x0,
                    /// System PLL output (pll_clk)
                    SYSTEM_PLL_OUTPUT = 0x1,
                    /// USB PLL clock (usb_pll_clk)
                    USB_PLL_CLOCK = 0x2,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            /// USB1 clock source select
            USB1CLKSEL: mmio.Mmio(packed struct(u32) {
                /// USB1 PHY clock source selection.
                SEL: enum(u3) {
                    /// Main clock (main_clk)
                    MAIN_CLOCK = 0x0,
                    /// System PLL output (pll_clk)
                    SYSTEM_PLL_OUTPUT = 0x1,
                    /// USB PLL clock (usb_pll_clk)
                    USB_PLL_CLOCK = 0x2,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            /// Flexcomm 0 clock source select
            FCLKSEL: [10]mmio.Mmio(packed struct(u32) {
                /// Flexcomm clock source selection. One per Flexcomm.
                SEL: enum(u3) {
                    /// FRO 12 MHz (fro_12m)
                    FRO_12_MHZ = 0x0,
                    /// FRO HF DIV (fro_hf_div)
                    FRO_HF_DIV = 0x1,
                    /// Audio PLL clock (audio_pll_clk)
                    AUDIO_PLL_OUTPUT = 0x2,
                    /// MCLK pin input, when selected in IOCON (mclk_in)
                    MCLK_INPUT = 0x3,
                    /// FRG clock, the output of the fractional rate generator (frg_clk)
                    FRG_CLOCK_OUTPUT = 0x4,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            reserved736: [8]u8,
            /// MCLK clock source select
            MCLKCLKSEL: mmio.Mmio(packed struct(u32) {
                /// MCLK source select. This may be used by Flexcomms that support I2S, and/or by the digital microphone subsystem.
                SEL: enum(u3) {
                    /// FRO HF DIV (fro_hf_div)
                    FRO_HF_DIV = 0x0,
                    /// Audio PLL clock (audio_pll_clk)
                    AUDIO_PLL_OUTPUT = 0x1,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            reserved744: [4]u8,
            /// Fractional Rate Generator clock source select
            FRGCLKSEL: mmio.Mmio(packed struct(u32) {
                /// Fractional Rate Generator clock source select.
                SEL: enum(u3) {
                    /// Main clock (main_clk)
                    MAIN_CLOCK = 0x0,
                    /// System PLL output (pll_clk)
                    SYSTEM_PLL_OUTPUT = 0x1,
                    /// FRO 12 MHz (fro_12m)
                    FRO_12_MHZ = 0x2,
                    /// FRO 96 or 48 MHz (fro_hf)
                    FRO_HF = 0x3,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            /// Digital microphone (DMIC) subsystem clock select
            DMICCLKSEL: mmio.Mmio(packed struct(u32) {
                /// DMIC (audio subsystem) clock source select.
                SEL: enum(u3) {
                    /// FRO 12 MHz (fro_12m)
                    FRO_12_MHZ = 0x0,
                    /// FRO HF DIV (fro_hf_div)
                    FRO_HF_DIV = 0x1,
                    /// Audio PLL clock (audio_pll_clk)
                    AUDIO_PLL_OUTPUT = 0x2,
                    /// MCLK pin input, when selected in IOCON (mclk_in)
                    MCLK_INPUT = 0x3,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            /// SCTimer/PWM clock source select
            SCTCLKSEL: mmio.Mmio(packed struct(u32) {
                /// SCT clock source select.
                SEL: enum(u3) {
                    /// Main clock (main_clk)
                    MAIN_CLOCK = 0x0,
                    /// System PLL output (pll_clk)
                    SYSTEM_PLL_OUTPUT = 0x1,
                    /// FRO 96 or 48 MHz (fro_hf)
                    FRO_HF = 0x2,
                    /// Audio PLL clock (audio_pll_clk)
                    AUDIO_PLL_OUTPUT = 0x3,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            /// LCD clock source select
            LCDCLKSEL: mmio.Mmio(packed struct(u32) {
                /// LCD clock source select.
                SEL: enum(u2) {
                    /// Main clock (main_clk)
                    MAIN_CLOCK = 0x0,
                    /// LCDCLKIN (LCDCLK_EXT)
                    LCDCLKIN = 0x1,
                    /// FRO 96 or 48 MHz (fro_hf)
                    FRO_HF = 0x2,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x3,
                },
                padding: u30,
            }),
            /// SDIO clock source select
            SDIOCLKSEL: mmio.Mmio(packed struct(u32) {
                /// SDIO clock source select.
                SEL: enum(u3) {
                    /// Main clock (main_clk)
                    MAIN_CLOCK = 0x0,
                    /// System PLL output (pll_clk)
                    SYSTEM_PLL_OUTPUT = 0x1,
                    /// USB PLL clock (usb_pll_clk)
                    USB_PLL_CLOCK = 0x2,
                    /// FRO 96 or 48 MHz (fro_hf)
                    FRO_HF = 0x3,
                    /// Audio PLL clock (audio_pll_clk)
                    AUDIO_PLL_OUTPUT = 0x4,
                    /// None, this may be selected in order to reduce power when no output is needed.
                    NONE = 0x7,
                    _,
                },
                padding: u29,
            }),
            reserved768: [4]u8,
            /// SYSTICK clock divider
            SYSTICKCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value. 0: Divide by 1 up to 255: Divide by 256.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// ARM Trace clock divider
            ARMTRACECLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// MCAN0 clock divider
            CAN0CLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// MCAN1 clock divider
            CAN1CLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value. 0: Divide by 1 up to 255: Divide by 256.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// Smartcard0 clock divider
            SC0CLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// Smartcard1 clock divider
            SC1CLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            reserved896: [104]u8,
            /// AHB clock divider
            AHBCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value. 0: Divide by 1 up to 255: Divide by 256.
                DIV: u8,
                reserved31: u23,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// CLKOUT clock divider
            CLKOUTDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value. 0: Divide by 1 up to 255: Divide by 256.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.
                RESET: u1,
                /// Halts the divider counter. The intent is to allow the divider clock source to be changed without the risk of a glitch at the output.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// FROHF clock divider
            FROHFCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            reserved912: [4]u8,
            /// SPIFI clock divider
            SPIFICLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.
                RESET: u1,
                /// Halts the divider counter. The intent is to allow the divider clock source to be changed without the risk of a glitch at the output.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// ADC clock divider
            ADCCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// USB0 clock divider
            USB0CLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// USB1 clock divider
            USB1CLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// Fractional rate divider
            FRGCTRL: mmio.Mmio(packed struct(u32) {
                /// Denominator of the fractional divider. DIV is equal to the programmed value +1. Always set to 0xFF to use with the fractional baud rate generator.
                DIV: u8,
                /// Numerator of the fractional divider. MULT is equal to the programmed value.
                MULT: u8,
                padding: u16,
            }),
            reserved936: [4]u8,
            /// DMIC clock divider
            DMICCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value. 0: Divide by 1 up to 255: Divide by 256.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.
                RESET: u1,
                /// Halts the divider counter. The intent is to allow the divider clock source to be changed without the risk of a glitch at the output.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// I2S MCLK clock divider
            MCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value. 0: Divide by 1 up to 255: Divide by 256.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// LCD clock divider
            LCDCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// SCT/PWM clock divider
            SCTCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// EMC clock divider
            EMCCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            /// SDIO clock divider
            SDIOCLKDIV: mmio.Mmio(packed struct(u32) {
                /// Clock divider value.
                DIV: u8,
                reserved29: u21,
                /// Resets the divider counter.
                RESET: u1,
                /// Halts the divider counter.
                HALT: u1,
                /// Divider status flag.
                REQFLAG: u1,
            }),
            reserved1024: [64]u8,
            /// Flash wait states configuration
            FLASHCFG: mmio.Mmio(packed struct(u32) {
                /// Instruction fetch configuration. This field determines how flash accelerator buffers are used for instruction fetches.
                FETCHCFG: enum(u2) {
                    /// Instruction fetches from flash are not buffered. Every fetch request from the CPU results in a read of the flash memory. This setting may use significantly more power than when buffering is enabled.
                    NO_BUFFER = 0x0,
                    /// One buffer is used for all instruction fetches.
                    ONE_BUFFER = 0x1,
                    /// All buffers may be used for instruction fetches.
                    ALL_BUFFERS = 0x2,
                    _,
                },
                /// Data read configuration. This field determines how flash accelerator buffers are used for data accesses.
                DATACFG: enum(u2) {
                    /// Data accesses from flash are not buffered. Every data access from the CPU results in a read of the flash memory.
                    NOT_BUFFERED = 0x0,
                    /// One buffer is used for all data accesses.
                    ONE_BUFFER = 0x1,
                    /// All buffers may be used for data accesses.
                    ALL_BUFFERS = 0x2,
                    _,
                },
                /// Acceleration enable.
                ACCEL: enum(u1) {
                    /// Flash acceleration is disabled. Every flash read (including those fulfilled from a buffer) takes FLASHTIM + 1 system clocks. This allows more determinism at a cost of performance.
                    DISABLED = 0x0,
                    /// Flash acceleration is enabled. Performance is enhanced, dependent on other FLASHCFG settings.
                    ENABLED = 0x1,
                },
                /// Prefetch enable.
                PREFEN: enum(u1) {
                    /// No instruction prefetch is performed.
                    NO_PREFETCH = 0x0,
                    /// If the FETCHCFG field is not 0, the next flash line following the current execution address is automatically prefetched if it is not already buffered.
                    PREFETCH = 0x1,
                },
                /// Prefetch override. This bit only applies when PREFEN = 1 and a buffered instruction is completing for which the next flash line is not already buffered or being prefetched.
                PREFOVR: enum(u1) {
                    /// Any previously initiated prefetch will be completed.
                    PREFETCH_COMPLETED = 0x0,
                    /// Any previously initiated prefetch will be aborted, and the next flash line following the current execution address will be prefetched if not already buffered.
                    PREFETCH_ABORT = 0x1,
                },
                reserved12: u5,
                /// Flash memory access time. The number of system clocks used for flash accesses is equal to FLASHTIM +1.
                FLASHTIM: enum(u4) {
                    /// 1 system clock flash access time (for system clock rates up to 12 MHz).
                    N_1_CLOCK_CYCLE = 0x0,
                    /// 2 system clocks flash access time (for system clock rates up to 30 MHz).
                    N_2_CLOCK_CYCLES = 0x1,
                    /// 3 system clocks flash access time (for system clock rates up to 60 MHz).
                    N_3_CLOCK_CYCLES = 0x2,
                    /// 4 system clocks flash access time (for system clock rates up to 85 MHz).
                    N_4_CLOCK_CYCLES = 0x3,
                    /// 5 system clocks flash access time (for system clock rates up to 100 MHz).
                    N_5_CLOCK_CYCLES = 0x4,
                    _,
                },
                padding: u16,
            }),
            reserved1036: [8]u8,
            /// USB0 clock control
            USB0CLKCTRL: mmio.Mmio(packed struct(u32) {
                /// USB0 Device USB0_NEEDCLK signal control.
                AP_FS_DEV_CLK: u1,
                /// USB0 Device USB0_NEEDCLK polarity for triggering the USB0 wake-up interrupt.
                POL_FS_DEV_CLK: u1,
                /// USB0 Host USB0_NEEDCLK signal control.
                AP_FS_HOST_CLK: u1,
                /// USB0 Host USB0_NEEDCLK polarity for triggering the USB0 wake-up interrupt.
                POL_FS_HOST_CLK: u1,
                /// Internal pull-up disable control.
                PU_DISABLE: u1,
                padding: u27,
            }),
            /// USB0 clock status
            USB0CLKSTAT: mmio.Mmio(packed struct(u32) {
                /// USB0 Device USB0_NEEDCLK signal status.
                DEV_NEED_CLKST: u1,
                /// USB0 Host USB0_NEEDCLK signal status.
                HOST_NEED_CLKST: u1,
                padding: u30,
            }),
            reserved1048: [4]u8,
            /// Frequency measure register
            FREQMECTRL: mmio.Mmio(packed struct(u32) {
                /// Stores the capture result which is used to calculate the frequency of the target clock. This field is read-only.
                CAPVAL: u14,
                reserved31: u17,
                /// Set this bit to one to initiate a frequency measurement cycle. Hardware clears this bit when the measurement cycle has completed and there is valid capture data in the CAPVAL field (bits 13:0).
                PROG: u1,
            }),
            reserved1056: [4]u8,
            /// MCLK input/output control
            MCLKIO: mmio.Mmio(packed struct(u32) {
                /// MCLK direction control.
                DIR: u1,
                padding: u31,
            }),
            /// USB1 clock control
            USB1CLKCTRL: mmio.Mmio(packed struct(u32) {
                /// USB1 Device need_clock signal control.
                AP_FS_DEV_CLK: u1,
                /// USB1 Device need_clock polarity for triggering the USB1 wake-up interrupt.
                POL_FS_DEV_CLK: u1,
                /// USB1 Host need_clock signal control.
                AP_FS_HOST_CLK: u1,
                /// USB1 Host need_clock polarity for triggering the USB1 wake-up interrupt.
                POL_FS_HOST_CLK: u1,
                /// External user wake-up signal for device mode; asserting this signal (active low) will result in exiting the low power mode; input to asynchronous control logic.
                HS_DEV_WAKEUP_N: u1,
                padding: u27,
            }),
            /// USB1 clock status
            USB1CLKSTAT: mmio.Mmio(packed struct(u32) {
                /// USB1 Device USB1_NEEDCLK signal status.
                DEV_NEED_CLKST: u1,
                /// USB1 Device host USB1_NEEDCLK signal status.
                HOST_NEED_CLKST: u1,
                padding: u30,
            }),
            reserved1092: [24]u8,
            /// EMC system control
            EMCSYSCTRL: mmio.Mmio(packed struct(u32) {
                /// EMC Shift Control.
                EMCSC: u1,
                /// EMC Reset Disable.
                EMCRD: u1,
                /// External Memory Controller burst control.
                EMCBC: u1,
                /// External Memory Controller clock select.
                EMCFBCLKINSEL: u1,
                padding: u28,
            }),
            /// EMC clock delay control
            EMCDLYCTRL: mmio.Mmio(packed struct(u32) {
                /// Programmable delay value for EMC outputs in command delayed mode.
                CMD_DELAY: u5,
                reserved8: u3,
                /// Programmable delay value for the feedback clock that controls input data sampling.
                FBCLK_DELAY: u5,
                padding: u19,
            }),
            /// EMC delay chain calibration control
            EMCDLYCAL: mmio.Mmio(packed struct(u32) {
                /// Returns the count of the approximately 50 MHz ring oscillator that occur during 32 clocks of the FRO 12 MHz.
                CALVALUE: u8,
                reserved14: u6,
                /// Start control bit for the EMC calibration counter.
                START: u1,
                /// Measurement completion flag.
                DONE: u1,
                padding: u16,
            }),
            /// Ethernet PHY Selection
            ETHPHYSEL: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// PHY interface select.
                PHY_SEL: u1,
                padding: u29,
            }),
            /// Ethernet SBD flow control
            ETHSBDCTRL: mmio.Mmio(packed struct(u32) {
                /// Sideband Flow Control.
                SBD_CTRL: u2,
                padding: u30,
            }),
            reserved1120: [8]u8,
            /// SDIO CCLKIN phase and delay control
            SDIOCLKCTRL: mmio.Mmio(packed struct(u32) {
                /// Programmable delay value by which cclk_in_drv is phase-shifted with regard to cclk_in.
                CCLK_DRV_PHASE: u2,
                /// Programmable delay value by which cclk_in_sample is delayed with regard to cclk_in.
                CCLK_SAMPLE_PHASE: u2,
                reserved7: u3,
                /// sdio_clk by 2, before feeding into ccl_in, cclk_in_sample, and cclk_in_drv.
                PHASE_ACTIVE: u1,
                reserved16: u8,
                /// Programmable delay value by which cclk_in_drv is delayed with regard to cclk_in.
                CCLK_DRV_DELAY: u5,
                reserved23: u2,
                /// Enables drive delay, as controlled by the CCLK_DRV_DELAY field.
                CCLK_DRV_DELAY_ACTIVE: u1,
                /// Programmable delay value by which cclk_in_sample is delayed with regard to cclk_in.
                CCLK_SAMPLE_DELAY: u5,
                reserved31: u2,
                /// Enables sample delay, as controlled by the CCLK_SAMPLE_DELAY field.
                CCLK_SAMPLE_DELAY_ACTIVE: u1,
            }),
            reserved1280: [156]u8,
            /// FRO oscillator control
            FROCTRL: mmio.Mmio(packed struct(u32) {
                /// This value is factory trimmed to account for bias and temperature compensation.
                TRIM: u14,
                /// Select the FRO HF output frequency.
                SEL: u1,
                reserved16: u1,
                /// Frequency trim.
                FREQTRIM: u8,
                /// USB clock adjust mode.
                USBCLKADJ: u1,
                /// USB Mode value Change flag.
                USBMODCHG: u1,
                reserved30: u4,
                /// High speed clock enable.
                HSPDCLK: u1,
                /// Write Trim value.
                WRTRIM: u1,
            }),
            /// System oscillator control
            SYSOSCCTRL: mmio.Mmio(packed struct(u32) {
                /// Bypass system oscillator.
                BYPASS: u1,
                /// Determines frequency range for system oscillator.
                FREQRANGE: u1,
                padding: u30,
            }),
            /// Watchdog oscillator control
            WDTOSCCTRL: mmio.Mmio(packed struct(u32) {
                /// Divider select.
                DIVSEL: u5,
                /// Frequency select.
                FREQSEL: u5,
                padding: u22,
            }),
            /// RTC oscillator 32 kHz output control
            RTCOSCCTRL: mmio.Mmio(packed struct(u32) {
                /// RTC 32 kHz clock enable.
                EN: u1,
                padding: u31,
            }),
            reserved1308: [12]u8,
            /// USB PLL control
            USBPLLCTRL: mmio.Mmio(packed struct(u32) {
                /// PLL feedback Divider value.
                MSEL: u8,
                /// PLL Divider value.
                PSEL: u2,
                /// PLL feedback Divider value.
                NSEL: u2,
                /// Direct CCO clock output control.
                DIRECT: enum(u1) {
                    /// CCO Clock signal goes through post divider.
                    DISABLED = 0x0,
                    /// CCO Clock signal goes directly to output(s)..
                    ENABLED = 0x1,
                },
                /// Input clock bypass control.
                BYPASS: enum(u1) {
                    /// CCO clock is sent to post dividers..
                    DISABLED = 0x0,
                    /// PLL input clock is sent to post dividers..
                    ENABLED = 0x1,
                },
                /// Feedback divider input clock control.
                FBSEL: u1,
                padding: u17,
            }),
            /// USB PLL status
            USBPLLSTAT: mmio.Mmio(packed struct(u32) {
                /// USBPLL lock indicator.
                LOCK: u1,
                padding: u31,
            }),
            reserved1408: [92]u8,
            /// System PLL control
            SYSPLLCTRL: mmio.Mmio(packed struct(u32) {
                /// Bandwidth select R value.
                SELR: u4,
                /// Bandwidth select I value.
                SELI: u6,
                /// Bandwidth select P value.
                SELP: u5,
                /// PLL bypass control.
                BYPASS: enum(u1) {
                    /// Bypass disabled. PLL CCO is sent to the PLL post-dividers.
                    DISABLED = 0x0,
                    /// Bypass enabled. PLL input clock is sent directly to the PLL output (default).
                    ENABLED = 0x1,
                },
                reserved17: u1,
                /// Disable upper frequency limiter.
                UPLIMOFF: u1,
                reserved19: u1,
                /// PLL0 direct input enable.
                DIRECTI: u1,
                /// PLL0 direct output enable.
                DIRECTO: enum(u1) {
                    /// Disabled. The PLL output divider (P divider) is used to create the PLL output.
                    DISABLED = 0x0,
                    /// Enabled. The PLL output divider (P divider) is bypassed, the PLL CCO output is used as the PLL output.
                    ENABLED = 0x1,
                },
                padding: u11,
            }),
            /// PLL status
            SYSPLLSTAT: mmio.Mmio(packed struct(u32) {
                /// PLL lock indicator.
                LOCK: u1,
                padding: u31,
            }),
            /// PLL N divider
            SYSPLLNDEC: mmio.Mmio(packed struct(u32) {
                /// Decoded N-divider coefficient value.
                NDEC: u10,
                /// NDEC reload request.
                NREQ: u1,
                padding: u21,
            }),
            /// PLL P divider
            SYSPLLPDEC: mmio.Mmio(packed struct(u32) {
                /// Decoded P-divider coefficient value.
                PDEC: u7,
                /// .
                PREQ: u1,
                padding: u24,
            }),
            /// System PLL M divider
            SYSPLLMDEC: mmio.Mmio(packed struct(u32) {
                /// Decoded M-divider coefficient value.
                MDEC: u17,
                /// MDEC reload request.
                MREQ: u1,
                padding: u14,
            }),
            reserved1440: [12]u8,
            /// Audio PLL control
            AUDPLLCTRL: mmio.Mmio(packed struct(u32) {
                /// Bandwidth select R value.
                SELR: u4,
                /// Bandwidth select I value.
                SELI: u6,
                /// .
                SELP: u5,
                /// PLL bypass control.
                BYPASS: enum(u1) {
                    /// Bypass disabled. PLL CCO is sent to the PLL post-dividers.
                    DISABLED = 0x0,
                    /// Bypass enabled. PLL input clock is sent directly to the PLL output (default).
                    ENABLED = 0x1,
                },
                reserved17: u1,
                /// Disable upper frequency limiter.
                UPLIMOFF: u1,
                reserved19: u1,
                /// PLL direct input enable.
                DIRECTI: u1,
                /// PLL direct output enable
                DIRECTO: enum(u1) {
                    /// Disabled. The PLL output divider (P divider) is used to create the PLL output.
                    DISABLED = 0x0,
                    /// Enabled. The PLL output divider (P divider) is bypassed, the PLL CCO output is used as the PLL output.
                    ENABLED = 0x1,
                },
                padding: u11,
            }),
            /// Audio PLL status
            AUDPLLSTAT: mmio.Mmio(packed struct(u32) {
                /// PLL lock indicator.
                LOCK: u1,
                padding: u31,
            }),
            /// Audio PLL N divider
            AUDPLLNDEC: mmio.Mmio(packed struct(u32) {
                /// Decoded N-divider coefficient value.
                NDEC: u10,
                /// NDEC reload request.
                NREQ: u1,
                padding: u21,
            }),
            /// Audio PLL P divider
            AUDPLLPDEC: mmio.Mmio(packed struct(u32) {
                /// Decoded P-divider coefficient value.
                PDEC: u7,
                /// PDEC reload request.
                PREQ: u1,
                padding: u24,
            }),
            /// Audio PLL M divider
            AUDPLLMDEC: mmio.Mmio(packed struct(u32) {
                /// Decoded M-divider coefficient value.
                MDEC: u17,
                /// MDEC reload request.
                MREQ: u1,
                padding: u14,
            }),
            /// Audio PLL fractional divider control
            AUDPLLFRAC: mmio.Mmio(packed struct(u32) {
                /// PLL fractional divider control word
                CTRL: u22,
                /// Writing 1 to REQ signal loads CTRL value into fractional wrapper modulator.
                REQ: u1,
                /// Select fractional divider.
                SEL_EXT: u1,
                padding: u8,
            }),
            reserved1536: [72]u8,
            /// Sleep configuration register
            PDSLEEPCFG0: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// FRO oscillator.
                PDEN_FRO: u1,
                reserved6: u1,
                /// Temp sensor.
                PDEN_TS: u1,
                /// Brown-out Detect reset.
                PDEN_BOD_RST: u1,
                /// Brown-out Detect interrupt.
                PDEN_BOD_INTR: u1,
                /// Analog supply for System Oscillator (also enable/disable bit 3 in PDRUNCFG1 register), Temperature Sensor (also, enable/disable bit 6), ADC (also, enable/disable bits 10, 19, and 23).
                PDEN_VD2_ANA: u1,
                /// ADC power.
                PDEN_ADC0: u1,
                reserved13: u2,
                /// PDEN_SRAMX controls SRAMX (also enable/disable bit 27).
                PDEN_SRAMX: u1,
                /// PDEN_SRAM0 controls SRAM0 (also enable/disable bit 27).
                PDEN_SRAM0: u1,
                /// PDEN_SRAM1_2_3 controls SRAM1, SRAM2, and SRAM3 (also enable/disable bit 27).
                PDEN_SRAM1_2_3: u1,
                /// PDEN_USB_SRAM controls USB_RAM (also enable/disable bit 27).
                PDEN_USB_RAM: u1,
                /// ROM (also enable/disable bit 27).
                PDEN_ROM: u1,
                reserved19: u1,
                /// Vdda to the ADC, must be enabled for the ADC to work (also enable/disable bit 9, 10, and 23).
                PDEN_VDDA: u1,
                /// Watchdog oscillator.
                PDEN_WDT_OSC: u1,
                /// USB0 PHY power (also enable/disable bit 28).
                PDEN_USB0_PHY: u1,
                /// System PLL (PLL0) power (also enable/disable bit 26).
                PDEN_SYS_PLL: u1,
                /// VREFP to the ADC must be enabled for the ADC to work (also enable/disable bit 9, 10, and 19).
                PDEN_VREFP: u1,
                reserved26: u2,
                /// Power control for all PLLs.
                PDEN_VD3: u1,
                /// Power control for all SRAMs and ROM.
                PDEN_VD4: u1,
                /// Power control both USB0 PHY and USB1 PHY.
                PDEN_VD5: u1,
                /// Power control for EEPROM.
                PDEN_VD6: u1,
                padding: u2,
            }),
            /// Sleep configuration register
            PDSLEEPCFG1: mmio.Mmio(packed struct(u32) {
                /// USB1 high speed PHY (also, enable/disable bit 28 in PDRUNCFG0 register).
                PDEN_USB1_PHY: u1,
                /// USB PLL (PLL1) power (also, enable/disable bit 26 in PDRUNCFG0 register).
                PDEN_USB1_PLL: u1,
                /// Audio PLL (PLL2) power and fractional divider (also, enable/disable bit 26 in PDRUNCFG0 register).
                PDEN_AUD_PLL: u1,
                /// System Oscillator Power (also, enable/disable bit 9 in PDRUNCFG0 register).
                PDEN_SYSOSC: u1,
                reserved5: u1,
                /// EEPROM power (also, enable/disable bit 29 in PDRUNCFG0 register).
                PDEN_EEPROM: u1,
                reserved7: u1,
                /// Random Number Generator Power.
                PDEN_RNG: u1,
                padding: u24,
            }),
            reserved1552: [8]u8,
            /// Power configuration register
            PDRUNCFG0: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// FRO oscillator.
                PDEN_FRO: u1,
                reserved6: u1,
                /// Temp sensor.
                PDEN_TS: u1,
                /// Brown-out Detect reset.
                PDEN_BOD_RST: u1,
                /// Brown-out Detect interrupt.
                PDEN_BOD_INTR: u1,
                /// Analog supply for System Oscillator (also enable/disable bit 3 in PDRUNCFG1 register), Temperature Sensor (also, enable/disable bit 6), ADC (also, enable/disable bits 10, 19, and 23).
                PDEN_VD2_ANA: u1,
                /// ADC power.
                PDEN_ADC0: u1,
                reserved13: u2,
                /// PDEN_SRAMX controls SRAMX (also enable/disable bit 27).
                PDEN_SRAMX: u1,
                /// PDEN_SRAM0 controls SRAM0 (also enable/disable bit 27).
                PDEN_SRAM0: u1,
                /// PDEN_SRAM1_2_3 controls SRAM1, SRAM2, and SRAM3 (also enable/disable bit 27).
                PDEN_SRAM1_2_3: u1,
                /// PDEN_USB_SRAM controls USB_RAM (also enable/disable bit 27).
                PDEN_USB_RAM: u1,
                /// ROM (also enable/disable bit 27).
                PDEN_ROM: u1,
                reserved19: u1,
                /// Vdda to the ADC, must be enabled for the ADC to work (also enable/disable bit 9, 10, and 23).
                PDEN_VDDA: u1,
                /// Watchdog oscillator.
                PDEN_WDT_OSC: u1,
                /// USB0 PHY power (also enable/disable bit 28).
                PDEN_USB0_PHY: u1,
                /// System PLL (PLL0) power (also enable/disable bit 26).
                PDEN_SYS_PLL: u1,
                /// VREFP to the ADC must be enabled for the ADC to work (also enable/disable bit 9, 10, and 19).
                PDEN_VREFP: u1,
                reserved26: u2,
                /// Power control for all PLLs.
                PDEN_VD3: u1,
                /// Power control for all SRAMs and ROM.
                PDEN_VD4: u1,
                /// Power control both USB0 PHY and USB1 PHY.
                PDEN_VD5: u1,
                /// Power control for EEPROM.
                PDEN_VD6: u1,
                padding: u2,
            }),
            /// Power configuration register
            PDRUNCFG1: mmio.Mmio(packed struct(u32) {
                /// USB1 high speed PHY (also, enable/disable bit 28 in PDRUNCFG0 register).
                PDEN_USB1_PHY: u1,
                /// USB PLL (PLL1) power (also, enable/disable bit 26 in PDRUNCFG0 register).
                PDEN_USB1_PLL: u1,
                /// Audio PLL (PLL2) power and fractional divider (also, enable/disable bit 26 in PDRUNCFG0 register).
                PDEN_AUD_PLL: u1,
                /// System Oscillator Power (also, enable/disable bit 9 in PDRUNCFG0 register).
                PDEN_SYSOSC: u1,
                reserved5: u1,
                /// EEPROM power (also, enable/disable bit 29 in PDRUNCFG0 register).
                PDEN_EEPROM: u1,
                reserved7: u1,
                /// Random Number Generator Power.
                PDEN_RNG: u1,
                padding: u24,
            }),
            reserved1568: [8]u8,
            /// Power configuration set register
            PDRUNCFGSET0: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// FRO oscillator.
                PDEN_FRO: u1,
                reserved6: u1,
                /// Temp sensor.
                PDEN_TS: u1,
                /// Brown-out Detect reset.
                PDEN_BOD_RST: u1,
                /// Brown-out Detect interrupt.
                PDEN_BOD_INTR: u1,
                /// Analog supply for System Oscillator (also enable/disable bit 3 in PDRUNCFG1 register), Temperature Sensor (also, enable/disable bit 6), ADC (also, enable/disable bits 10, 19, and 23).
                PDEN_VD2_ANA: u1,
                /// ADC power.
                PDEN_ADC0: u1,
                reserved13: u2,
                /// PDEN_SRAMX controls SRAMX (also enable/disable bit 27).
                PDEN_SRAMX: u1,
                /// PDEN_SRAM0 controls SRAM0 (also enable/disable bit 27).
                PDEN_SRAM0: u1,
                /// PDEN_SRAM1_2_3 controls SRAM1, SRAM2, and SRAM3 (also enable/disable bit 27).
                PDEN_SRAM1_2_3: u1,
                /// PDEN_USB_SRAM controls USB_RAM (also enable/disable bit 27).
                PDEN_USB_RAM: u1,
                /// ROM (also enable/disable bit 27).
                PDEN_ROM: u1,
                reserved19: u1,
                /// Vdda to the ADC, must be enabled for the ADC to work (also enable/disable bit 9, 10, and 23).
                PDEN_VDDA: u1,
                /// Watchdog oscillator.
                PDEN_WDT_OSC: u1,
                /// USB0 PHY power (also enable/disable bit 28).
                PDEN_USB0_PHY: u1,
                /// System PLL (PLL0) power (also enable/disable bit 26).
                PDEN_SYS_PLL: u1,
                /// VREFP to the ADC must be enabled for the ADC to work (also enable/disable bit 9, 10, and 19).
                PDEN_VREFP: u1,
                reserved26: u2,
                /// Power control for all PLLs.
                PDEN_VD3: u1,
                /// Power control for all SRAMs and ROM.
                PDEN_VD4: u1,
                /// Power control both USB0 PHY and USB1 PHY.
                PDEN_VD5: u1,
                /// Power control for EEPROM.
                PDEN_VD6: u1,
                padding: u2,
            }),
            /// Power configuration set register
            PDRUNCFGSET1: mmio.Mmio(packed struct(u32) {
                /// USB1 high speed PHY (also, enable/disable bit 28 in PDRUNCFG0 register).
                PDEN_USB1_PHY: u1,
                /// USB PLL (PLL1) power (also, enable/disable bit 26 in PDRUNCFG0 register).
                PDEN_USB1_PLL: u1,
                /// Audio PLL (PLL2) power and fractional divider (also, enable/disable bit 26 in PDRUNCFG0 register).
                PDEN_AUD_PLL: u1,
                /// System Oscillator Power (also, enable/disable bit 9 in PDRUNCFG0 register).
                PDEN_SYSOSC: u1,
                reserved5: u1,
                /// EEPROM power (also, enable/disable bit 29 in PDRUNCFG0 register).
                PDEN_EEPROM: u1,
                reserved7: u1,
                /// Random Number Generator Power.
                PDEN_RNG: u1,
                padding: u24,
            }),
            reserved1584: [8]u8,
            /// Power configuration clear register
            PDRUNCFGCLR0: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// FRO oscillator.
                PDEN_FRO: u1,
                reserved6: u1,
                /// Temp sensor.
                PDEN_TS: u1,
                /// Brown-out Detect reset.
                PDEN_BOD_RST: u1,
                /// Brown-out Detect interrupt.
                PDEN_BOD_INTR: u1,
                /// Analog supply for System Oscillator (also enable/disable bit 3 in PDRUNCFG1 register), Temperature Sensor (also, enable/disable bit 6), ADC (also, enable/disable bits 10, 19, and 23).
                PDEN_VD2_ANA: u1,
                /// ADC power.
                PDEN_ADC0: u1,
                reserved13: u2,
                /// PDEN_SRAMX controls SRAMX (also enable/disable bit 27).
                PDEN_SRAMX: u1,
                /// PDEN_SRAM0 controls SRAM0 (also enable/disable bit 27).
                PDEN_SRAM0: u1,
                /// PDEN_SRAM1_2_3 controls SRAM1, SRAM2, and SRAM3 (also enable/disable bit 27).
                PDEN_SRAM1_2_3: u1,
                /// PDEN_USB_SRAM controls USB_RAM (also enable/disable bit 27).
                PDEN_USB_RAM: u1,
                /// ROM (also enable/disable bit 27).
                PDEN_ROM: u1,
                reserved19: u1,
                /// Vdda to the ADC, must be enabled for the ADC to work (also enable/disable bit 9, 10, and 23).
                PDEN_VDDA: u1,
                /// Watchdog oscillator.
                PDEN_WDT_OSC: u1,
                /// USB0 PHY power (also enable/disable bit 28).
                PDEN_USB0_PHY: u1,
                /// System PLL (PLL0) power (also enable/disable bit 26).
                PDEN_SYS_PLL: u1,
                /// VREFP to the ADC must be enabled for the ADC to work (also enable/disable bit 9, 10, and 19).
                PDEN_VREFP: u1,
                reserved26: u2,
                /// Power control for all PLLs.
                PDEN_VD3: u1,
                /// Power control for all SRAMs and ROM.
                PDEN_VD4: u1,
                /// Power control both USB0 PHY and USB1 PHY.
                PDEN_VD5: u1,
                /// Power control for EEPROM.
                PDEN_VD6: u1,
                padding: u2,
            }),
            /// Power configuration clear register
            PDRUNCFGCLR1: mmio.Mmio(packed struct(u32) {
                /// USB1 high speed PHY (also, enable/disable bit 28 in PDRUNCFG0 register).
                PDEN_USB1_PHY: u1,
                /// USB PLL (PLL1) power (also, enable/disable bit 26 in PDRUNCFG0 register).
                PDEN_USB1_PLL: u1,
                /// Audio PLL (PLL2) power and fractional divider (also, enable/disable bit 26 in PDRUNCFG0 register).
                PDEN_AUD_PLL: u1,
                /// System Oscillator Power (also, enable/disable bit 9 in PDRUNCFG0 register).
                PDEN_SYSOSC: u1,
                reserved5: u1,
                /// EEPROM power (also, enable/disable bit 29 in PDRUNCFG0 register).
                PDEN_EEPROM: u1,
                reserved7: u1,
                /// Random Number Generator Power.
                PDEN_RNG: u1,
                padding: u24,
            }),
            reserved1664: [72]u8,
            /// Start logic 0 wake-up enable register
            STARTER0: mmio.Mmio(packed struct(u32) {
                /// WWDT and BOD interrupt wake-up.
                WDT_BOD: u1,
                /// DMA wake-up.
                DMA: u1,
                /// Group interrupt 0 wake-up.
                GINT0: u1,
                /// Group interrupt 1 wake-up.
                GINT1: u1,
                /// GPIO pin interrupt 0 wake-up.
                PIN_INT0: u1,
                /// GPIO pin interrupt 1 wake-up.
                PIN_INT1: u1,
                /// GPIO pin interrupt 2 wake-up.
                PIN_INT2: u1,
                /// GPIO pin interrupt 3 wake-up.
                PIN_INT3: u1,
                /// Micro-tick Timer wake-up.
                UTICK: u1,
                /// Multi-Rate Timer wake-up.
                MRT: u1,
                /// Standard counter/timer CTIMER0 wake-up.
                CTIMER0: u1,
                /// Standard counter/timer CTIMER1 wake-up.
                CTIMER1: u1,
                /// SCT0 wake-up.
                SCT0: u1,
                /// Standard counter/timer CTIMER3 wake-up.
                CTIMER3: u1,
                /// Flexcomm0 peripheral interrupt wake-up.
                FLEXCOMM0: u1,
                /// Flexcomm1 peripheral interrupt wake-up.
                FLEXCOMM1: u1,
                /// Flexcomm2 peripheral interrupt wake-up.
                FLEXCOMM2: u1,
                /// Flexcomm3 peripheral interrupt wake-up.
                FLEXCOMM3: u1,
                /// Flexcomm4 peripheral interrupt wake-up.
                FLEXCOMM4: u1,
                /// Flexcomm5 peripheral interrupt wake-up.
                FLEXCOMM5: u1,
                /// Flexcomm6 peripheral interrupt wake-up.
                FLEXCOMM6: u1,
                /// Flexcomm7 peripheral interrupt wake-up.
                FLEXCOMM7: u1,
                /// ADC0 sequence A interrupt wake-up.
                ADC0_SEQA: u1,
                /// ADC0 sequence B interrupt wake-up.
                ADC0_SEQB: u1,
                /// ADC0 threshold and error interrupt wake-up.
                ADC0_THCMP: u1,
                /// Digital microphone interrupt wake-up.
                DMIC: u1,
                /// Hardware voice activity detect interrupt wake-up.
                HWVAD: u1,
                /// USB activity interrupt wake-up.
                USB0_NEEDCLK: u1,
                /// USB function interrupt wake-up.
                USB0: u1,
                /// RTC interrupt alarm and wake-up timer.
                RTC: u1,
                padding: u2,
            }),
            /// Start logic 0 wake-up enable register
            STARTER1: mmio.Mmio(packed struct(u32) {
                /// GPIO pin interrupt 4 wake-up.
                PINT4: u1,
                /// GPIO pin interrupt 5 wake-up.
                PINT5: u1,
                /// GPIO pin interrupt 6 wake-up.
                PINT6: u1,
                /// GPIO pin interrupt 7 wake-up.
                PINT7: u1,
                /// Standard counter/timer CTIMER2 wake-up.
                CTIMER2: u1,
                /// Standard counter/timer CTIMER4 wake-up.
                CTIMER4: u1,
                reserved7: u1,
                /// SPIFI interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                SPIFI: u1,
                /// Flexcomm Interface 8 wake-up.
                FLEXCOMM8: u1,
                /// Flexcomm Interface 9 wake-up.
                FLEXCOMM9: u1,
                reserved15: u5,
                /// USB 1 wake-up.
                USB1: u1,
                /// USB 1 activity wake-up.
                USB1_ACT: u1,
                /// Ethernet.
                ENET_INT1: u1,
                /// Ethernet.
                ENET_INT2: u1,
                /// Ethernet.
                ENET_INT0: u1,
                reserved23: u3,
                /// Smart card 0 wake-up.
                SMARTCARD0: u1,
                /// Smart card 1 wake-up.
                SMARTCARD1: u1,
                padding: u7,
            }),
            reserved1696: [24]u8,
            /// Set bits in STARTER
            STARTERSET: [2]mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register sets the corresponding bit or bits in the STARTER0 register, if they are implemented.
                START_SET: u32,
            }),
            reserved1728: [24]u8,
            /// Clear bits in STARTER0
            STARTERCLR: [2]mmio.Mmio(packed struct(u32) {
                /// Writing ones to this register clears the corresponding bit or bits in the STARTER0 register, if they are implemented.
                START_CLR: u32,
            }),
            reserved1920: [184]u8,
            /// Configures special cases of hardware wake-up
            HWWAKE: mmio.Mmio(packed struct(u32) {
                /// Force peripheral clocking to stay on during Deep Sleep and Power-down modes. When 1, clocking to peripherals is prevented from being shut down when the CPU enters Deep Sleep and Power-down modes. This is intended to allow a coprocessor to continue operating while the main CPU(s) are shut down.
                FORCEWAKE: u1,
                /// Wake for Flexcomms. When 1, any Flexcomm FIFO reaching the level specified by its own TXLVL will cause peripheral clocking to wake up temporarily while the related status is asserted.
                FCWAKE: u1,
                /// Wake for Digital Microphone. When 1, the digital microphone input FIFO reaching the level specified by TRIGLVL of either channel will cause peripheral clocking to wake up temporarily while the related status is asserted.
                WAKEDMIC: u1,
                /// Wake for DMA. When 1, DMA being busy will cause peripheral clocking to remain running until DMA completes. This is generally used in conjunction with bit 1 and/or 2 in order to prevent peripheral clocking from being shut down as soon as the cause of wake-up is cleared, but before DMA has completed its related activity.
                WAKEDMA: u1,
                padding: u28,
            }),
            reserved3588: [1664]u8,
            /// Auto Clock-Gate Override Register
            AUTOCGOR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// When 1, automatic clock gating for RAMX and RAM0 are turned off.
                RAM0X: u1,
                /// When 1, automatic clock gating for RAM1 are turned off.
                RAM1: u1,
                /// When 1, automatic clock gating for RAM1 are turned off.
                RAM2: u1,
                /// When 1, automatic clock gating for RAM1 are turned off.
                RAM3: u1,
                padding: u27,
            }),
            reserved4084: [492]u8,
            /// JTAG ID code register
            JTAGIDCODE: mmio.Mmio(packed struct(u32) {
                /// JTAG ID code.
                JTAGID: u32,
            }),
            /// Part ID register
            DEVICE_ID0: mmio.Mmio(packed struct(u32) {
                /// Part ID
                PARTID: u32,
            }),
            /// Boot ROM and die revision register
            DEVICE_ID1: mmio.Mmio(packed struct(u32) {
                /// Revision.
                REVID: u32,
            }),
            reserved131140: [127044]u8,
            /// Brown-Out Detect control
            BODCTRL: mmio.Mmio(packed struct(u32) {
                /// BOD reset level
                BODRSTLEV: enum(u2) {
                    /// Level 0: 1.5 V
                    LEVEL0 = 0x0,
                    /// Level 1: 1.85 V
                    LEVEL1 = 0x1,
                    /// Level 2: 2.0 V
                    LEVEL2 = 0x2,
                    /// Level 3: 2.3 V
                    LEVEL3 = 0x3,
                },
                /// BOD reset enable
                BODRSTENA: enum(u1) {
                    /// Disable reset function.
                    DISABLE = 0x0,
                    /// Enable reset function.
                    ENABLE = 0x1,
                },
                /// BOD interrupt level
                BODINTLEV: enum(u2) {
                    /// Level 0: 2.05 V
                    LEVEL0 = 0x0,
                    /// Level 1: 2.45 V
                    LEVEL1 = 0x1,
                    /// Level 2: 2.75 V
                    LEVEL2 = 0x2,
                    /// Level 3: 3.05 V
                    LEVEL3 = 0x3,
                },
                /// BOD interrupt enable
                BODINTENA: enum(u1) {
                    /// Disable interrupt function.
                    DISABLE = 0x0,
                    /// Enable interrupt function.
                    ENABLE = 0x1,
                },
                /// BOD reset status. When 1, a BOD reset has occurred. Cleared by writing 1 to this bit.
                BODRSTSTAT: u1,
                /// BOD interrupt status. When 1, a BOD interrupt has occurred. Cleared by writing 1 to this bit.
                BODINTSTAT: u1,
                padding: u24,
            }),
        };

        /// System timer
        pub const SysTick = extern struct {
            /// SysTick Control and Status Register
            CSR: mmio.Mmio(packed struct(u32) {
                /// no description available
                ENABLE: enum(u1) {
                    /// counter disabled
                    ENABLE_0 = 0x0,
                    /// counter enabled
                    ENABLE_1 = 0x1,
                },
                /// no description available
                TICKINT: enum(u1) {
                    /// counting down to 0 does not assert the SysTick exception request
                    TICKINT_0 = 0x0,
                    /// counting down to 0 asserts the SysTick exception request
                    TICKINT_1 = 0x1,
                },
                /// no description available
                CLKSOURCE: enum(u1) {
                    /// external clock
                    CLKSOURCE_0 = 0x0,
                    /// processor clock
                    CLKSOURCE_1 = 0x1,
                },
                reserved16: u13,
                /// no description available
                COUNTFLAG: u1,
                padding: u15,
            }),
            /// SysTick Reload Value Register
            RVR: mmio.Mmio(packed struct(u32) {
                /// Value to load into the SysTick Current Value Register when the counter reaches 0
                RELOAD: u24,
                padding: u8,
            }),
            /// SysTick Current Value Register
            CVR: mmio.Mmio(packed struct(u32) {
                /// Current value at the time the register is accessed
                CURRENT: u24,
                padding: u8,
            }),
            /// SysTick Calibration Value Register
            CALIB: mmio.Mmio(packed struct(u32) {
                /// Reload value to use for 10ms timing
                TENMS: u24,
                reserved30: u6,
                /// no description available
                SKEW: enum(u1) {
                    /// 10ms calibration value is exact
                    SKEW_0 = 0x0,
                    /// 10ms calibration value is inexact, because of the clock frequency
                    SKEW_1 = 0x1,
                },
                /// no description available
                NOREF: enum(u1) {
                    /// The reference clock is provided
                    NOREF_0 = 0x0,
                    /// The reference clock is not provided
                    NOREF_1 = 0x1,
                },
            }),
        };

        /// System Control Block
        pub const SystemControl = extern struct {
            reserved8: [8]u8,
            /// Auxiliary Control Register,
            ACTLR: mmio.Mmio(packed struct(u32) {
                /// Disables interruption of multi-cycle instructions.
                DISMCYCINT: u1,
                /// Disables write buffer use during default memory map accesses.
                DISDEFWBUF: u1,
                /// Disables folding of IT instructions.
                DISFOLD: u1,
                padding: u29,
            }),
            reserved3328: [3316]u8,
            /// CPUID Base Register
            CPUID: mmio.Mmio(packed struct(u32) {
                /// Indicates patch release: 0x0 = Patch 0
                REVISION: u4,
                /// Indicates part number
                PARTNO: u12,
                reserved20: u4,
                /// Indicates processor revision: 0x2 = Revision 2
                VARIANT: u4,
                /// Implementer code
                IMPLEMENTER: u8,
            }),
            /// Interrupt Control and State Register
            ICSR: mmio.Mmio(packed struct(u32) {
                /// Active exception number
                VECTACTIVE: u9,
                reserved11: u2,
                /// no description available
                RETTOBASE: enum(u1) {
                    /// there are preempted active exceptions to execute
                    RETTOBASE_0 = 0x0,
                    /// there are no active exceptions, or the currently-executing exception is the only active exception
                    RETTOBASE_1 = 0x1,
                },
                /// Exception number of the highest priority pending enabled exception
                VECTPENDING: u6,
                reserved22: u4,
                /// no description available
                ISRPENDING: u1,
                /// no description available
                ISRPREEMPT: enum(u1) {
                    /// Will not service
                    ISRPREEMPT_0 = 0x0,
                    /// Will service a pending exception
                    ISRPREEMPT_1 = 0x1,
                },
                reserved25: u1,
                /// no description available
                PENDSTCLR: enum(u1) {
                    /// no effect
                    PENDSTCLR_0 = 0x0,
                    /// removes the pending state from the SysTick exception
                    PENDSTCLR_1 = 0x1,
                },
                /// no description available
                PENDSTSET: enum(u1) {
                    /// write: no effect; read: SysTick exception is not pending
                    PENDSTSET_0 = 0x0,
                    /// write: changes SysTick exception state to pending; read: SysTick exception is pending
                    PENDSTSET_1 = 0x1,
                },
                /// no description available
                PENDSVCLR: enum(u1) {
                    /// no effect
                    PENDSVCLR_0 = 0x0,
                    /// removes the pending state from the PendSV exception
                    PENDSVCLR_1 = 0x1,
                },
                /// no description available
                PENDSVSET: enum(u1) {
                    /// write: no effect; read: PendSV exception is not pending
                    PENDSVSET_0 = 0x0,
                    /// write: changes PendSV exception state to pending; read: PendSV exception is pending
                    PENDSVSET_1 = 0x1,
                },
                reserved31: u2,
                /// no description available
                NMIPENDSET: enum(u1) {
                    /// write: no effect; read: NMI exception is not pending
                    NMIPENDSET_0 = 0x0,
                    /// write: changes NMI exception state to pending; read: NMI exception is pending
                    NMIPENDSET_1 = 0x1,
                },
            }),
            /// Vector Table Offset Register
            VTOR: mmio.Mmio(packed struct(u32) {
                reserved7: u7,
                /// Vector table base offset
                TBLOFF: u25,
            }),
            /// Application Interrupt and Reset Control Register
            AIRCR: mmio.Mmio(packed struct(u32) {
                /// no description available
                VECTRESET: u1,
                /// no description available
                VECTCLRACTIVE: u1,
                /// no description available
                SYSRESETREQ: enum(u1) {
                    /// no system reset request
                    SYSRESETREQ_0 = 0x0,
                    /// asserts a signal to the outer system that requests a reset
                    SYSRESETREQ_1 = 0x1,
                },
                reserved8: u5,
                /// Interrupt priority grouping field. This field determines the split of group priority from subpriority.
                PRIGROUP: u3,
                reserved15: u4,
                /// no description available
                ENDIANNESS: enum(u1) {
                    /// Little-endian
                    ENDIANNESS_0 = 0x0,
                    /// Big-endian
                    ENDIANNESS_1 = 0x1,
                },
                /// Register key
                VECTKEY: u16,
            }),
            /// System Control Register
            SCR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// no description available
                SLEEPONEXIT: enum(u1) {
                    /// o not sleep when returning to Thread mode
                    SLEEPONEXIT_0 = 0x0,
                    /// enter sleep, or deep sleep, on return from an ISR
                    SLEEPONEXIT_1 = 0x1,
                },
                /// no description available
                SLEEPDEEP: enum(u1) {
                    /// sleep
                    SLEEPDEEP_0 = 0x0,
                    /// deep sleep
                    SLEEPDEEP_1 = 0x1,
                },
                reserved4: u1,
                /// no description available
                SEVONPEND: enum(u1) {
                    /// only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
                    SEVONPEND_0 = 0x0,
                    /// enabled events and all interrupts, including disabled interrupts, can wakeup the processor
                    SEVONPEND_1 = 0x1,
                },
                padding: u27,
            }),
            /// Configuration and Control Register
            CCR: mmio.Mmio(packed struct(u32) {
                /// no description available
                NONBASETHRDENA: enum(u1) {
                    /// processor can enter Thread mode only when no exception is active
                    NONBASETHRDENA_0 = 0x0,
                    /// processor can enter Thread mode from any level under the control of an EXC_RETURN value
                    NONBASETHRDENA_1 = 0x1,
                },
                /// Enables unprivileged software access to the STIR
                USERSETMPEND: enum(u1) {
                    /// disable
                    USERSETMPEND_0 = 0x0,
                    /// enable
                    USERSETMPEND_1 = 0x1,
                },
                reserved3: u1,
                /// Enables unaligned access traps
                UNALIGN_TRP: enum(u1) {
                    /// do not trap unaligned halfword and word accesses
                    UNALIGN_TRP_0 = 0x0,
                    /// trap unaligned halfword and word accesses
                    UNALIGN_TRP_1 = 0x1,
                },
                /// Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
                DIV_0_TRP: enum(u1) {
                    /// do not trap divide by 0
                    DIV_0_TRP_0 = 0x0,
                    /// trap divide by 0
                    DIV_0_TRP_1 = 0x1,
                },
                reserved8: u3,
                /// Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
                BFHFNMIGN: enum(u1) {
                    /// data bus faults caused by load and store instructions cause a lock-up
                    BFHFNMIGN_0 = 0x0,
                    /// handlers running at priority -1 and -2 ignore data bus faults caused by load and store instructions
                    BFHFNMIGN_1 = 0x1,
                },
                /// Indicates stack alignment on exception entry
                STKALIGN: enum(u1) {
                    /// 4-byte aligned
                    STKALIGN_0 = 0x0,
                    /// 8-byte aligned
                    STKALIGN_1 = 0x1,
                },
                padding: u22,
            }),
            /// System Handler Priority Register 1
            SHPR1: mmio.Mmio(packed struct(u32) {
                /// Priority of system handler 4, MemManage
                PRI_4: u8,
                /// Priority of system handler 5, BusFault
                PRI_5: u8,
                /// Priority of system handler 6, UsageFault
                PRI_6: u8,
                padding: u8,
            }),
            /// System Handler Priority Register 2
            SHPR2: mmio.Mmio(packed struct(u32) {
                reserved24: u24,
                /// Priority of system handler 11, SVCall
                PRI_11: u8,
            }),
            /// System Handler Priority Register 3
            SHPR3: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                /// Priority of system handler 14, PendSV
                PRI_14: u8,
                /// Priority of system handler 15, SysTick exception
                PRI_15: u8,
            }),
            /// System Handler Control and State Register
            SHCSR: mmio.Mmio(packed struct(u32) {
                /// no description available
                MEMFAULTACT: enum(u1) {
                    /// exception is not active
                    MEMFAULTACT_0 = 0x0,
                    /// exception is active
                    MEMFAULTACT_1 = 0x1,
                },
                /// no description available
                BUSFAULTACT: enum(u1) {
                    /// exception is not active
                    BUSFAULTACT_0 = 0x0,
                    /// exception is active
                    BUSFAULTACT_1 = 0x1,
                },
                reserved3: u1,
                /// no description available
                USGFAULTACT: enum(u1) {
                    /// exception is not active
                    USGFAULTACT_0 = 0x0,
                    /// exception is active
                    USGFAULTACT_1 = 0x1,
                },
                reserved7: u3,
                /// no description available
                SVCALLACT: enum(u1) {
                    /// exception is not active
                    SVCALLACT_0 = 0x0,
                    /// exception is active
                    SVCALLACT_1 = 0x1,
                },
                /// no description available
                MONITORACT: enum(u1) {
                    /// exception is not active
                    MONITORACT_0 = 0x0,
                    /// exception is active
                    MONITORACT_1 = 0x1,
                },
                reserved10: u1,
                /// no description available
                PENDSVACT: enum(u1) {
                    /// exception is not active
                    PENDSVACT_0 = 0x0,
                    /// exception is active
                    PENDSVACT_1 = 0x1,
                },
                /// no description available
                SYSTICKACT: enum(u1) {
                    /// exception is not active
                    SYSTICKACT_0 = 0x0,
                    /// exception is active
                    SYSTICKACT_1 = 0x1,
                },
                /// no description available
                USGFAULTPENDED: enum(u1) {
                    /// exception is not pending
                    USGFAULTPENDED_0 = 0x0,
                    /// exception is pending
                    USGFAULTPENDED_1 = 0x1,
                },
                /// no description available
                MEMFAULTPENDED: enum(u1) {
                    /// exception is not pending
                    MEMFAULTPENDED_0 = 0x0,
                    /// exception is pending
                    MEMFAULTPENDED_1 = 0x1,
                },
                /// no description available
                BUSFAULTPENDED: enum(u1) {
                    /// exception is not pending
                    BUSFAULTPENDED_0 = 0x0,
                    /// exception is pending
                    BUSFAULTPENDED_1 = 0x1,
                },
                /// no description available
                SVCALLPENDED: enum(u1) {
                    /// exception is not pending
                    SVCALLPENDED_0 = 0x0,
                    /// exception is pending
                    SVCALLPENDED_1 = 0x1,
                },
                /// no description available
                MEMFAULTENA: enum(u1) {
                    /// disable the exception
                    MEMFAULTENA_0 = 0x0,
                    /// enable the exception
                    MEMFAULTENA_1 = 0x1,
                },
                /// no description available
                BUSFAULTENA: enum(u1) {
                    /// disable the exception
                    BUSFAULTENA_0 = 0x0,
                    /// enable the exception
                    BUSFAULTENA_1 = 0x1,
                },
                /// no description available
                USGFAULTENA: enum(u1) {
                    /// disable the exception
                    USGFAULTENA_0 = 0x0,
                    /// enable the exception
                    USGFAULTENA_1 = 0x1,
                },
                padding: u13,
            }),
            /// Configurable Fault Status Registers
            CFSR: mmio.Mmio(packed struct(u32) {
                /// no description available
                IACCVIOL: enum(u1) {
                    /// no instruction access violation fault
                    IACCVIOL_0 = 0x0,
                    /// the processor attempted an instruction fetch from a location that does not permit execution
                    IACCVIOL_1 = 0x1,
                },
                /// no description available
                DACCVIOL: enum(u1) {
                    /// no data access violation fault
                    DACCVIOL_0 = 0x0,
                    /// the processor attempted a load or store at a location that does not permit the operation
                    DACCVIOL_1 = 0x1,
                },
                reserved3: u1,
                /// no description available
                MUNSTKERR: enum(u1) {
                    /// no unstacking fault
                    MUNSTKERR_0 = 0x0,
                    /// unstack for an exception return has caused one or more access violations
                    MUNSTKERR_1 = 0x1,
                },
                /// no description available
                MSTKERR: enum(u1) {
                    /// no stacking fault
                    MSTKERR_0 = 0x0,
                    /// stacking for an exception entry has caused one or more access violations
                    MSTKERR_1 = 0x1,
                },
                /// no description available
                MLSPERR: enum(u1) {
                    /// No MemManage fault occurred during floating-point lazy state preservation
                    MLSPERR_0 = 0x0,
                    /// A MemManage fault occurred during floating-point lazy state preservation
                    MLSPERR_1 = 0x1,
                },
                reserved7: u1,
                /// no description available
                MMARVALID: enum(u1) {
                    /// value in MMAR is not a valid fault address
                    MMARVALID_0 = 0x0,
                    /// MMAR holds a valid fault address
                    MMARVALID_1 = 0x1,
                },
                /// no description available
                IBUSERR: enum(u1) {
                    /// no instruction bus error
                    IBUSERR_0 = 0x0,
                    /// instruction bus error
                    IBUSERR_1 = 0x1,
                },
                /// no description available
                PRECISERR: enum(u1) {
                    /// no precise data bus error
                    PRECISERR_0 = 0x0,
                    /// a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault
                    PRECISERR_1 = 0x1,
                },
                /// no description available
                IMPRECISERR: enum(u1) {
                    /// no imprecise data bus error
                    IMPRECISERR_0 = 0x0,
                    /// a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error
                    IMPRECISERR_1 = 0x1,
                },
                /// no description available
                UNSTKERR: enum(u1) {
                    /// no unstacking fault
                    UNSTKERR_0 = 0x0,
                    /// unstack for an exception return has caused one or more BusFaults
                    UNSTKERR_1 = 0x1,
                },
                /// no description available
                STKERR: enum(u1) {
                    /// no stacking fault
                    STKERR_0 = 0x0,
                    /// stacking for an exception entry has caused one or more BusFaults
                    STKERR_1 = 0x1,
                },
                /// no description available
                LSPERR: enum(u1) {
                    /// No bus fault occurred during floating-point lazy state preservation
                    LSPERR_0 = 0x0,
                    /// A bus fault occurred during floating-point lazy state preservation
                    LSPERR_1 = 0x1,
                },
                reserved15: u1,
                /// no description available
                BFARVALID: enum(u1) {
                    /// value in BFAR is not a valid fault address
                    BFARVALID_0 = 0x0,
                    /// BFAR holds a valid fault address
                    BFARVALID_1 = 0x1,
                },
                /// no description available
                UNDEFINSTR: enum(u1) {
                    /// no undefined instruction UsageFault
                    UNDEFINSTR_0 = 0x0,
                    /// the processor has attempted to execute an undefined instruction
                    UNDEFINSTR_1 = 0x1,
                },
                /// no description available
                INVSTATE: enum(u1) {
                    /// no invalid state UsageFault
                    INVSTATE_0 = 0x0,
                    /// the processor has attempted to execute an instruction that makes illegal use of the EPSR
                    INVSTATE_1 = 0x1,
                },
                /// no description available
                INVPC: enum(u1) {
                    /// no invalid PC load UsageFault
                    INVPC_0 = 0x0,
                    /// the processor has attempted an illegal load of EXC_RETURN to the PC
                    INVPC_1 = 0x1,
                },
                /// no description available
                NOCP: enum(u1) {
                    /// no UsageFault caused by attempting to access a coprocessor
                    NOCP_0 = 0x0,
                    /// the processor has attempted to access a coprocessor
                    NOCP_1 = 0x1,
                },
                reserved24: u4,
                /// no description available
                UNALIGNED: enum(u1) {
                    /// no unaligned access fault, or unaligned access trapping not enabled
                    UNALIGNED_0 = 0x0,
                    /// the processor has made an unaligned memory access
                    UNALIGNED_1 = 0x1,
                },
                /// no description available
                DIVBYZERO: enum(u1) {
                    /// no divide by zero fault, or divide by zero trapping not enabled
                    DIVBYZERO_0 = 0x0,
                    /// the processor has executed an SDIV or UDIV instruction with a divisor of 0
                    DIVBYZERO_1 = 0x1,
                },
                padding: u6,
            }),
            /// HardFault Status register
            HFSR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// no description available
                VECTTBL: enum(u1) {
                    /// no BusFault on vector table read
                    VECTTBL_0 = 0x0,
                    /// BusFault on vector table read
                    VECTTBL_1 = 0x1,
                },
                reserved30: u28,
                /// no description available
                FORCED: enum(u1) {
                    /// no forced HardFault
                    FORCED_0 = 0x0,
                    /// forced HardFault
                    FORCED_1 = 0x1,
                },
                /// no description available
                DEBUGEVT: u1,
            }),
            /// Debug Fault Status Register
            DFSR: mmio.Mmio(packed struct(u32) {
                /// no description available
                HALTED: enum(u1) {
                    /// No active halt request debug event
                    HALTED_0 = 0x0,
                    /// Halt request debug event active
                    HALTED_1 = 0x1,
                },
                /// no description available
                BKPT: enum(u1) {
                    /// No current breakpoint debug event
                    BKPT_0 = 0x0,
                    /// At least one current breakpoint debug event
                    BKPT_1 = 0x1,
                },
                /// no description available
                DWTTRAP: enum(u1) {
                    /// No current debug events generated by the DWT
                    DWTTRAP_0 = 0x0,
                    /// At least one current debug event generated by the DWT
                    DWTTRAP_1 = 0x1,
                },
                /// no description available
                VCATCH: enum(u1) {
                    /// No Vector catch triggered
                    VCATCH_0 = 0x0,
                    /// Vector catch triggered
                    VCATCH_1 = 0x1,
                },
                /// no description available
                EXTERNAL: enum(u1) {
                    /// No EDBGRQ debug event
                    EXTERNAL_0 = 0x0,
                    /// EDBGRQ debug event
                    EXTERNAL_1 = 0x1,
                },
                padding: u27,
            }),
            /// MemManage Address Register
            MMFAR: mmio.Mmio(packed struct(u32) {
                /// Address of MemManage fault location
                ADDRESS: u32,
            }),
            /// BusFault Address Register
            BFAR: mmio.Mmio(packed struct(u32) {
                /// Address of the BusFault location
                ADDRESS: u32,
            }),
            /// Auxiliary Fault Status Register
            AFSR: mmio.Mmio(packed struct(u32) {
                /// Latched version of the AUXFAULT inputs
                AUXFAULT: u32,
            }),
            reserved3464: [72]u8,
            /// Coprocessor Access Control Register
            CPACR: mmio.Mmio(packed struct(u32) {
                reserved20: u20,
                /// Access privileges for coprocessor 10.
                CP10: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault
                    CP10_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP fault.
                    CP10_1 = 0x1,
                    /// Full access.
                    CP10_3 = 0x3,
                    _,
                },
                /// Access privileges for coprocessor 11.
                CP11: enum(u2) {
                    /// Access denied. Any attempted access generates a NOCP UsageFault
                    CP11_0 = 0x0,
                    /// Privileged access only. An unprivileged access generates a NOCP fault.
                    CP11_1 = 0x1,
                    /// Full access.
                    CP11_3 = 0x3,
                    _,
                },
                padding: u8,
            }),
            reserved3892: [424]u8,
            /// Floating-point Context Control Register
            FPCCR: mmio.Mmio(packed struct(u32) {
                /// Lazy state preservation.
                LSPACT: enum(u1) {
                    /// Lazy state preservation is not active.
                    LSPACT_0 = 0x0,
                    /// Lazy state preservation is active. floating-point stack frame has been allocated but saving state to it has been deferred.
                    LSPACT_1 = 0x1,
                },
                /// Privilege level when the floating-point stack frame was allocated.
                USER: enum(u1) {
                    /// Privilege level was not user when the floating-point stack frame was allocated.
                    USER_0 = 0x0,
                    /// Privilege level was user when the floating-point stack frame was allocated.
                    USER_1 = 0x1,
                },
                reserved3: u1,
                /// Mode when the floating-point stack frame was allocated.
                THREAD: enum(u1) {
                    /// Mode was not Thread Mode when the floating-point stack frame was allocated.
                    THREAD_0 = 0x0,
                    /// Mode was Thread Mode when the floating-point stack frame was allocated.
                    THREAD_1 = 0x1,
                },
                /// Permission to set the HardFault handler to the pending state when the floating-point stack frame was allocated.
                HFRDY: enum(u1) {
                    /// Priority did not permit setting the HardFault handler to the pending state when the floating-point stack frame was allocated.
                    HFRDY_0 = 0x0,
                    /// Priority permitted setting the HardFault handler to the pending state when the floating-point stack frame was allocated.
                    HFRDY_1 = 0x1,
                },
                /// Permission to set the MemManage handler to the pending state when the floating-point stack frame was allocated.
                MMRDY: enum(u1) {
                    /// MemManage is disabled or priority did not permit setting the MemManage handler to the pending state when the floating-point stack frame was allocated.
                    MMRDY_0 = 0x0,
                    /// MemManage is enabled and priority permitted setting the MemManage handler to the pending state when the floating-point stack frame was allocated.
                    MMRDY_1 = 0x1,
                },
                /// Permission to set the BusFault handler to the pending state when the floating-point stack frame was allocated.
                BFRDY: enum(u1) {
                    /// BusFault is disabled or priority did not permit setting the BusFault handler to the pending state when the floating-point stack frame was allocated.
                    BFRDY_0 = 0x0,
                    /// BusFault is disabled or priority did not permit setting the BusFault handler to the pending state when the floating-point stack frame was allocated.
                    BFRDY_1 = 0x1,
                },
                reserved8: u1,
                /// Permission to set the MON_PEND when the floating-point stack frame was allocated.
                MONRDY: enum(u1) {
                    /// DebugMonitor is disabled or priority did not permit setting MON_PEND when the floating-point stack frame was allocated.
                    MONRDY_0 = 0x0,
                    /// DebugMonitor is enabled and priority permits setting MON_PEND when the floating-point stack frame was allocated.
                    MONRDY_1 = 0x1,
                },
                reserved30: u21,
                /// Lazy state preservation for floating-point context.
                LSPEN: enum(u1) {
                    /// Disable automatic lazy state preservation for floating-point context.
                    LSPEN_0 = 0x0,
                    /// Enable automatic lazy state preservation for floating-point context.
                    LSPEN_1 = 0x1,
                },
                /// Enables CONTROL2 setting on execution of a floating-point instruction. This results in automatic hardware state preservation and restoration, for floating-point context, on exception entry and exit.
                ASPEN: enum(u1) {
                    /// Disable CONTROL2 setting on execution of a floating-point instruction.
                    ASPEN_0 = 0x0,
                    /// Enable CONTROL2 setting on execution of a floating-point instruction.
                    ASPEN_1 = 0x1,
                },
            }),
            /// Floating-point Context Address Register
            FPCAR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// The location of the unpopulated floating-point register space allocated on an exception stack frame.
                ADDRESS: u29,
            }),
            /// Floating-point Default Status Control Register
            FPDSCR: mmio.Mmio(packed struct(u32) {
                reserved22: u22,
                /// Default value for FPSCR.RMode (Rounding Mode control field).
                RMode: enum(u2) {
                    /// Round to Nearest (RN) mode
                    RMode_0 = 0x0,
                    /// Round towards Plus Infinity (RP) mode.
                    RMode_1 = 0x1,
                    /// Round towards Minus Infinity (RM) mode.
                    RMode_2 = 0x2,
                    /// Round towards Zero (RZ) mode.
                    RMode_3 = 0x3,
                },
                /// Default value for FPSCR.FZ (Flush-to-zero mode control bit).
                FZ: enum(u1) {
                    /// Flush-to-zero mode disabled. Behavior of the floating-point system is fully compliant with the IEEE 754 standard.
                    FZ_0 = 0x0,
                    /// Flush-to-zero mode enabled.
                    FZ_1 = 0x1,
                },
                /// Default value for FPSCR.DN (Default NaN mode control bit).
                DN: enum(u1) {
                    /// NaN operands propagate through to the output of a floating-point operation.
                    DN_0 = 0x0,
                    /// Any operation involving one or more NaNs returns the Default NaN.
                    DN_1 = 0x1,
                },
                /// Default value for FPSCR.AHP (Alternative half-precision control bit).
                AHP: enum(u1) {
                    /// IEEE half-precision format selected.
                    AHP_0 = 0x0,
                    /// Alternative half-precision format selected.
                    AHP_1 = 0x1,
                },
                padding: u5,
            }),
        };

        /// LPC5411x USARTs
        pub const USART0 = extern struct {
            /// USART Configuration register. Basic USART configuration settings that typically are not changed during operation.
            CFG: mmio.Mmio(packed struct(u32) {
                /// USART Enable.
                ENABLE: enum(u1) {
                    /// Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. When re-enabled, the USART will immediately be ready to transmit because the transmitter has been reset and is therefore available.
                    DISABLED = 0x0,
                    /// Enabled. The USART is enabled for operation.
                    ENABLED = 0x1,
                },
                reserved2: u1,
                /// Selects the data size for the USART.
                DATALEN: enum(u2) {
                    /// 7 bit Data length.
                    BIT_7 = 0x0,
                    /// 8 bit Data length.
                    BIT_8 = 0x1,
                    /// 9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTL register.
                    BIT_9 = 0x2,
                    _,
                },
                /// Selects what type of parity is used by the USART.
                PARITYSEL: enum(u2) {
                    /// No parity.
                    NO_PARITY = 0x0,
                    /// Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even.
                    EVEN_PARITY = 0x2,
                    /// Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.
                    ODD_PARITY = 0x3,
                    _,
                },
                /// Number of stop bits appended to transmitted data. Only a single stop bit is required for received data.
                STOPLEN: enum(u1) {
                    /// 1 stop bit.
                    BIT_1 = 0x0,
                    /// 2 stop bits. This setting should only be used for asynchronous communication.
                    BITS_2 = 0x1,
                },
                /// Selects standard or 32 kHz clocking mode.
                MODE32K: enum(u1) {
                    /// Disabled. USART uses standard clocking.
                    DISABLED = 0x0,
                    /// Enabled. USART uses the 32 kHz clock from the RTC oscillator as the clock source to the BRG, and uses a special bit clocking scheme.
                    ENABLED = 0x1,
                },
                /// LIN break mode enable.
                LINMODE: enum(u1) {
                    /// Disabled. Break detect and generate is configured for normal operation.
                    DISABLED = 0x0,
                    /// Enabled. Break detect and generate is configured for LIN bus operation.
                    ENABLED = 0x1,
                },
                /// CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled.
                CTSEN: enum(u1) {
                    /// No flow control. The transmitter does not receive any automatic flow control signal.
                    DISABLED = 0x0,
                    /// Flow control enabled. The transmitter uses the CTS input (or RTS output in loopback mode) for flow control purposes.
                    ENABLED = 0x1,
                },
                reserved11: u1,
                /// Selects synchronous or asynchronous operation.
                SYNCEN: enum(u1) {
                    /// Asynchronous mode.
                    ASYNCHRONOUS_MODE = 0x0,
                    /// Synchronous mode.
                    SYNCHRONOUS_MODE = 0x1,
                },
                /// Selects the clock polarity and sampling edge of received data in synchronous mode.
                CLKPOL: enum(u1) {
                    /// Falling edge. Un_RXD is sampled on the falling edge of SCLK.
                    FALLING_EDGE = 0x0,
                    /// Rising edge. Un_RXD is sampled on the rising edge of SCLK.
                    RISING_EDGE = 0x1,
                },
                reserved14: u1,
                /// Synchronous mode Master select.
                SYNCMST: enum(u1) {
                    /// Slave. When synchronous mode is enabled, the USART is a slave.
                    SLAVE = 0x0,
                    /// Master. When synchronous mode is enabled, the USART is a master.
                    MASTER = 0x1,
                },
                /// Selects data loopback mode.
                LOOP: enum(u1) {
                    /// Normal operation.
                    NORMAL = 0x0,
                    /// Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.
                    LOOPBACK = 0x1,
                },
                reserved18: u2,
                /// Output Enable Turnaround time enable for RS-485 operation.
                OETA: enum(u1) {
                    /// Disabled. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission.
                    DISABLED = 0x0,
                    /// Enabled. If selected by OESEL, the Output Enable signal remains asserted for one character time after the end of the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted.
                    ENABLED = 0x1,
                },
                /// Automatic Address matching enable.
                AUTOADDR: enum(u1) {
                    /// Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address).
                    DISABLED = 0x0,
                    /// Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match.
                    ENABLED = 0x1,
                },
                /// Output Enable Select.
                OESEL: enum(u1) {
                    /// Standard. The RTS signal is used as the standard flow control function.
                    STANDARD = 0x0,
                    /// RS-485. The RTS signal configured to provide an output enable signal to control an RS-485 transceiver.
                    RS_485 = 0x1,
                },
                /// Output Enable Polarity.
                OEPOL: enum(u1) {
                    /// Low. If selected by OESEL, the output enable is active low.
                    LOW = 0x0,
                    /// High. If selected by OESEL, the output enable is active high.
                    HIGH = 0x1,
                },
                /// Receive data polarity.
                RXPOL: enum(u1) {
                    /// Standard. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.
                    STANDARD = 0x0,
                    /// Inverted. The RX signal is inverted before being used by the USART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.
                    INVERTED = 0x1,
                },
                /// Transmit data polarity.
                TXPOL: enum(u1) {
                    /// Standard. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1.
                    STANDARD = 0x0,
                    /// Inverted. The TX signal is inverted by the USART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.
                    INVERTED = 0x1,
                },
                padding: u8,
            }),
            /// USART Control register. USART control settings that are more likely to change during operation.
            CTL: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// Break Enable.
                TXBRKEN: enum(u1) {
                    /// Normal operation.
                    NORMAL = 0x0,
                    /// Continuous break. Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.
                    CONTINOUS = 0x1,
                },
                /// Enable address detect mode.
                ADDRDET: enum(u1) {
                    /// Disabled. The USART presents all incoming data.
                    DISABLED = 0x0,
                    /// Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.
                    ENABLED = 0x1,
                },
                reserved6: u3,
                /// Transmit Disable.
                TXDIS: enum(u1) {
                    /// Not disabled. USART transmitter is not disabled.
                    ENABLED = 0x0,
                    /// Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.
                    DISABLED = 0x1,
                },
                reserved8: u1,
                /// Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode.
                CC: enum(u1) {
                    /// Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received.
                    CLOCK_ON_CHARACTER = 0x0,
                    /// Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).
                    CONTINOUS_CLOCK = 0x1,
                },
                /// Clear Continuous Clock.
                CLRCCONRX: enum(u1) {
                    /// No effect. No effect on the CC bit.
                    NO_EFFECT = 0x0,
                    /// Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.
                    AUTO_CLEAR = 0x1,
                },
                reserved16: u6,
                /// Autobaud enable.
                AUTOBAUD: enum(u1) {
                    /// Disabled. USART is in normal operating mode.
                    DISABLED = 0x0,
                    /// Enabled. USART is in autobaud mode. This bit should only be set when the USART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR.
                    ENABLED = 0x1,
                },
                padding: u15,
            }),
            /// USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them.
            STAT: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                /// Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.
                RXIDLE: u1,
                reserved3: u1,
                /// Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.
                TXIDLE: u1,
                /// This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled.
                CTS: u1,
                /// This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.
                DELTACTS: u1,
                /// Transmitter Disabled Status flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS bit in the CFG register (TXDIS = 1).
                TXDISSTAT: u1,
                reserved10: u3,
                /// Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.
                RXBRK: u1,
                /// This bit is set when a change in the state of receiver break detection occurs. Cleared by software.
                DELTARXBRK: u1,
                /// This bit is set when a start is detected on the receiver input. Its purpose is primarily to allow wake-up from Deep-sleep or Power-down mode immediately when a start is detected. Cleared by software.
                START: u1,
                /// Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.
                FRAMERRINT: u1,
                /// Parity Error interrupt flag. This flag is set when a parity error is detected in a received character.
                PARITYERRINT: u1,
                /// Received Noise interrupt flag. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. This flag is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception.
                RXNOISEINT: u1,
                /// Auto baud Error. An auto baud error can occur if the BRG counts to its limit before the end of the start bit that is being measured, essentially an auto baud time-out.
                ABERR: u1,
                padding: u15,
            }),
            /// Interrupt Enable read and Set register for USART (not FIFO) status. Contains individual interrupt enable bits for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.
            INTENSET: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// When 1, enables an interrupt when the transmitter becomes idle (TXIDLE = 1).
                TXIDLEEN: u1,
                reserved5: u1,
                /// When 1, enables an interrupt when there is a change in the state of the CTS input.
                DELTACTSEN: u1,
                /// When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.
                TXDISEN: u1,
                reserved11: u4,
                /// When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).
                DELTARXBRKEN: u1,
                /// When 1, enables an interrupt when a received start bit has been detected.
                STARTEN: u1,
                /// When 1, enables an interrupt when a framing error has been detected.
                FRAMERREN: u1,
                /// When 1, enables an interrupt when a parity error has been detected.
                PARITYERREN: u1,
                /// When 1, enables an interrupt when noise is detected. See description of the RXNOISEINT bit in Table 354.
                RXNOISEEN: u1,
                /// When 1, enables an interrupt when an auto baud error occurs.
                ABERREN: u1,
                padding: u15,
            }),
            /// Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.
            INTENCLR: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                TXIDLECLR: u1,
                reserved5: u1,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                DELTACTSCLR: u1,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                TXDISCLR: u1,
                reserved11: u4,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                DELTARXBRKCLR: u1,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                STARTCLR: u1,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                FRAMERRCLR: u1,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                PARITYERRCLR: u1,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                RXNOISECLR: u1,
                /// Writing 1 clears the corresponding bit in the INTENSET register.
                ABERRCLR: u1,
                padding: u15,
            }),
            reserved32: [12]u8,
            /// Baud Rate Generator register. 16-bit integer baud rate divisor value.
            BRG: mmio.Mmio(packed struct(u32) {
                /// This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = FCLK is used directly by the USART function. 1 = FCLK is divided by 2 before use by the USART function. 2 = FCLK is divided by 3 before use by the USART function. 0xFFFF = FCLK is divided by 65,536 before use by the USART function.
                BRGVAL: u16,
                padding: u16,
            }),
            /// Interrupt status register. Reflects interrupts that are currently enabled.
            INTSTAT: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                /// Transmitter Idle status.
                TXIDLE: u1,
                reserved5: u1,
                /// This bit is set when a change in the state of the CTS input is detected.
                DELTACTS: u1,
                /// Transmitter Disabled Interrupt flag.
                TXDISINT: u1,
                reserved11: u4,
                /// This bit is set when a change in the state of receiver break detection occurs.
                DELTARXBRK: u1,
                /// This bit is set when a start is detected on the receiver input.
                START: u1,
                /// Framing Error interrupt flag.
                FRAMERRINT: u1,
                /// Parity Error interrupt flag.
                PARITYERRINT: u1,
                /// Received Noise interrupt flag.
                RXNOISEINT: u1,
                /// Auto baud Error Interrupt flag.
                ABERRINT: u1,
                padding: u15,
            }),
            /// Oversample selection register for asynchronous communication.
            OSR: mmio.Mmio(packed struct(u32) {
                /// Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 function clocks are used to transmit and receive each data bit. 0x5 = 6 function clocks are used to transmit and receive each data bit. 0xF= 16 function clocks are used to transmit and receive each data bit.
                OSRVAL: u4,
                padding: u28,
            }),
            /// Address register for automatic address matching.
            ADDR: mmio.Mmio(packed struct(u32) {
                /// 8-bit address used with automatic address matching. Used when address detection is enabled (ADDRDET in CTL = 1) and automatic address matching is enabled (AUTOADDR in CFG = 1).
                ADDRESS: u8,
                padding: u24,
            }),
            reserved3584: [3536]u8,
            /// FIFO configuration and enable register.
            FIFOCFG: mmio.Mmio(packed struct(u32) {
                /// Enable the transmit FIFO.
                ENABLETX: enum(u1) {
                    /// The transmit FIFO is not enabled.
                    DISABLED = 0x0,
                    /// The transmit FIFO is enabled.
                    ENABLED = 0x1,
                },
                /// Enable the receive FIFO.
                ENABLERX: enum(u1) {
                    /// The receive FIFO is not enabled.
                    DISABLED = 0x0,
                    /// The receive FIFO is enabled.
                    ENABLED = 0x1,
                },
                reserved4: u2,
                /// FIFO size configuration. This is a read-only field. 0x0 = FIFO is configured as 16 entries of 8 bits. 0x1, 0x2, 0x3 = not applicable to USART.
                SIZE: u2,
                reserved12: u6,
                /// DMA configuration for transmit.
                DMATX: enum(u1) {
                    /// DMA is not used for the transmit function.
                    DISABLED = 0x0,
                    /// Trigger DMA for the transmit function if the FIFO is not full. Generally, data interrupts would be disabled if DMA is enabled.
                    ENABLED = 0x1,
                },
                /// DMA configuration for receive.
                DMARX: enum(u1) {
                    /// DMA is not used for the receive function.
                    DISABLED = 0x0,
                    /// Trigger DMA for the receive function if the FIFO is not empty. Generally, data interrupts would be disabled if DMA is enabled.
                    ENABLED = 0x1,
                },
                /// Wake-up for transmit FIFO level. This allows the device to be woken from reduced power modes (up to power-down, as long as the peripheral function works in that power mode) without enabling the TXLVL interrupt. Only DMA wakes up, processes data, and goes back to sleep. The CPU will remain stopped until woken by another cause, such as DMA completion. See Hardware Wake-up control register.
                WAKETX: enum(u1) {
                    /// Only enabled interrupts will wake up the device form reduced power modes.
                    DISABLED = 0x0,
                    /// A device wake-up for DMA will occur if the transmit FIFO level reaches the value specified by TXLVL in FIFOTRIG, even when the TXLVL interrupt is not enabled.
                    ENABLED = 0x1,
                },
                /// Wake-up for receive FIFO level. This allows the device to be woken from reduced power modes (up to power-down, as long as the peripheral function works in that power mode) without enabling the TXLVL interrupt. Only DMA wakes up, processes data, and goes back to sleep. The CPU will remain stopped until woken by another cause, such as DMA completion. See Hardware Wake-up control register.
                WAKERX: enum(u1) {
                    /// Only enabled interrupts will wake up the device form reduced power modes.
                    DISABLED = 0x0,
                    /// A device wake-up for DMA will occur if the receive FIFO level reaches the value specified by RXLVL in FIFOTRIG, even when the RXLVL interrupt is not enabled.
                    ENABLED = 0x1,
                },
                /// Empty command for the transmit FIFO. When a 1 is written to this bit, the TX FIFO is emptied.
                EMPTYTX: u1,
                /// Empty command for the receive FIFO. When a 1 is written to this bit, the RX FIFO is emptied.
                EMPTYRX: u1,
                /// Pop FIFO for debug reads.
                POPDBG: enum(u1) {
                    /// Debug reads of the FIFO do not pop the FIFO.
                    DO_NOT_POP = 0x0,
                    /// A debug read will cause the FIFO to pop.
                    POP = 0x1,
                },
                padding: u13,
            }),
            /// FIFO status register.
            FIFOSTAT: mmio.Mmio(packed struct(u32) {
                /// TX FIFO error. Will be set if a transmit FIFO error occurs. This could be an overflow caused by pushing data into a full FIFO, or by an underflow if the FIFO is empty when data is needed. Cleared by writing a 1 to this bit.
                TXERR: u1,
                /// RX FIFO error. Will be set if a receive FIFO overflow occurs, caused by software or DMA not emptying the FIFO fast enough. Cleared by writing a 1 to this bit.
                RXERR: u1,
                reserved3: u1,
                /// Peripheral interrupt. When 1, this indicates that the peripheral function has asserted an interrupt. The details can be found by reading the peripheral's STAT register.
                PERINT: u1,
                /// Transmit FIFO empty. When 1, the transmit FIFO is empty. The peripheral may still be processing the last piece of data.
                TXEMPTY: u1,
                /// Transmit FIFO not full. When 1, the transmit FIFO is not full, so more data can be written. When 0, the transmit FIFO is full and another write would cause it to overflow.
                TXNOTFULL: u1,
                /// Receive FIFO not empty. When 1, the receive FIFO is not empty, so data can be read. When 0, the receive FIFO is empty.
                RXNOTEMPTY: u1,
                /// Receive FIFO full. When 1, the receive FIFO is full. Data needs to be read out to prevent the peripheral from causing an overflow.
                RXFULL: u1,
                /// Transmit FIFO current level. A 0 means the TX FIFO is currently empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other values tell how much data is actually in the TX FIFO at the point where the read occurs. If the TX FIFO is full, the TXEMPTY and TXNOTFULL flags will be 0.
                TXLVL: u5,
                reserved16: u3,
                /// Receive FIFO current level. A 0 means the RX FIFO is currently empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other values tell how much data is actually in the RX FIFO at the point where the read occurs. If the RX FIFO is full, the RXFULL and RXNOTEMPTY flags will be 1.
                RXLVL: u5,
                padding: u11,
            }),
            /// FIFO trigger settings for interrupt and DMA request.
            FIFOTRIG: mmio.Mmio(packed struct(u32) {
                /// Transmit FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMATX in FIFOCFG is set.
                TXLVLENA: enum(u1) {
                    /// Transmit FIFO level does not generate a FIFO level trigger.
                    DISABLED = 0x0,
                    /// An trigger will be generated if the transmit FIFO level reaches the value specified by the TXLVL field in this register.
                    ENABLED = 0x1,
                },
                /// Receive FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMARX in FIFOCFG is set.
                RXLVLENA: enum(u1) {
                    /// Receive FIFO level does not generate a FIFO level trigger.
                    DISABLED = 0x0,
                    /// An trigger will be generated if the receive FIFO level reaches the value specified by the RXLVL field in this register.
                    ENABLED = 0x1,
                },
                reserved8: u6,
                /// Transmit FIFO level trigger point. This field is used only when TXLVLENA = 1. If enabled to do so, the FIFO level can wake up the device just enough to perform DMA, then return to the reduced power mode. See Hardware Wake-up control register. 0 = trigger when the TX FIFO becomes empty. 1 = trigger when the TX FIFO level decreases to one entry. 15 = trigger when the TX FIFO level decreases to 15 entries (is no longer full).
                TXLVL: u4,
                reserved16: u4,
                /// Receive FIFO level trigger point. The RX FIFO level is checked when a new piece of data is received. This field is used only when RXLVLENA = 1. If enabled to do so, the FIFO level can wake up the device just enough to perform DMA, then return to the reduced power mode. See Hardware Wake-up control register. 0 = trigger when the RX FIFO has received one entry (is no longer empty). 1 = trigger when the RX FIFO has received two entries. 15 = trigger when the RX FIFO has received 16 entries (has become full).
                RXLVL: u4,
                padding: u12,
            }),
            reserved3600: [4]u8,
            /// FIFO interrupt enable set (enable) and read register.
            FIFOINTENSET: mmio.Mmio(packed struct(u32) {
                /// Determines whether an interrupt occurs when a transmit error occurs, based on the TXERR flag in the FIFOSTAT register.
                TXERR: enum(u1) {
                    /// No interrupt will be generated for a transmit error.
                    DISABLED = 0x0,
                    /// An interrupt will be generated when a transmit error occurs.
                    ENABLED = 0x1,
                },
                /// Determines whether an interrupt occurs when a receive error occurs, based on the RXERR flag in the FIFOSTAT register.
                RXERR: enum(u1) {
                    /// No interrupt will be generated for a receive error.
                    DISABLED = 0x0,
                    /// An interrupt will be generated when a receive error occurs.
                    ENABLED = 0x1,
                },
                /// Determines whether an interrupt occurs when a the transmit FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.
                TXLVL: enum(u1) {
                    /// No interrupt will be generated based on the TX FIFO level.
                    DISABLED = 0x0,
                    /// If TXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the TX FIFO level decreases to the level specified by TXLVL in the FIFOTRIG register.
                    ENABLED = 0x1,
                },
                /// Determines whether an interrupt occurs when a the receive FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.
                RXLVL: enum(u1) {
                    /// No interrupt will be generated based on the RX FIFO level.
                    DISABLED = 0x0,
                    /// If RXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the when the RX FIFO level increases to the level specified by RXLVL in the FIFOTRIG register.
                    ENABLED = 0x1,
                },
                padding: u28,
            }),
            /// FIFO interrupt enable clear (disable) and read register.
            FIFOINTENCLR: mmio.Mmio(packed struct(u32) {
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                TXERR: u1,
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                RXERR: u1,
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                TXLVL: u1,
                /// Writing one clears the corresponding bits in the FIFOINTENSET register.
                RXLVL: u1,
                padding: u28,
            }),
            /// FIFO interrupt status register.
            FIFOINTSTAT: mmio.Mmio(packed struct(u32) {
                /// TX FIFO error.
                TXERR: u1,
                /// RX FIFO error.
                RXERR: u1,
                /// Transmit FIFO level interrupt.
                TXLVL: u1,
                /// Receive FIFO level interrupt.
                RXLVL: u1,
                /// Peripheral interrupt.
                PERINT: u1,
                padding: u27,
            }),
            reserved3616: [4]u8,
            /// FIFO write data.
            FIFOWR: mmio.Mmio(packed struct(u32) {
                /// Transmit data to the FIFO.
                TXDATA: u9,
                padding: u23,
            }),
            reserved3632: [12]u8,
            /// FIFO read data.
            FIFORD: mmio.Mmio(packed struct(u32) {
                /// Received data from the FIFO. The number of bits used depends on the DATALEN and PARITYSEL settings.
                RXDATA: u9,
                reserved13: u4,
                /// Framing Error status flag. This bit reflects the status for the data it is read along with from the FIFO, and indicates that the character was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.
                FRAMERR: u1,
                /// Parity Error status flag. This bit reflects the status for the data it is read along with from the FIFO. This bit will be set when a parity error is detected in a received character.
                PARITYERR: u1,
                /// Received Noise flag. See description of the RxNoiseInt bit in Table 354.
                RXNOISE: u1,
                padding: u16,
            }),
            reserved3648: [12]u8,
            /// FIFO data read with no FIFO pop.
            FIFORDNOPOP: mmio.Mmio(packed struct(u32) {
                /// Received data from the FIFO. The number of bits used depends on the DATALEN and PARITYSEL settings.
                RXDATA: u9,
                reserved13: u4,
                /// Framing Error status flag. This bit reflects the status for the data it is read along with from the FIFO, and indicates that the character was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.
                FRAMERR: u1,
                /// Parity Error status flag. This bit reflects the status for the data it is read along with from the FIFO. This bit will be set when a parity error is detected in a received character.
                PARITYERR: u1,
                /// Received Noise flag. See description of the RxNoiseInt bit in Table 354.
                RXNOISE: u1,
                padding: u16,
            }),
            reserved4092: [440]u8,
            /// Peripheral identification register.
            ID: mmio.Mmio(packed struct(u32) {
                /// Aperture: encoded as (aperture size/4K) -1, so 0x00 means a 4K aperture.
                APERTURE: u8,
                /// Minor revision of module implementation.
                MINOR_REV: u4,
                /// Major revision of module implementation.
                MAJOR_REV: u4,
                /// Module identifier for the selected function.
                ID: u16,
            }),
        };

        /// LPC5411x USB 2.0 Device Controller
        pub const USB0 = extern struct {
            /// USB Device Command/Status register
            DEVCMDSTAT: mmio.Mmio(packed struct(u32) {
                /// USB device address. After bus reset, the address is reset to 0x00. If the enable bit is set, the device will respond on packets for function address DEV_ADDR. When receiving a SetAddress Control Request from the USB host, software must program the new address before completing the status phase of the SetAddress Control Request.
                DEV_ADDR: u7,
                /// USB device enable. If this bit is set, the HW will start responding on packets for function address DEV_ADDR.
                DEV_EN: u1,
                /// SETUP token received. If a SETUP token is received and acknowledged by the device, this bit is set. As long as this bit is set all received IN and OUT tokens will be NAKed by HW. SW must clear this bit by writing a one. If this bit is zero, HW will handle the tokens to the CTRL EP0 as indicated by the CTRL EP0 IN and OUT data information programmed by SW.
                SETUP: u1,
                /// Forces the NEEDCLK output to always be on:
                FORCE_NEEDCLK: enum(u1) {
                    /// USB_NEEDCLK has normal function.
                    NORMAL = 0x0,
                    /// USB_NEEDCLK always 1. Clock will not be stopped in case of suspend.
                    ALWAYS_ON = 0x1,
                },
                reserved11: u1,
                /// LPM Supported:
                LPM_SUP: enum(u1) {
                    /// LPM not supported.
                    NO = 0x0,
                    /// LPM supported.
                    YES = 0x1,
                },
                /// Interrupt on NAK for interrupt and bulk OUT EP
                INTONNAK_AO: enum(u1) {
                    /// Only acknowledged packets generate an interrupt
                    DISABLED = 0x0,
                    /// Both acknowledged and NAKed packets generate interrupts.
                    ENABLED = 0x1,
                },
                /// Interrupt on NAK for interrupt and bulk IN EP
                INTONNAK_AI: enum(u1) {
                    /// Only acknowledged packets generate an interrupt
                    DISABLED = 0x0,
                    /// Both acknowledged and NAKed packets generate interrupts.
                    ENABLED = 0x1,
                },
                /// Interrupt on NAK for control OUT EP
                INTONNAK_CO: enum(u1) {
                    /// Only acknowledged packets generate an interrupt
                    DISABLED = 0x0,
                    /// Both acknowledged and NAKed packets generate interrupts.
                    ENABLED = 0x1,
                },
                /// Interrupt on NAK for control IN EP
                INTONNAK_CI: enum(u1) {
                    /// Only acknowledged packets generate an interrupt
                    DISABLED = 0x0,
                    /// Both acknowledged and NAKed packets generate interrupts.
                    ENABLED = 0x1,
                },
                /// Device status - connect. The connect bit must be set by SW to indicate that the device must signal a connect. The pull-up resistor on USB_DP will be enabled when this bit is set and the VBUSDEBOUNCED bit is one.
                DCON: u1,
                /// Device status - suspend. The suspend bit indicates the current suspend state. It is set to 1 when the device hasn't seen any activity on its upstream port for more than 3 milliseconds. It is reset to 0 on any activity. When the device is suspended (Suspend bit DSUS = 1) and the software writes a 0 to it, the device will generate a remote wake-up. This will only happen when the device is connected (Connect bit = 1). When the device is not connected or not suspended, a writing a 0 has no effect. Writing a 1 never has an effect.
                DSUS: u1,
                reserved19: u1,
                /// Device status - LPM Suspend. This bit represents the current LPM suspend state. It is set to 1 by HW when the device has acknowledged the LPM request from the USB host and the Token Retry Time of 10 ms has elapsed. When the device is in the LPM suspended state (LPM suspend bit = 1) and the software writes a zero to this bit, the device will generate a remote walk-up. Software can only write a zero to this bit when the LPM_REWP bit is set to 1. HW resets this bit when it receives a host initiated resume. HW only updates the LPM_SUS bit when the LPM_SUPP bit is equal to one.
                LPM_SUS: u1,
                /// LPM Remote Wake-up Enabled by USB host. HW sets this bit to one when the bRemoteWake bit in the LPM extended token is set to 1. HW will reset this bit to 0 when it receives the host initiated LPM resume, when a remote wake-up is sent by the device or when a USB bus reset is received. Software can use this bit to check if the remote wake-up feature is enabled by the host for the LPM transaction.
                LPM_REWP: u1,
                reserved24: u3,
                /// Device status - connect change. The Connect Change bit is set when the device's pull-up resistor is disconnected because VBus disappeared. The bit is reset by writing a one to it.
                DCON_C: u1,
                /// Device status - suspend change. The suspend change bit is set to 1 when the suspend bit toggles. The suspend bit can toggle because: - The device goes in the suspended state - The device is disconnected - The device receives resume signaling on its upstream port. The bit is reset by writing a one to it.
                DSUS_C: u1,
                /// Device status - reset change. This bit is set when the device received a bus reset. On a bus reset the device will automatically go to the default state (unconfigured and responding to address 0). The bit is reset by writing a one to it.
                DRES_C: u1,
                reserved28: u1,
                /// This bit indicates if Vbus is detected or not. The bit raises immediately when Vbus becomes high. It drops to zero if Vbus is low for at least 3 ms. If this bit is high and the DCon bit is set, the HW will enable the pull-up resistor to signal a connect.
                VBUSDEBOUNCED: u1,
                padding: u3,
            }),
            /// USB Info register
            INFO: mmio.Mmio(packed struct(u32) {
                /// Frame number. This contains the frame number of the last successfully received SOF. In case no SOF was received by the device at the beginning of a frame, the frame number returned is that of the last successfully received SOF. In case the SOF frame number contained a CRC error, the frame number returned will be the corrupted frame number as received by the device.
                FRAME_NR: u11,
                /// The error code which last occurred:
                ERR_CODE: enum(u4) {
                    /// No error
                    NO_ERROR = 0x0,
                    /// PID encoding error
                    PID_ENCODING_ERROR = 0x1,
                    /// PID unknown
                    PID_UNKNOWN = 0x2,
                    /// Packet unexpected
                    PACKET_UNEXPECTED = 0x3,
                    /// Token CRC error
                    TOKEN_CRC_ERROR = 0x4,
                    /// Data CRC error
                    DATA_CRC_ERROR = 0x5,
                    /// Time out
                    TIMEOUT = 0x6,
                    /// Babble
                    BABBLE = 0x7,
                    /// Truncated EOP
                    TRUNCATED_EOP = 0x8,
                    /// Sent/Received NAK
                    SENT_RECEIVED_NAK = 0x9,
                    /// Sent Stall
                    SENT_STALL = 0xa,
                    /// Overrun
                    OVERRUN = 0xb,
                    /// Sent empty packet
                    SENT_EMPTY_PACKET = 0xc,
                    /// Bitstuff error
                    BITSTUFF_ERROR = 0xd,
                    /// Sync error
                    SYNC_ERROR = 0xe,
                    /// Wrong data toggle
                    WRONG_DATA_TOGGLE = 0xf,
                },
                reserved16: u1,
                /// Minor Revision.
                MINREV: u8,
                /// Major Revision.
                MAJREV: u8,
            }),
            /// USB EP Command/Status List start address
            EPLISTSTART: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                /// Start address of the USB EP Command/Status List.
                EP_LIST: u24,
            }),
            /// USB Data buffer start address
            DATABUFSTART: mmio.Mmio(packed struct(u32) {
                reserved22: u22,
                /// Start address of the buffer pointer page where all endpoint data buffers are located.
                DA_BUF: u10,
            }),
            /// USB Link Power Management register
            LPM: mmio.Mmio(packed struct(u32) {
                /// Host Initiated Resume Duration - HW. This is the HIRD value from the last received LPM token
                HIRD_HW: u4,
                /// Host Initiated Resume Duration - SW. This is the time duration required by the USB device system to come out of LPM initiated suspend after receiving the host initiated LPM resume.
                HIRD_SW: u4,
                /// As long as this bit is set to one and LPM supported bit is set to one, HW will return a NYET handshake on every LPM token it receives. If LPM supported bit is set to one and this bit is zero, HW will return an ACK handshake on every LPM token it receives. If SW has still data pending and LPM is supported, it must set this bit to 1.
                DATA_PENDING: u1,
                padding: u23,
            }),
            /// USB Endpoint skip
            EPSKIP: mmio.Mmio(packed struct(u32) {
                /// Endpoint skip: Writing 1 to one of these bits, will indicate to HW that it must deactivate the buffer assigned to this endpoint and return control back to software. When HW has deactivated the endpoint, it will clear this bit, but it will not modify the EPINUSE bit. An interrupt will be generated when the Active bit goes from 1 to 0. Note: In case of double-buffering, HW will only clear the Active bit of the buffer indicated by the EPINUSE bit.
                SKIP: u10,
                padding: u22,
            }),
            /// USB Endpoint Buffer in use
            EPINUSE: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Buffer in use: This register has one bit per physical endpoint. 0: HW is accessing buffer 0. 1: HW is accessing buffer 1.
                BUF: u8,
                padding: u22,
            }),
            /// USB Endpoint Buffer Configuration register
            EPBUFCFG: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Buffer usage: This register has one bit per physical endpoint. 0: Single-buffer. 1: Double-buffer. If the bit is set to single-buffer (0), it will not toggle the corresponding EPINUSE bit when it clears the active bit. If the bit is set to double-buffer (1), HW will toggle the EPINUSE bit when it clears the Active bit for the buffer.
                BUF_SB: u8,
                padding: u22,
            }),
            /// USB interrupt status register
            INTSTAT: mmio.Mmio(packed struct(u32) {
                /// Interrupt status register bit for the Control EP0 OUT direction. This bit will be set if NBytes transitions to zero or the skip bit is set by software or a SETUP packet is successfully received for the control EP0. If the IntOnNAK_CO is set, this bit will also be set when a NAK is transmitted for the Control EP0 OUT direction. Software can clear this bit by writing a one to it.
                EP0OUT: u1,
                /// Interrupt status register bit for the Control EP0 IN direction. This bit will be set if NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_CI is set, this bit will also be set when a NAK is transmitted for the Control EP0 IN direction. Software can clear this bit by writing a one to it.
                EP0IN: u1,
                /// Interrupt status register bit for the EP1 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP1 OUT direction. Software can clear this bit by writing a one to it.
                EP1OUT: u1,
                /// Interrupt status register bit for the EP1 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP1 IN direction. Software can clear this bit by writing a one to it.
                EP1IN: u1,
                /// Interrupt status register bit for the EP2 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP2 OUT direction. Software can clear this bit by writing a one to it.
                EP2OUT: u1,
                /// Interrupt status register bit for the EP2 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP2 IN direction. Software can clear this bit by writing a one to it.
                EP2IN: u1,
                /// Interrupt status register bit for the EP3 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP3 OUT direction. Software can clear this bit by writing a one to it.
                EP3OUT: u1,
                /// Interrupt status register bit for the EP3 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP3 IN direction. Software can clear this bit by writing a one to it.
                EP3IN: u1,
                /// Interrupt status register bit for the EP4 OUT direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AO is set, this bit will also be set when a NAK is transmitted for the EP4 OUT direction. Software can clear this bit by writing a one to it.
                EP4OUT: u1,
                /// Interrupt status register bit for the EP4 IN direction. This bit will be set if the corresponding Active bit is cleared by HW. This is done in case the programmed NBytes transitions to zero or the skip bit is set by software. If the IntOnNAK_AI is set, this bit will also be set when a NAK is transmitted for the EP4 IN direction. Software can clear this bit by writing a one to it.
                EP4IN: u1,
                reserved30: u20,
                /// Frame interrupt. This bit is set to one every millisecond when the VbusDebounced bit and the DCON bit are set. This bit can be used by software when handling isochronous endpoints. Software can clear this bit by writing a one to it.
                FRAME_INT: u1,
                /// Device status interrupt. This bit is set by HW when one of the bits in the Device Status Change register are set. Software can clear this bit by writing a one to it.
                DEV_INT: u1,
            }),
            /// USB interrupt enable register
            INTEN: mmio.Mmio(packed struct(u32) {
                /// If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit.
                EP_INT_EN: u10,
                reserved30: u20,
                /// If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit.
                FRAME_INT_EN: u1,
                /// If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line indicated by the corresponding USB interrupt routing bit.
                DEV_INT_EN: u1,
            }),
            /// USB set interrupt status register
            INTSETSTAT: mmio.Mmio(packed struct(u32) {
                /// If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned.
                EP_SET_INT: u10,
                reserved30: u20,
                /// If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned.
                FRAME_SET_INT: u1,
                /// If software writes a one to one of these bits, the corresponding USB interrupt status bit is set. When this register is read, the same value as the USB interrupt status register is returned.
                DEV_SET_INT: u1,
            }),
            reserved52: [8]u8,
            /// USB Endpoint toggle register
            EPTOGGLE: mmio.Mmio(packed struct(u32) {
                /// Endpoint data toggle: This field indicates the current value of the data toggle for the corresponding endpoint.
                TOGGLE: u10,
                padding: u22,
            }),
        };

        /// LPC5460x USB0 Full-speed Host controller
        pub const USBFSH = extern struct {
            /// BCD representation of the version of the HCI specification that is implemented by the Host Controller (HC)
            HCREVISION: mmio.Mmio(packed struct(u32) {
                /// Revision.
                REV: u8,
                padding: u24,
            }),
            /// Defines the operating modes of the HC
            HCCONTROL: mmio.Mmio(packed struct(u32) {
                /// ControlBulkServiceRatio.
                CBSR: u2,
                /// PeriodicListEnable.
                PLE: u1,
                /// IsochronousEnable.
                IE: u1,
                /// ControlListEnable.
                CLE: u1,
                /// BulkListEnable This bit is set to enable the processing of the Bulk list in the next Frame.
                BLE: u1,
                /// HostControllerFunctionalState for USB 00b: USBRESET 01b: USBRESUME 10b: USBOPERATIONAL 11b: USBSUSPEND A transition to USBOPERATIONAL from another state causes SOFgeneration to begin 1 ms later.
                HCFS: u2,
                /// InterruptRouting This bit determines the routing of interrupts generated by events registered in HcInterruptStatus.
                IR: u1,
                /// RemoteWakeupConnected This bit indicates whether HC supports remote wake-up signaling.
                RWC: u1,
                /// RemoteWakeupEnable This bit is used by HCD to enable or disable the remote wake-up feature upon the detection of upstream resume signaling.
                RWE: u1,
                padding: u21,
            }),
            /// This register is used to receive the commands from the Host Controller Driver (HCD)
            HCCOMMANDSTATUS: mmio.Mmio(packed struct(u32) {
                /// HostControllerReset This bit is set by HCD to initiate a software reset of HC.
                HCR: u1,
                /// ControlListFilled This bit is used to indicate whether there are any TDs on the Control list.
                CLF: u1,
                /// BulkListFilled This bit is used to indicate whether there are any TDs on the Bulk list.
                BLF: u1,
                /// OwnershipChangeRequest This bit is set by an OS HCD to request a change of control of the HC.
                OCR: u1,
                reserved6: u2,
                /// SchedulingOverrunCount These bits are incremented on each scheduling overrun error.
                SOC: u2,
                padding: u24,
            }),
            /// Indicates the status on various events that cause hardware interrupts by setting the appropriate bits
            HCINTERRUPTSTATUS: mmio.Mmio(packed struct(u32) {
                /// SchedulingOverrun This bit is set when the USB schedule for the current Frame overruns and after the update of HccaFrameNumber.
                SO: u1,
                /// WritebackDoneHead This bit is set immediately after HC has written HcDoneHead to HccaDoneHead.
                WDH: u1,
                /// StartofFrame This bit is set by HC at each start of a frame and after the update of HccaFrameNumber.
                SF: u1,
                /// ResumeDetected This bit is set when HC detects that a device on the USB is asserting resume signaling.
                RD: u1,
                /// UnrecoverableError This bit is set when HC detects a system error not related to USB.
                UE: u1,
                /// FrameNumberOverflow This bit is set when the MSb of HcFmNumber (bit 15) changes value, from 0 to 1 or from 1 to 0, and after HccaFrameNumber has been updated.
                FNO: u1,
                /// RootHubStatusChange This bit is set when the content of HcRhStatus or the content of any of HcRhPortStatus[NumberofDownstreamPort] has changed.
                RHSC: u1,
                reserved10: u3,
                /// OwnershipChange This bit is set by HC when HCD sets the OwnershipChangeRequest field in HcCommandStatus.
                OC: u22,
            }),
            /// Controls the bits in the HcInterruptStatus register and indicates which events will generate a hardware interrupt
            HCINTERRUPTENABLE: mmio.Mmio(packed struct(u32) {
                /// Scheduling Overrun interrupt.
                SO: u1,
                /// HcDoneHead Writeback interrupt.
                WDH: u1,
                /// Start of Frame interrupt.
                SF: u1,
                /// Resume Detect interrupt.
                RD: u1,
                /// Unrecoverable Error interrupt.
                UE: u1,
                /// Frame Number Overflow interrupt.
                FNO: u1,
                /// Root Hub Status Change interrupt.
                RHSC: u1,
                reserved30: u23,
                /// Ownership Change interrupt.
                OC: u1,
                /// Master Interrupt Enable.
                MIE: u1,
            }),
            /// The bits in this register are used to disable corresponding bits in the HCInterruptStatus register and in turn disable that event leading to hardware interrupt
            HCINTERRUPTDISABLE: mmio.Mmio(packed struct(u32) {
                /// Scheduling Overrun interrupt.
                SO: u1,
                /// HcDoneHead Writeback interrupt.
                WDH: u1,
                /// Start of Frame interrupt.
                SF: u1,
                /// Resume Detect interrupt.
                RD: u1,
                /// Unrecoverable Error interrupt.
                UE: u1,
                /// Frame Number Overflow interrupt.
                FNO: u1,
                /// Root Hub Status Change interrupt.
                RHSC: u1,
                reserved30: u23,
                /// Ownership Change interrupt.
                OC: u1,
                /// A 0 written to this field is ignored by HC.
                MIE: u1,
            }),
            /// Contains the physical address of the host controller communication area
            HCHCCA: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                /// Base address of the Host Controller Communication Area.
                HCCA: u24,
            }),
            /// Contains the physical address of the current isochronous or interrupt endpoint descriptor
            HCPERIODCURRENTED: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// The content of this register is updated by HC after a periodic ED is processed.
                PCED: u28,
            }),
            /// Contains the physical address of the first endpoint descriptor of the control list
            HCCONTROLHEADED: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// HC traverses the Control list starting with the HcControlHeadED pointer.
                CHED: u28,
            }),
            /// Contains the physical address of the current endpoint descriptor of the control list
            HCCONTROLCURRENTED: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// ControlCurrentED.
                CCED: u28,
            }),
            /// Contains the physical address of the first endpoint descriptor of the bulk list
            HCBULKHEADED: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// BulkHeadED HC traverses the bulk list starting with the HcBulkHeadED pointer.
                BHED: u28,
            }),
            /// Contains the physical address of the current endpoint descriptor of the bulk list
            HCBULKCURRENTED: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// BulkCurrentED This is advanced to the next ED after the HC has served the current one.
                BCED: u28,
            }),
            /// Contains the physical address of the last transfer descriptor added to the 'Done' queue
            HCDONEHEAD: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// DoneHead When a TD is completed, HC writes the content of HcDoneHead to the NextTD field of the TD.
                DH: u28,
            }),
            /// Defines the bit time interval in a frame and the full speed maximum packet size which would not cause an overrun
            HCFMINTERVAL: mmio.Mmio(packed struct(u32) {
                /// FrameInterval This specifies the interval between two consecutive SOFs in bit times.
                FI: u14,
                reserved16: u2,
                /// FSLargestDataPacket This field specifies a value which is loaded into the Largest Data Packet Counter at the beginning of each frame.
                FSMPS: u15,
                /// FrameIntervalToggle HCD toggles this bit whenever it loads a new value to FrameInterval.
                FIT: u1,
            }),
            /// A 14-bit counter showing the bit time remaining in the current frame
            HCFMREMAINING: mmio.Mmio(packed struct(u32) {
                /// FrameRemaining This counter is decremented at each bit time.
                FR: u14,
                reserved31: u17,
                /// FrameRemainingToggle This bit is loaded from the FrameIntervalToggle field of HcFmInterval whenever FrameRemaining reaches 0.
                FRT: u1,
            }),
            /// Contains a 16-bit counter and provides the timing reference among events happening in the HC and the HCD
            HCFMNUMBER: mmio.Mmio(packed struct(u32) {
                /// FrameNumber This is incremented when HcFmRemaining is re-loaded.
                FN: u16,
                padding: u16,
            }),
            /// Contains a programmable 14-bit value which determines the earliest time HC should start processing a periodic list
            HCPERIODICSTART: mmio.Mmio(packed struct(u32) {
                /// PeriodicStart After a hardware reset, this field is cleared and then set by HCD during the HC initialization.
                PS: u14,
                padding: u18,
            }),
            /// Contains 11-bit value which is used by the HC to determine whether to commit to transfer a maximum of 8-byte LS packet before EOF
            HCLSTHRESHOLD: mmio.Mmio(packed struct(u32) {
                /// LSThreshold This field contains a value which is compared to the FrameRemaining field prior to initiating a Low Speed transaction.
                LST: u12,
                padding: u20,
            }),
            /// First of the two registers which describes the characteristics of the root hub
            HCRHDESCRIPTORA: mmio.Mmio(packed struct(u32) {
                /// NumberDownstreamPorts These bits specify the number of downstream ports supported by the root hub.
                NDP: u8,
                /// PowerSwitchingMode This bit is used to specify how the power switching of the root hub ports is controlled.
                PSM: u1,
                /// NoPowerSwitching These bits are used to specify whether power switching is supported or port are always powered.
                NPS: u1,
                /// DeviceType This bit specifies that the root hub is not a compound device.
                DT: u1,
                /// OverCurrentProtectionMode This bit describes how the overcurrent status for the root hub ports are reported.
                OCPM: u1,
                /// NoOverCurrentProtection This bit describes how the overcurrent status for the root hub ports are reported.
                NOCP: u1,
                reserved24: u11,
                /// PowerOnToPowerGoodTime This byte specifies the duration the HCD has to wait before accessing a powered-on port of the root hub.
                POTPGT: u8,
            }),
            /// Second of the two registers which describes the characteristics of the Root Hub
            HCRHDESCRIPTORB: mmio.Mmio(packed struct(u32) {
                /// DeviceRemovable Each bit is dedicated to a port of the Root Hub.
                DR: u16,
                /// PortPowerControlMask Each bit indicates if a port is affected by a global power control command when PowerSwitchingMode is set.
                PPCM: u16,
            }),
            /// This register is divided into two parts
            HCRHSTATUS: mmio.Mmio(packed struct(u32) {
                /// (read) LocalPowerStatus The Root Hub does not support the local power status feature; thus, this bit is always read as 0.
                LPS: u1,
                /// OverCurrentIndicator This bit reports overcurrent conditions when the global reporting is implemented.
                OCI: u1,
                reserved15: u13,
                /// (read) DeviceRemoteWakeupEnable This bit enables a ConnectStatusChange bit as a resume event, causing a USBSUSPEND to USBRESUME state transition and setting the ResumeDetected interrupt.
                DRWE: u1,
                /// (read) LocalPowerStatusChange The root hub does not support the local power status feature.
                LPSC: u1,
                /// OverCurrentIndicatorChange This bit is set by hardware when a change has occurred to the OCI field of this register.
                OCIC: u1,
                reserved31: u13,
                /// (write) ClearRemoteWakeupEnable Writing a 1 clears DeviceRemoveWakeupEnable.
                CRWE: u1,
            }),
            /// Controls and reports the port events on a per-port basis
            HCRHPORTSTATUS: mmio.Mmio(packed struct(u32) {
                /// (read) CurrentConnectStatus This bit reflects the current state of the downstream port.
                CCS: u1,
                /// (read) PortEnableStatus This bit indicates whether the port is enabled or disabled.
                PES: u1,
                /// (read) PortSuspendStatus This bit indicates the port is suspended or in the resume sequence.
                PSS: u1,
                /// (read) PortOverCurrentIndicator This bit is only valid when the Root Hub is configured in such a way that overcurrent conditions are reported on a per-port basis.
                POCI: u1,
                /// (read) PortResetStatus When this bit is set by a write to SetPortReset, port reset signaling is asserted.
                PRS: u1,
                reserved8: u3,
                /// (read) PortPowerStatus This bit reflects the porta's power status, regardless of the type of power switching implemented.
                PPS: u1,
                /// (read) LowSpeedDeviceAttached This bit indicates the speed of the device attached to this port.
                LSDA: u1,
                reserved16: u6,
                /// ConnectStatusChange This bit is set whenever a connect or disconnect event occurs.
                CSC: u1,
                /// PortEnableStatusChange This bit is set when hardware events cause the PortEnableStatus bit to be cleared.
                PESC: u1,
                /// PortSuspendStatusChange This bit is set when the full resume sequence is completed.
                PSSC: u1,
                /// PortOverCurrentIndicatorChange This bit is valid only if overcurrent conditions are reported on a per-port basis.
                OCIC: u1,
                /// PortResetStatusChange This bit is set at the end of the 10 ms port reset signal.
                PRSC: u1,
                padding: u11,
            }),
            reserved92: [4]u8,
            /// Controls the port if it is attached to the host block or the device block
            PORTMODE: mmio.Mmio(packed struct(u32) {
                /// Port ID pin value.
                ID: u1,
                reserved8: u7,
                /// Port ID pin pull-up enable.
                ID_EN: u1,
                reserved16: u7,
                /// 1: device 0: host.
                DEV_ENABLE: u1,
                padding: u15,
            }),
        };

        /// LPC5460x USB1 High-speed Device Controller
        pub const USBHSD = extern struct {
            /// USB Device Command/Status register
            DEVCMDSTAT: mmio.Mmio(packed struct(u32) {
                /// USB device address.
                DEV_ADDR: u7,
                /// USB device enable.
                DEV_EN: u1,
                /// SETUP token received.
                SETUP: u1,
                /// Forces the NEEDCLK output to always be on:.
                FORCE_NEEDCLK: u1,
                /// If this bit is set to 1, the VBUS voltage indicators from the PHY are overruled.
                FORCE_VBUS: u1,
                /// LPM Supported:.
                LPM_SUP: u1,
                /// Interrupt on NAK for interrupt and bulk OUT EP:.
                INTONNAK_AO: u1,
                /// Interrupt on NAK for interrupt and bulk IN EP:.
                INTONNAK_AI: u1,
                /// Interrupt on NAK for control OUT EP:.
                INTONNAK_CO: u1,
                /// Interrupt on NAK for control IN EP:.
                INTONNAK_CI: u1,
                /// Device status - connect.
                DCON: u1,
                /// Device status - suspend.
                DSUS: u1,
                reserved19: u1,
                /// Device status - LPM Suspend.
                LPM_SUS: u1,
                /// LPM Remote Wake-up Enabled by USB host.
                LPM_REWP: u1,
                reserved22: u1,
                /// This field indicates the speed at which the device operates: 00b: reserved 01b: full-speed 10b: high-speed 11b: super-speed (reserved for future use).
                Speed: u2,
                /// Device status - connect change.
                DCON_C: u1,
                /// Device status - suspend change.
                DSUS_C: u1,
                /// Device status - reset change.
                DRES_C: u1,
                reserved28: u1,
                /// This bit indicates if VBUS is detected or not.
                VBUS_DEBOUNCED: u1,
                /// This field is written by firmware to put the PHY into a test mode as defined by the USB2.
                PHY_TEST_MODE: u3,
            }),
            /// USB Info register
            INFO: mmio.Mmio(packed struct(u32) {
                /// Frame number.
                FRAME_NR: u11,
                /// The error code which last occurred:.
                ERR_CODE: u4,
                reserved16: u1,
                /// Minor revision.
                Minrev: u8,
                /// Major revision.
                Majrev: u8,
            }),
            /// USB EP Command/Status List start address
            EPLISTSTART: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                /// Programmable portion of the USB EP Command/Status List address.
                EP_LIST_PRG: u12,
                /// Fixed portion of USB EP Command/Status List address.
                EP_LIST_FIXED: u12,
            }),
            /// USB Data buffer start address
            DATABUFSTART: mmio.Mmio(packed struct(u32) {
                /// Start address of the memory page where all endpoint data buffers are located.
                DA_BUF: u32,
            }),
            /// USB Link Power Management register
            LPM: mmio.Mmio(packed struct(u32) {
                /// Host Initiated Resume Duration - HW.
                HIRD_HW: u4,
                /// Host Initiated Resume Duration - SW.
                HIRD_SW: u4,
                /// As long as this bit is set to one and LPM supported bit is set to one, HW will return a NYET handshake on every LPM token it receives.
                DATA_PENDING: u1,
                padding: u23,
            }),
            /// USB Endpoint skip
            EPSKIP: mmio.Mmio(packed struct(u32) {
                /// Endpoint skip: Writing 1 to one of these bits, will indicate to HW that it must deactivate the buffer assigned to this endpoint and return control back to software.
                SKIP: u12,
                padding: u20,
            }),
            /// USB Endpoint Buffer in use
            EPINUSE: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Buffer in use: This register has one bit per physical endpoint.
                BUF: u10,
                padding: u20,
            }),
            /// USB Endpoint Buffer Configuration register
            EPBUFCFG: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Buffer usage: This register has one bit per physical endpoint.
                BUF_SB: u10,
                padding: u20,
            }),
            /// USB interrupt status register
            INTSTAT: mmio.Mmio(packed struct(u32) {
                /// Interrupt status register bit for the Control EP0 OUT direction.
                EP0OUT: u1,
                /// Interrupt status register bit for the Control EP0 IN direction.
                EP0IN: u1,
                /// Interrupt status register bit for the EP1 OUT direction.
                EP1OUT: u1,
                /// Interrupt status register bit for the EP1 IN direction.
                EP1IN: u1,
                /// Interrupt status register bit for the EP2 OUT direction.
                EP2OUT: u1,
                /// Interrupt status register bit for the EP2 IN direction.
                EP2IN: u1,
                /// Interrupt status register bit for the EP3 OUT direction.
                EP3OUT: u1,
                /// Interrupt status register bit for the EP3 IN direction.
                EP3IN: u1,
                /// Interrupt status register bit for the EP4 OUT direction.
                EP4OUT: u1,
                /// Interrupt status register bit for the EP4 IN direction.
                EP4IN: u1,
                /// Interrupt status register bit for the EP5 OUT direction.
                EP5OUT: u1,
                /// Interrupt status register bit for the EP5 IN direction.
                EP5IN: u1,
                reserved30: u18,
                /// Frame interrupt.
                FRAME_INT: u1,
                /// Device status interrupt.
                DEV_INT: u1,
            }),
            /// USB interrupt enable register
            INTEN: mmio.Mmio(packed struct(u32) {
                /// If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line.
                EP_INT_EN: u12,
                reserved30: u18,
                /// If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line.
                FRAME_INT_EN: u1,
                /// If this bit is set and the corresponding USB interrupt status bit is set, a HW interrupt is generated on the interrupt line.
                DEV_INT_EN: u1,
            }),
            /// USB set interrupt status register
            INTSETSTAT: mmio.Mmio(packed struct(u32) {
                /// If software writes a one to one of these bits, the corresponding USB interrupt status bit is set.
                EP_SET_INT: u12,
                reserved30: u18,
                /// If software writes a one to one of these bits, the corresponding USB interrupt status bit is set.
                FRAME_SET_INT: u1,
                /// If software writes a one to one of these bits, the corresponding USB interrupt status bit is set.
                DEV_SET_INT: u1,
            }),
            reserved52: [8]u8,
            /// USB Endpoint toggle register
            EPTOGGLE: mmio.Mmio(packed struct(u32) {
                /// Endpoint data toggle: This field indicates the current value of the data toggle for the corresponding endpoint.
                TOGGLE: u30,
                padding: u2,
            }),
            reserved60: [4]u8,
            /// UTMI/ULPI debug register
            ULPIDEBUG: mmio.Mmio(packed struct(u32) {
                /// ULPI mode: Bits 7:0 are used as the address when doing a register access over the ULPI interface.
                PHY_ADDR: u8,
                /// UTMI+ mode: Reserved.
                PHY_WDATA: u8,
                /// UTMI+ mode: Bits 7:0 contains the value returned by the VStatus signal on Vendor Interface of UTMI+.
                PHY_RDATA: u8,
                /// UTMI+ mode: Reserved.
                PHY_RW: u1,
                /// Software writes this bit to one to start a read or write operation.
                PHY_ACCESS: u1,
                reserved31: u5,
                /// This bit indicates if the interface between the controller is UTMI+ or ULPI.
                PHY_MODE: u1,
            }),
        };

        /// LPC5460x USB1 High-speed Host Controller
        pub const USBHSH = extern struct {
            /// This register contains the offset value towards the start of the operational register space and the version number of the IP block
            CAPLENGTH_CHIPID: mmio.Mmio(packed struct(u32) {
                /// Capability Length: This is used as an offset.
                CAPLENGTH: u8,
                reserved16: u8,
                /// Chip identification: indicates major and minor revision of the IP: [31:24] = Major revision [23:16] = Minor revision Major revisions used: 0x01: USB2.
                CHIPID: u16,
            }),
            /// Host Controller Structural Parameters
            HCSPARAMS: mmio.Mmio(packed struct(u32) {
                /// This register specifies the number of physical downstream ports implemented on this host controller.
                N_PORTS: u4,
                /// This field indicates whether the host controller implementation includes port power control.
                PPC: u1,
                reserved16: u11,
                /// This bit indicates whether the ports support port indicator control.
                P_INDICATOR: u1,
                padding: u15,
            }),
            /// Host Controller Capability Parameters
            HCCPARAMS: mmio.Mmio(packed struct(u32) {
                reserved17: u17,
                /// Link Power Management Capability.
                LPMC: u1,
                padding: u14,
            }),
            /// Frame Length Adjustment
            FLADJ_FRINDEX: mmio.Mmio(packed struct(u32) {
                /// Frame Length Timing Value.
                FLADJ: u6,
                reserved16: u10,
                /// Frame Index: Bits 29 to16 in this register are used for the frame number field in the SOF packet.
                FRINDEX: u14,
                padding: u2,
            }),
            /// Memory base address where ATL PTD0 is stored
            ATL_PTD_BASE_ADDR: mmio.Mmio(packed struct(u32) {
                reserved4: u4,
                /// This indicates the current PTD that is used by the hardware when it is processing the ATL list.
                ATL_CUR: u5,
                /// Base address to be used by the hardware to find the start of the ATL list.
                ATL_BASE: u23,
            }),
            /// Memory base address where ISO PTD0 is stored
            ISO_PTD_BASE_ADDR: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                /// This indicates the first PTD that is used by the hardware when it is processing the ISO list.
                ISO_FIRST: u5,
                /// Base address to be used by the hardware to find the start of the ISO list.
                ISO_BASE: u22,
            }),
            /// Memory base address where INT PTD0 is stored
            INT_PTD_BASE_ADDR: mmio.Mmio(packed struct(u32) {
                reserved5: u5,
                /// This indicates the first PTD that is used by the hardware when it is processing the INT list.
                INT_FIRST: u5,
                /// Base address to be used by the hardware to find the start of the INT list.
                INT_BASE: u22,
            }),
            /// Memory base address that indicates the start of the data payload buffers
            DATA_PAYLOAD_BASE_ADDR: mmio.Mmio(packed struct(u32) {
                reserved16: u16,
                /// Base address to be used by the hardware to find the start of the data payload section.
                DAT_BASE: u16,
            }),
            /// USB Command register
            USBCMD: mmio.Mmio(packed struct(u32) {
                /// Run/Stop: 1b = Run.
                RS: u1,
                /// Host Controller Reset: This control bit is used by the software to reset the host controller.
                HCRESET: u1,
                /// Frame List Size: This field specifies the size of the frame list.
                FLS: u2,
                reserved7: u3,
                /// Light Host Controller Reset: This bit allows the driver software to reset the host controller without affecting the state of the ports.
                LHCR: u1,
                /// ATL List enabled.
                ATL_EN: u1,
                /// ISO List enabled.
                ISO_EN: u1,
                /// INT List enabled.
                INT_EN: u1,
                reserved24: u13,
                /// Host-Initiated Resume Duration.
                HIRD: u4,
                /// bRemoteWake field.
                LPM_RWU: u1,
                padding: u3,
            }),
            /// USB Interrupt Status register
            USBSTS: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Port Change Detect: The host controller sets this bit to logic 1 when any port has a change bit transition from a 0 to a one or a Force Port Resume bit transition from a 0 to a 1 as a result of a J-K transition detected on a suspended port.
                PCD: u1,
                /// Frame List Rollover: The host controller sets this bit to logic 1 when the frame list index rolls over its maximum value to 0.
                FLR: u1,
                reserved16: u12,
                /// ATL IRQ: Indicates that an ATL PTD (with I-bit set) was completed.
                ATL_IRQ: u1,
                /// ISO IRQ: Indicates that an ISO PTD (with I-bit set) was completed.
                ISO_IRQ: u1,
                /// INT IRQ: Indicates that an INT PTD (with I-bit set) was completed.
                INT_IRQ: u1,
                /// SOF interrupt: Every time when the host sends a Start of Frame token on the USB bus, this bit is set.
                SOF_IRQ: u1,
                padding: u12,
            }),
            /// USB Interrupt Enable register
            USBINTR: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                /// Port Change Detect Interrupt Enable: 1: enable 0: disable.
                PCDE: u1,
                /// Frame List Rollover Interrupt Enable: 1: enable 0: disable.
                FLRE: u1,
                reserved16: u12,
                /// ATL IRQ Enable bit: 1: enable 0: disable.
                ATL_IRQ_E: u1,
                /// ISO IRQ Enable bit: 1: enable 0: disable.
                ISO_IRQ_E: u1,
                /// INT IRQ Enable bit: 1: enable 0: disable.
                INT_IRQ_E: u1,
                /// SOF Interrupt Enable bit: 1: enable 0: disable.
                SOF_E: u1,
                padding: u12,
            }),
            /// Port Status and Control register
            PORTSC1: mmio.Mmio(packed struct(u32) {
                /// Current Connect Status: Logic 1 indicates a device is present on the port.
                CCS: u1,
                /// Connect Status Change: Logic 1 means that the value of CCS has changed.
                CSC: u1,
                /// Port Enabled/Disabled.
                PED: u1,
                /// Port Enabled/Disabled Change: Logic 1 means that the value of PED has changed.
                PEDC: u1,
                /// Over-current active: Logic 1 means that this port has an over-current condition.
                OCA: u1,
                /// Over-current change: Logic 1 means that the value of OCA has changed.
                OCC: u1,
                /// Force Port Resume: Logic 1 means resume (K-state) detected or driven on the port.
                FPR: u1,
                /// Suspend: Logic 1 means port is in the suspend state.
                SUSP: u1,
                /// Port Reset: Logic 1 means the port is in the reset state.
                PR: u1,
                /// Suspend using L1 0b = Suspend using L2 1b = Suspend using L1 When this bit is set to a 1 and a non-zero value is specified in the Device Address field, the host controller will generate an LPM Token to enter the L1 state whenever software writes a one to the Suspend bit, as well as L1 exit timing during any device or host-initiated resume.
                SUS_L1: u1,
                /// Line Status: This field reflects the current logical levels of the DP (bit 11) and DM (bit 10) signal lines.
                LS: u2,
                /// Port Power: The function of this bit depends on the value of the Port Power Control (PPC) bit in the HCSPARAMS register.
                PP: u1,
                reserved14: u1,
                /// Port Indicator Control : Writing to this field has no effect if the P_INDICATOR bit in the HCSPARAMS register is logic 0.
                PIC: u2,
                /// Port Test Control: A non-zero value indicates that the port is operating in the test mode as indicated by the value.
                PTC: u4,
                /// Port Speed: 00b: Low-speed 01b: Full-speed 10b: High-speed 11b: Reserved.
                PSPD: u2,
                /// Wake on overcurrent enable: Writing this bit to a one enables the port to be sensitive to overcurrent conditions as wake-up events.
                WOO: u1,
                /// These two bits are used by software to determine whether the most recent L1 suspend request was successful: 00b: Success-state transition was successful (ACK) 01b: Not Yet - Device was unable to enter the L1 state at this time (NYET) 10b: Not supported - Device does not support the L1 state (STALL) 11b: Timeout/Error - Device failed to respond or an error occurred.
                SUS_STAT: u2,
                /// Device Address for LPM tokens.
                DEV_ADD: u7,
            }),
            /// Done map for each ATL PTD
            ATL_PTD_DONE_MAP: mmio.Mmio(packed struct(u32) {
                /// The bit corresponding to a certain PTD will be set to logic 1 as soon as that PTD execution is completed.
                ATL_DONE: u32,
            }),
            /// Skip map for each ATL PTD
            ATL_PTD_SKIP_MAP: mmio.Mmio(packed struct(u32) {
                /// When a bit in the PTD Skip Map is set to logic 1, the corresponding PTD will be skipped, independent of the V bit setting.
                ATL_SKIP: u32,
            }),
            /// Done map for each ISO PTD
            ISO_PTD_DONE_MAP: mmio.Mmio(packed struct(u32) {
                /// The bit corresponding to a certain PTD will be set to logic 1 as soon as that PTD execution is completed.
                ISO_DONE: u32,
            }),
            /// Skip map for each ISO PTD
            ISO_PTD_SKIP_MAP: mmio.Mmio(packed struct(u32) {
                /// The bit corresponding to a certain PTD will be set to logic 1 as soon as that PTD execution is completed.
                ISO_SKIP: u32,
            }),
            /// Done map for each INT PTD
            INT_PTD_DONE_MAP: mmio.Mmio(packed struct(u32) {
                /// The bit corresponding to a certain PTD will be set to logic 1 as soon as that PTD execution is completed.
                INT_DONE: u32,
            }),
            /// Skip map for each INT PTD
            INT_PTD_SKIP_MAP: mmio.Mmio(packed struct(u32) {
                /// When a bit in the PTD Skip Map is set to logic 1, the corresponding PTD will be skipped, independent of the V bit setting.
                INT_SKIP: u32,
            }),
            /// Marks the last PTD in the list for ISO, INT and ATL
            LAST_PTD_INUSE: mmio.Mmio(packed struct(u32) {
                /// If hardware has reached this PTD and the J bit is not set, it will go to PTD0 as the next PTD to be processed.
                ATL_LAST: u5,
                reserved8: u3,
                /// This indicates the last PTD in the ISO list.
                ISO_LAST: u5,
                reserved16: u3,
                /// This indicates the last PTD in the INT list.
                INT_LAST: u5,
                padding: u11,
            }),
            /// Register to read/write registers in the attached USB PHY
            UTMIPLUS_ULPI_DEBUG: mmio.Mmio(packed struct(u32) {
                /// UTMI+ mode: Bits 3:0 are used to control VControl signal on Vendor Interface of UTMI+ ULPI mode: Bits 7:0 are used as the address when doing a register access over the ULPI interface.
                PHY_ADDR: u8,
                /// UTMI+ mode: Reserved.
                PHY_WDATA: u8,
                /// UTMI+ mode: Bits 7:0 contains the value returned by the VStatus signal on Vendor Interface of UTMI+ ULPI mode: Bits 7:0 are used for the read data when reading a value to a ULPI PHY register.
                PHY_RDATA: u8,
                /// UTMI+ mode: Reserved.
                PHY_RW: u1,
                /// Software writes this bit to one to start a read or write operation.
                PHY_ACCESS: u1,
                reserved31: u5,
                /// This bit indicates if the interface between the controller is UTMI+ or ULPI 0b: UTMI+ 1b: ULPI If the hardware supports both modes, this bit is RW by SW.
                PHY_MODE: u1,
            }),
            /// Controls the port if it is attached to the host block or the device block
            PORTMODE: mmio.Mmio(packed struct(u32) {
                /// Port 0 ID pin value.
                ID0: u1,
                reserved8: u7,
                /// Port 0 ID pin pull-up enable.
                ID0_EN: u1,
                reserved16: u7,
                /// If this bit is set to one, one of the ports will behave as a USB device.
                DEV_ENABLE: u1,
                reserved18: u1,
                /// This bit indicates if the PHY power-down input is controlled by software or by hardware.
                SW_CTRL_PDCOM: u1,
                /// This bit is only used when SW_CTRL_PDCOM is set to 1b.
                SW_PDCOM: u1,
                padding: u12,
            }),
        };

        /// LPC5411x Micro-tick Timer (UTICK)
        pub const UTICK0 = extern struct {
            /// Control register.
            CTRL: mmio.Mmio(packed struct(u32) {
                /// Tick interval value. The delay will be equal to DELAYVAL + 1 periods of the timer clock. The minimum usable value is 1, for a delay of 2 timer clocks. A value of 0 stops the timer.
                DELAYVAL: u31,
                /// Repeat delay. 0 = One-time delay. 1 = Delay repeats continuously.
                REPEAT: u1,
            }),
            /// Status register.
            STAT: mmio.Mmio(packed struct(u32) {
                /// Interrupt flag. 0 = No interrupt is pending. 1 = An interrupt is pending. A write of any value to this register clears this flag.
                INTR: u1,
                /// Active flag. 0 = The Micro-Tick Timer is stopped. 1 = The Micro-Tick Timer is currently active.
                ACTIVE: u1,
                padding: u30,
            }),
            /// Capture configuration register.
            CFG: mmio.Mmio(packed struct(u32) {
                /// Enable Capture 0. 1 = Enabled, 0 = Disabled.
                CAPEN0: u1,
                /// Enable Capture 1. 1 = Enabled, 0 = Disabled.
                CAPEN1: u1,
                /// Enable Capture 2. 1 = Enabled, 0 = Disabled.
                CAPEN2: u1,
                /// Enable Capture 3. 1 = Enabled, 0 = Disabled.
                CAPEN3: u1,
                reserved8: u4,
                /// Capture Polarity 0. 0 = Positive edge capture, 1 = Negative edge capture.
                CAPPOL0: u1,
                /// Capture Polarity 1. 0 = Positive edge capture, 1 = Negative edge capture.
                CAPPOL1: u1,
                /// Capture Polarity 2. 0 = Positive edge capture, 1 = Negative edge capture.
                CAPPOL2: u1,
                /// Capture Polarity 3. 0 = Positive edge capture, 1 = Negative edge capture.
                CAPPOL3: u1,
                padding: u20,
            }),
            /// Capture clear register.
            CAPCLR: mmio.Mmio(packed struct(u32) {
                /// Clear capture 0. Writing 1 to this bit clears the CAP0 register value.
                CAPCLR0: u1,
                /// Clear capture 1. Writing 1 to this bit clears the CAP1 register value.
                CAPCLR1: u1,
                /// Clear capture 2. Writing 1 to this bit clears the CAP2 register value.
                CAPCLR2: u1,
                /// Clear capture 3. Writing 1 to this bit clears the CAP3 register value.
                CAPCLR3: u1,
                padding: u28,
            }),
            /// Capture register .
            CAP: [4]mmio.Mmio(packed struct(u32) {
                /// Capture value for the related capture event (UTICK_CAPn. Note: the value is 1 lower than the actual value of the Micro-tick Timer at the moment of the capture event.
                CAP_VALUE: u31,
                /// Capture Valid. When 1, a value has been captured based on a transition of the related UTICK_CAPn pin. Cleared by writing to the related bit in the CAPCLR register.
                VALID: u1,
            }),
        };

        /// LPC5411x Windowed Watchdog Timer (WWDT)
        pub const WWDT = extern struct {
            /// Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.
            MOD: mmio.Mmio(packed struct(u32) {
                /// Watchdog enable bit. Once this bit is set to one and a watchdog feed is performed, the watchdog timer will run permanently.
                WDEN: enum(u1) {
                    /// Stop. The watchdog timer is stopped.
                    STOP = 0x0,
                    /// Run. The watchdog timer is running.
                    RUN = 0x1,
                },
                /// Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be re-written with a 0.
                WDRESET: enum(u1) {
                    /// Interrupt. A watchdog time-out will not cause a chip reset.
                    INTERRUPT = 0x0,
                    /// Reset. A watchdog time-out will cause a chip reset.
                    RESET = 0x1,
                },
                /// Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software writing a 0 to this bit position. Causes a chip reset if WDRESET = 1.
                WDTOF: u1,
                /// Warning interrupt flag. Set when the timer is at or below the value in WDWARNINT. Cleared by software writing a 1 to this bit position. Note that this bit cannot be cleared while the WARNINT value is equal to the value of the TV register. This can occur if the value of WARNINT is 0 and the WDRESET bit is 0 when TV decrements to 0.
                WDINT: u1,
                /// Watchdog update mode. This bit can be set once by software and is only cleared by a reset.
                WDPROTECT: enum(u1) {
                    /// Flexible. The watchdog time-out value (TC) can be changed at any time.
                    FLEXIBLE = 0x0,
                    /// Threshold. The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW.
                    THRESHOLD = 0x1,
                },
                /// Once this bit is set to one and a watchdog feed is performed, disabling or powering down the watchdog oscillator is prevented by hardware. This bit can be set once by software and is only cleared by any reset.
                LOCK: u1,
                padding: u26,
            }),
            /// Watchdog timer constant register. This 24-bit register determines the time-out value.
            TC: mmio.Mmio(packed struct(u32) {
                /// Watchdog time-out value.
                COUNT: u24,
                padding: u8,
            }),
            /// Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in TC.
            FEED: mmio.Mmio(packed struct(u32) {
                /// Feed value should be 0xAA followed by 0x55.
                FEED: u8,
                padding: u24,
            }),
            /// Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer.
            TV: mmio.Mmio(packed struct(u32) {
                /// Counter timer value.
                COUNT: u24,
                padding: u8,
            }),
            reserved20: [4]u8,
            /// Watchdog Warning Interrupt compare value.
            WARNINT: mmio.Mmio(packed struct(u32) {
                /// Watchdog warning interrupt compare value.
                WARNINT: u10,
                padding: u22,
            }),
            /// Watchdog Window compare value.
            WINDOW: mmio.Mmio(packed struct(u32) {
                /// Watchdog window value.
                WINDOW: u24,
                padding: u8,
            }),
        };
    };
};
